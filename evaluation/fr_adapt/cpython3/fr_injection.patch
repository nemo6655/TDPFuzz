diff --git a/Modules/_xxtestfuzz/fuzzer.c b/Modules/_xxtestfuzz/fuzzer.c
index 6ea9f64d628..49847c7e0ae 100644
--- a/Modules/_xxtestfuzz/fuzzer.c
+++ b/Modules/_xxtestfuzz/fuzzer.c
@@ -1,714 +1,1484 @@
+#ifdef FRCOV
+#define FIXREVERTER_SIZE 7736
+short FIXREVERTER[FIXREVERTER_SIZE];
+#endif
+#include <stdio.h>
 /* A fuzz test for CPython.
 
+
+
   The only exposed function is LLVMFuzzerTestOneInput, which is called by
+
   fuzzers and by the _fuzz module for smoke tests.
 
+
+
   To build exactly one fuzz test, as when running in oss-fuzz etc.,
+
   build with -D _Py_FUZZ_ONE and -D _Py_FUZZ_<test_name>. e.g. to build
+
   LLVMFuzzerTestOneInput to only run "fuzz_builtin_float", build this file with
+
       -D _Py_FUZZ_ONE -D _Py_FUZZ_fuzz_builtin_float.
 
+
+
   See the source code for LLVMFuzzerTestOneInput for details. */
 
+
+
 #ifndef Py_BUILD_CORE
+
 #  define Py_BUILD_CORE 1
+
 #endif
 
+
+
 #include <Python.h>
+
 #include "pycore_pyhash.h"        // _Py_HashBytes()
+
 #include <stdlib.h>
+
 #include <inttypes.h>
 
+
+
 /*  Fuzz PyFloat_FromString as a proxy for float(str). */
+
 static int fuzz_builtin_float(const char* data, size_t size) {
+
     PyObject* s = PyBytes_FromStringAndSize(data, size);
+
     if (s == NULL) return 0;
+
     PyObject* f = PyFloat_FromString(s);
+
     if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_ValueError)) {
+
         PyErr_Clear();
+
     }
 
+
+
     Py_XDECREF(f);
+
     Py_DECREF(s);
+
     return 0;
+
 }
 
+
+
 #define MAX_INT_TEST_SIZE 0x10000
 
+
+
 /* Fuzz PyLong_FromUnicodeObject as a proxy for int(str). */
+
 static int fuzz_builtin_int(const char* data, size_t size) {
+
     /* Ignore test cases with very long ints to avoid timeouts
+
        int("9" * 1000000) is not a very interesting test caase */
+
     if (size > MAX_INT_TEST_SIZE) {
+
         return 0;
+
     }
+
     /* Pick a random valid base. (When the fuzzed function takes extra
+
        parameters, it's somewhat normal to hash the input to generate those
+
        parameters. We want to exercise all code paths, so we do so here.) */
+
     int base = _Py_HashBytes(data, size) % 37;
+
     if (base == 1) {
+
         // 1 is the only number between 0 and 36 that is not a valid base.
+
         base = 0;
+
     }
+
     if (base == -1) {
+
         return 0;  // An error occurred, bail early.
+
     }
+
     if (base < 0) {
+
         base = -base;
+
     }
 
+
+
     PyObject* s = PyUnicode_FromStringAndSize(data, size);
+
     if (s == NULL) {
+
         if (PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {
+
             PyErr_Clear();
+
         }
+
         return 0;
+
     }
+
     PyObject* l = PyLong_FromUnicodeObject(s, base);
+
     if (l == NULL && PyErr_ExceptionMatches(PyExc_ValueError)) {
+
         PyErr_Clear();
+
     }
+
     PyErr_Clear();
+
     Py_XDECREF(l);
+
     Py_DECREF(s);
+
     return 0;
+
 }
 
+
+
 /* Fuzz PyUnicode_FromStringAndSize as a proxy for unicode(str). */
+
 static int fuzz_builtin_unicode(const char* data, size_t size) {
+
     PyObject* s = PyUnicode_FromStringAndSize(data, size);
+
     if (s == NULL && PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {
+
         PyErr_Clear();
+
     }
+
     Py_XDECREF(s);
+
     return 0;
+
 }
 
 
+
+
+
 PyObject* struct_unpack_method = NULL;
+
 PyObject* struct_error = NULL;
+
 /* Called by LLVMFuzzerTestOneInput for initialization */
+
 static int init_struct_unpack(void) {
+
     /* Import struct.unpack */
+
     PyObject* struct_module = PyImport_ImportModule("struct");
+
     if (struct_module == NULL) {
+
         return 0;
+
     }
+
     struct_error = PyObject_GetAttrString(struct_module, "error");
+
     if (struct_error == NULL) {
+
         return 0;
+
     }
+
     struct_unpack_method = PyObject_GetAttrString(struct_module, "unpack");
+
     return struct_unpack_method != NULL;
+
 }
+
 /* Fuzz struct.unpack(x, y) */
+
 static int fuzz_struct_unpack(const char* data, size_t size) {
+
     /* Everything up to the first null byte is considered the
+
        format. Everything after is the buffer */
+
     const char* first_null = memchr(data, '\0', size);
+
     if (first_null == NULL) {
+
         return 0;
+
     }
 
+
+
     size_t format_length = first_null - data;
+
     size_t buffer_length = size - format_length - 1;
 
+
+
     PyObject* pattern = PyBytes_FromStringAndSize(data, format_length);
+
     if (pattern == NULL) {
+
         return 0;
+
     }
+
     PyObject* buffer = PyBytes_FromStringAndSize(first_null + 1, buffer_length);
+
     if (buffer == NULL) {
+
         Py_DECREF(pattern);
+
         return 0;
+
     }
 
+
+
     PyObject* unpacked = PyObject_CallFunctionObjArgs(
+
         struct_unpack_method, pattern, buffer, NULL);
+
     /* Ignore any overflow errors, these are easily triggered accidentally */
+
     if (unpacked == NULL && PyErr_ExceptionMatches(PyExc_OverflowError)) {
+
         PyErr_Clear();
+
     }
+
     /* The pascal format string will throw a negative size when passing 0
+
        like: struct.unpack('0p', b'') */
+
     if (unpacked == NULL && PyErr_ExceptionMatches(PyExc_SystemError)) {
+
         PyErr_Clear();
+
     }
+
     /* Ignore any struct.error exceptions, these can be caused by invalid
+
        formats or incomplete buffers both of which are common. */
+
     if (unpacked == NULL && PyErr_ExceptionMatches(struct_error)) {
+
         PyErr_Clear();
+
     }
 
+
+
     Py_XDECREF(unpacked);
+
     Py_DECREF(pattern);
+
     Py_DECREF(buffer);
+
     return 0;
+
 }
 
 
+
+
+
 #define MAX_JSON_TEST_SIZE 0x100000
 
+
+
 PyObject* json_loads_method = NULL;
+
 /* Called by LLVMFuzzerTestOneInput for initialization */
+
 static int init_json_loads(void) {
+
     /* Import json.loads */
+
     PyObject* json_module = PyImport_ImportModule("json");
+
     if (json_module == NULL) {
+
         return 0;
+
     }
+
     json_loads_method = PyObject_GetAttrString(json_module, "loads");
+
     return json_loads_method != NULL;
+
 }
+
 /* Fuzz json.loads(x) */
+
 static int fuzz_json_loads(const char* data, size_t size) {
+
     /* Since python supports arbitrarily large ints in JSON,
+
        long inputs can lead to timeouts on boring inputs like
+
        `json.loads("9" * 100000)` */
+
     if (size > MAX_JSON_TEST_SIZE) {
+
         return 0;
+
     }
+
     PyObject* input_bytes = PyBytes_FromStringAndSize(data, size);
+
     if (input_bytes == NULL) {
+
         return 0;
+
     }
+
     PyObject* parsed = PyObject_CallOneArg(json_loads_method, input_bytes);
+
     if (parsed == NULL) {
+
         /* Ignore ValueError as the fuzzer will more than likely
+
            generate some invalid json and values */
+
         if (PyErr_ExceptionMatches(PyExc_ValueError) ||
+
         /* Ignore RecursionError as the fuzzer generates long sequences of
+
            arrays such as `[[[...` */
+
             PyErr_ExceptionMatches(PyExc_RecursionError) ||
+
         /* Ignore unicode errors, invalid byte sequences are common */
+
             PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)
+
         ) {
+
             PyErr_Clear();
+
         }
+
     }
+
     Py_DECREF(input_bytes);
+
     Py_XDECREF(parsed);
+
     return 0;
+
 }
 
+
+
 #define MAX_RE_TEST_SIZE 0x10000
 
+
+
 PyObject* re_compile_method = NULL;
+
 PyObject* re_error_exception = NULL;
+
 int RE_FLAG_DEBUG = 0;
+
 /* Called by LLVMFuzzerTestOneInput for initialization */
+
 static int init_sre_compile(void) {
+
     /* Import sre_compile.compile and sre.error */
+
     PyObject* re_module = PyImport_ImportModule("re");
+
     if (re_module == NULL) {
+
         return 0;
+
     }
+
     re_compile_method = PyObject_GetAttrString(re_module, "compile");
+
     if (re_compile_method == NULL) {
+
         return 0;
+
     }
 
+
+
     re_error_exception = PyObject_GetAttrString(re_module, "error");
+
     if (re_error_exception == NULL) {
+
         return 0;
+
     }
+
     PyObject* debug_flag = PyObject_GetAttrString(re_module, "DEBUG");
+
     if (debug_flag == NULL) {
+
         return 0;
+
     }
+
     RE_FLAG_DEBUG = PyLong_AsLong(debug_flag);
+
     return 1;
+
 }
+
 /* Fuzz re.compile(x) */
+
 static int fuzz_sre_compile(const char* data, size_t size) {
+
     /* Ignore really long regex patterns that will timeout the fuzzer */
+
     if (size > MAX_RE_TEST_SIZE) {
+
         return 0;
+
     }
+
     /* We treat the first 2 bytes of the input as a number for the flags */
+
     if (size < 2) {
+
         return 0;
+
     }
+
     uint16_t flags = ((uint16_t*) data)[0];
+
     /* We remove the SRE_FLAG_DEBUG if present. This is because it
+
        prints to stdout which greatly decreases fuzzing speed */
+
     flags &= ~RE_FLAG_DEBUG;
 
+
+
     /* Pull the pattern from the remaining bytes */
+
     PyObject* pattern_bytes = PyBytes_FromStringAndSize(data + 2, size - 2);
+
     if (pattern_bytes == NULL) {
+
         return 0;
+
     }
+
     PyObject* flags_obj = PyLong_FromUnsignedLong(flags);
+
     if (flags_obj == NULL) {
+
         Py_DECREF(pattern_bytes);
+
         return 0;
+
     }
 
+
+
     /* compiled = re.compile(data[2:], data[0:2] */
+
     PyObject* compiled = PyObject_CallFunctionObjArgs(
+
         re_compile_method, pattern_bytes, flags_obj, NULL);
+
     /* Ignore ValueError as the fuzzer will more than likely
+
        generate some invalid combination of flags */
+
     if (compiled == NULL && PyErr_ExceptionMatches(PyExc_ValueError)) {
+
         PyErr_Clear();
+
     }
+
     /* Ignore some common errors thrown by sre_parse:
+
        Overflow, Assertion, Recursion and Index */
+
     if (compiled == NULL && (PyErr_ExceptionMatches(PyExc_OverflowError) ||
+
                              PyErr_ExceptionMatches(PyExc_AssertionError) ||
+
                              PyErr_ExceptionMatches(PyExc_RecursionError) ||
+
                              PyErr_ExceptionMatches(PyExc_IndexError))
+
     ) {
+
         PyErr_Clear();
+
     }
+
     /* Ignore re.error */
+
     if (compiled == NULL && PyErr_ExceptionMatches(re_error_exception)) {
+
         PyErr_Clear();
+
     }
 
+
+
     Py_DECREF(pattern_bytes);
+
     Py_DECREF(flags_obj);
+
     Py_XDECREF(compiled);
+
     return 0;
+
 }
 
+
+
 /* Some random patterns used to test re.match.
+
    Be careful not to add catostraphically slow regexes here, we want to
+
    exercise the matching code without causing timeouts.*/
+
 static const char* regex_patterns[] = {
+
     ".", "^", "abc", "abc|def", "^xxx$", "\\b", "()", "[a-zA-Z0-9]",
+
     "abc+", "[^A-Z]", "[x]", "(?=)", "a{z}", "a+b", "a*?", "a??", "a+?",
+
     "{}", "a{,}", "{", "}", "^\\(*\\d{3}\\)*( |-)*\\d{3}( |-)*\\d{4}$",
+
     "(?:a*)*", "a{1,2}?"
+
 };
+
 const size_t NUM_PATTERNS = sizeof(regex_patterns) / sizeof(regex_patterns[0]);
+
 PyObject** compiled_patterns = NULL;
+
 /* Called by LLVMFuzzerTestOneInput for initialization */
+
 static int init_sre_match(void) {
+
     PyObject* re_module = PyImport_ImportModule("re");
+
     if (re_module == NULL) {
+
         return 0;
+
     }
+
     compiled_patterns = (PyObject**) PyMem_RawMalloc(
+
         sizeof(PyObject*) * NUM_PATTERNS);
+
     if (compiled_patterns == NULL) {
+
         PyErr_NoMemory();
+
         return 0;
+
     }
 
+
+
     /* Precompile all the regex patterns on the first run for faster fuzzing */
+
     for (size_t i = 0; i < NUM_PATTERNS; i++) {
+
         PyObject* compiled = PyObject_CallMethod(
+
             re_module, "compile", "y", regex_patterns[i]);
+
         /* Bail if any of the patterns fail to compile */
+
         if (compiled == NULL) {
+
             return 0;
+
         }
+
         compiled_patterns[i] = compiled;
+
     }
+
     return 1;
+
 }
+
 /* Fuzz re.match(x) */
+
 static int fuzz_sre_match(const char* data, size_t size) {
+
     if (size < 1 || size > MAX_RE_TEST_SIZE) {
+
         return 0;
+
     }
+
     /* Use the first byte as a uint8_t specifying the index of the
+
        regex to use */
+
     unsigned char idx = (unsigned char) data[0];
+
     idx = idx % NUM_PATTERNS;
 
+
+
     /* Pull the string to match from the remaining bytes */
+
     PyObject* to_match = PyBytes_FromStringAndSize(data + 1, size - 1);
+
     if (to_match == NULL) {
+
         return 0;
+
     }
 
+
+
     PyObject* pattern = compiled_patterns[idx];
+
     PyObject* match_callable = PyObject_GetAttrString(pattern, "match");
 
+
+
     PyObject* matches = PyObject_CallOneArg(match_callable, to_match);
 
+
+
     Py_XDECREF(matches);
+
     Py_DECREF(match_callable);
+
     Py_DECREF(to_match);
+
     return 0;
+
 }
 
+
+
 #define MAX_CSV_TEST_SIZE 0x100000
+
 PyObject* csv_module = NULL;
+
 PyObject* csv_error = NULL;
+
 /* Called by LLVMFuzzerTestOneInput for initialization */
+
 static int init_csv_reader(void) {
+
     /* Import csv and csv.Error */
+
     csv_module = PyImport_ImportModule("csv");
+
     if (csv_module == NULL) {
+
         return 0;
+
     }
+
     csv_error = PyObject_GetAttrString(csv_module, "Error");
+
     return csv_error != NULL;
+
 }
+
 /* Fuzz csv.reader([x]) */
+
 static int fuzz_csv_reader(const char* data, size_t size) {
+
     if (size < 1 || size > MAX_CSV_TEST_SIZE) {
+
         return 0;
+
     }
+
     /* Ignore non null-terminated strings since _csv can't handle
+
        embedded nulls */
+
     if (memchr(data, '\0', size) == NULL) {
+
         return 0;
+
     }
 
+
+
     PyObject* s = PyUnicode_FromString(data);
+
     /* Ignore exceptions until we have a valid string */
+
     if (s == NULL) {
+
         PyErr_Clear();
+
         return 0;
+
     }
 
+
+
     /* Split on \n so we can test multiple lines */
+
     PyObject* lines = PyObject_CallMethod(s, "split", "s", "\n");
+
     if (lines == NULL) {
+
         Py_DECREF(s);
+
         return 0;
+
     }
 
+
+
     PyObject* reader = PyObject_CallMethod(csv_module, "reader", "N", lines);
+
     if (reader) {
+
         /* Consume all of the reader as an iterator */
+
         PyObject* parsed_line;
+
         while ((parsed_line = PyIter_Next(reader))) {
+
             Py_DECREF(parsed_line);
+
         }
+
     }
 
+
+
     /* Ignore csv.Error because we're probably going to generate
+
        some bad files (embedded new-lines, unterminated quotes etc) */
+
     if (PyErr_ExceptionMatches(csv_error)) {
+
         PyErr_Clear();
+
     }
 
+
+
     Py_XDECREF(reader);
+
     Py_DECREF(s);
+
     return 0;
+
 }
 
+
+
 #define MAX_AST_LITERAL_EVAL_TEST_SIZE 0x100000
+
 PyObject* ast_literal_eval_method = NULL;
+
 /* Called by LLVMFuzzerTestOneInput for initialization */
+
 static int init_ast_literal_eval(void) {
+
     PyObject* ast_module = PyImport_ImportModule("ast");
+
     if (ast_module == NULL) {
+
         return 0;
+
     }
+
     ast_literal_eval_method = PyObject_GetAttrString(ast_module, "literal_eval");
+
     return ast_literal_eval_method != NULL;
+
 }
+
 /* Fuzz ast.literal_eval(x) */
+
 static int fuzz_ast_literal_eval(const char* data, size_t size) {
+
     if (size > MAX_AST_LITERAL_EVAL_TEST_SIZE) {
+
         return 0;
+
     }
+
     /* Ignore non null-terminated strings since ast can't handle
+
        embedded nulls */
+
     if (memchr(data, '\0', size) == NULL) {
+
         return 0;
+
     }
 
+
+
     PyObject* s = PyUnicode_FromString(data);
+
     /* Ignore exceptions until we have a valid string */
+
     if (s == NULL) {
+
         PyErr_Clear();
+
         return 0;
+
     }
 
+
+
     PyObject* literal = PyObject_CallOneArg(ast_literal_eval_method, s);
+
     /* Ignore some common errors thrown by ast.literal_eval */
+
     if (literal == NULL && (PyErr_ExceptionMatches(PyExc_ValueError) ||
+
                             PyErr_ExceptionMatches(PyExc_TypeError) ||
+
                             PyErr_ExceptionMatches(PyExc_SyntaxError) ||
+
                             PyErr_ExceptionMatches(PyExc_MemoryError) ||
+
                             PyErr_ExceptionMatches(PyExc_RecursionError))
+
     ) {
+
         PyErr_Clear();
+
     }
 
+
+
     Py_XDECREF(literal);
+
     Py_DECREF(s);
+
     return 0;
+
 }
 
+
+
 #define MAX_ELEMENTTREE_PARSEWHOLE_TEST_SIZE 0x100000
+
 PyObject* xmlparser_type = NULL;
+
 PyObject* bytesio_type = NULL;
+
 /* Called by LLVMFuzzerTestOneInput for initialization */
+
 static int init_elementtree_parsewhole(void) {
+
     PyObject* elementtree_module = PyImport_ImportModule("_elementtree");
+
     if (elementtree_module == NULL) {
+
         return 0;
+
     }
+
     xmlparser_type = PyObject_GetAttrString(elementtree_module, "XMLParser");
+
     Py_DECREF(elementtree_module);
+
     if (xmlparser_type == NULL) {
+
         return 0;
+
     }
 
 
+
+
+
     PyObject* io_module = PyImport_ImportModule("io");
+
     if (io_module == NULL) {
+
         return 0;
+
     }
+
     bytesio_type = PyObject_GetAttrString(io_module, "BytesIO");
+
     Py_DECREF(io_module);
+
     if (bytesio_type == NULL) {
+
         return 0;
+
     }
 
+
+
     return 1;
+
 }
+
 /* Fuzz _elementtree.XMLParser._parse_whole(x) */
+
 static int fuzz_elementtree_parsewhole(const char* data, size_t size) {
+
     if (size > MAX_ELEMENTTREE_PARSEWHOLE_TEST_SIZE) {
+
         return 0;
+
     }
 
+
+
     PyObject *input = PyObject_CallFunction(bytesio_type, "y#", data, (Py_ssize_t)size);
+
     if (input == NULL) {
+
         assert(PyErr_Occurred());
+
         PyErr_Print();
+
         abort();
+
     }
 
+
+
     PyObject *xmlparser_instance = PyObject_CallObject(xmlparser_type, NULL);
+
     if (xmlparser_instance == NULL) {
+
         assert(PyErr_Occurred());
+
         PyErr_Print();
+
         abort();
+
     }
 
+
+
     PyObject *result = PyObject_CallMethod(xmlparser_instance, "_parse_whole", "O", input);
+
     if (result == NULL) {
+
         /* Ignore exception here, which can be caused by invalid XML input */
+
         PyErr_Clear();
+
     } else {
+
         Py_DECREF(result);
+
     }
 
+
+
     Py_DECREF(xmlparser_instance);
+
     Py_DECREF(input);
 
+
+
     return 0;
+
 }
 
+
+
 #define MAX_PYCOMPILE_TEST_SIZE 16384
 
+
+
 static const int start_vals[] = {Py_eval_input, Py_single_input, Py_file_input};
+
 const size_t NUM_START_VALS = sizeof(start_vals) / sizeof(start_vals[0]);
 
+
+
 static const int optimize_vals[] = {-1, 0, 1, 2};
+
 const size_t NUM_OPTIMIZE_VALS = sizeof(optimize_vals) / sizeof(optimize_vals[0]);
 
+
+
 /* Fuzz `PyCompileStringExFlags` using a variety of input parameters.
+
  * That function is essentially behind the `compile` builtin */
+
 static int fuzz_pycompile(const char* data, size_t size) {
+
     // Ignore overly-large inputs, and account for a NUL terminator
+
     if (size > MAX_PYCOMPILE_TEST_SIZE - 1) {
+
         return 0;
+
     }
 
+
+
     // Need 2 bytes for parameter selection
+
     if (size < 2) {
+
         return 0;
+
     }
 
+
+
     // Use first byte to determine element of `start_vals` to use
+
     unsigned char start_idx = (unsigned char) data[0];
+
     int start = start_vals[start_idx % NUM_START_VALS];
 
+
+
     // Use second byte to determine element of `optimize_vals` to use
+
     unsigned char optimize_idx = (unsigned char) data[1];
+
     int optimize = optimize_vals[optimize_idx % NUM_OPTIMIZE_VALS];
 
+
+
     char pycompile_scratch[MAX_PYCOMPILE_TEST_SIZE];
 
+
+
     // Create a NUL-terminated C string from the remaining input
+
     memcpy(pycompile_scratch, data + 2, size - 2);
+
     // Put a NUL terminator just after the copied data. (Space was reserved already.)
+
     pycompile_scratch[size - 2] = '\0';
 
+
+
     // XXX: instead of always using NULL for the `flags` value to
+
     // `Py_CompileStringExFlags`, there are many flags that conditionally
+
     // change parser behavior:
+
     //
+
     //     #define PyCF_TYPE_COMMENTS 0x1000
+
     //     #define PyCF_ALLOW_TOP_LEVEL_AWAIT 0x2000
+
     //     #define PyCF_ONLY_AST 0x0400
+
     //
+
     // It would be good to test various combinations of these, too.
+
     PyCompilerFlags *flags = NULL;
 
+
+
     PyObject *result = Py_CompileStringExFlags(pycompile_scratch, "<fuzz input>", start, flags, optimize);
+
     if (result == NULL) {
+
         /* Compilation failed, most likely from a syntax error. If it was a
+
            SystemError we abort. There's no non-bug reason to raise a
+
            SystemError. */
+
         if (PyErr_Occurred() && PyErr_ExceptionMatches(PyExc_SystemError)) {
+
             PyErr_Print();
+
             abort();
+
         }
+
         PyErr_Clear();
+
     } else {
+
         Py_DECREF(result);
+
     }
 
+
+
     return 0;
+
 }
 
+
+
 /* Run fuzzer and abort on failure. */
+
 static int _run_fuzz(const uint8_t *data, size_t size, int(*fuzzer)(const char* , size_t)) {
+
     int rv = fuzzer((const char*) data, size);
+
     if (PyErr_Occurred()) {
+
         /* Fuzz tests should handle expected errors for themselves.
+
            This is last-ditch check in case they didn't. */
+
         PyErr_Print();
+
         abort();
+
     }
+
     /* Someday the return value might mean something, propagate it. */
+
     return rv;
+
 }
 
+
+
 /* CPython generates a lot of leak warnings for whatever reason. */
+
 int __lsan_is_turned_off(void) { return 1; }
 
 
+
+
+
 int LLVMFuzzerInitialize(int *argc, char ***argv) {
+
     PyConfig config;
+
     PyConfig_InitPythonConfig(&config);
+
     config.install_signal_handlers = 0;
+
     /* Raise the limit above the default allows exercising larger things
+
      * now that we fall back to the _pylong module for large values. */
+
     config.int_max_str_digits = 8086;
+
     PyStatus status;
+
     status = PyConfig_SetBytesString(&config, &config.program_name, *argv[0]);
+
     if (PyStatus_Exception(status)) {
+
         goto fail;
+
     }
 
+
+
     status = Py_InitializeFromConfig(&config);
+
     if (PyStatus_Exception(status)) {
+
         goto fail;
+
     }
+
     PyConfig_Clear(&config);
 
+
+
     return 0;
 
+
+
 fail:
+
     PyConfig_Clear(&config);
+
     Py_ExitStatusException(status);
+
 }
 
+
+
 /* Fuzz test interface.
+
    This returns the bitwise or of all fuzz test's return values.
 
+
+
    All fuzz tests must return 0, as all nonzero return codes are reserved for
+
    future use -- we propagate the return values for that future case.
+
    (And we bitwise or when running multiple tests to verify that normally we
+
    only return 0.) */
+
+
+#ifdef FRCOV
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#endif
 int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {
+
+    
+    #ifdef FRCOV
+    char *fixReverterEnv = getenv("FIXREVERTER");
+    char *fixReverterToken = strtok(fixReverterEnv, " ");
+    if (fixReverterToken == NULL) {
+      for (int i = 0; i < FIXREVERTER_SIZE; i++)
+        FIXREVERTER[i] = 1;
+    } else if (!strcmp("on", fixReverterToken)) {
+      for (int i = 0; i < FIXREVERTER_SIZE; i++)
+        FIXREVERTER[i] = 0;
+      fixReverterToken = strtok(NULL, " ");
+      while (fixReverterToken != NULL) {
+        FIXREVERTER[atoi(fixReverterToken)] = 1;
+        fixReverterToken = strtok(NULL, " ");
+      }
+    } else if (!strcmp("off", fixReverterToken)) {
+      for (int i = 0; i < FIXREVERTER_SIZE; i++)
+        FIXREVERTER[i] = 1;
+      fixReverterToken = strtok(NULL, " ");
+      while (fixReverterToken != NULL) {
+        FIXREVERTER[atoi(fixReverterToken)] = 0;
+        fixReverterToken = strtok(NULL, " ");
+      }
+    } else {
+      fprintf(stderr, "[FIXREVERTER] - first token must be on or off\n");
+      exit(0);
+    }
+    #endif
     assert(Py_IsInitialized());
 
+
+
     int rv = 0;
 
+
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_builtin_float)
+
     rv |= _run_fuzz(data, size, fuzz_builtin_float);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_builtin_int)
+
     rv |= _run_fuzz(data, size, fuzz_builtin_int);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_builtin_unicode)
+
     rv |= _run_fuzz(data, size, fuzz_builtin_unicode);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_struct_unpack)
+
     static int STRUCT_UNPACK_INITIALIZED = 0;
+
     if (!STRUCT_UNPACK_INITIALIZED && !init_struct_unpack()) {
+
         PyErr_Print();
+
         abort();
+
     } else {
+
         STRUCT_UNPACK_INITIALIZED = 1;
+
     }
+
     rv |= _run_fuzz(data, size, fuzz_struct_unpack);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_json_loads)
+
     static int JSON_LOADS_INITIALIZED = 0;
+
     if (!JSON_LOADS_INITIALIZED && !init_json_loads()) {
+
         PyErr_Print();
+
         abort();
+
     } else {
+
         JSON_LOADS_INITIALIZED = 1;
+
     }
 
+
+
     rv |= _run_fuzz(data, size, fuzz_json_loads);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_sre_compile)
+
     static int SRE_COMPILE_INITIALIZED = 0;
+
     if (!SRE_COMPILE_INITIALIZED && !init_sre_compile()) {
+
         PyErr_Print();
+
         abort();
+
     } else {
+
         SRE_COMPILE_INITIALIZED = 1;
+
     }
 
+
+
     if (SRE_COMPILE_INITIALIZED) {
+
         rv |= _run_fuzz(data, size, fuzz_sre_compile);
+
     }
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_sre_match)
+
     static int SRE_MATCH_INITIALIZED = 0;
+
     if (!SRE_MATCH_INITIALIZED && !init_sre_match()) {
+
         PyErr_Print();
+
         abort();
+
     } else {
+
         SRE_MATCH_INITIALIZED = 1;
+
     }
 
+
+
     rv |= _run_fuzz(data, size, fuzz_sre_match);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_csv_reader)
+
     static int CSV_READER_INITIALIZED = 0;
+
     if (!CSV_READER_INITIALIZED && !init_csv_reader()) {
+
         PyErr_Print();
+
         abort();
+
     } else {
+
         CSV_READER_INITIALIZED = 1;
+
     }
 
+
+
     rv |= _run_fuzz(data, size, fuzz_csv_reader);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_ast_literal_eval)
+
     static int AST_LITERAL_EVAL_INITIALIZED = 0;
+
     if (!AST_LITERAL_EVAL_INITIALIZED && !init_ast_literal_eval()) {
+
         PyErr_Print();
+
         abort();
+
     } else {
+
         AST_LITERAL_EVAL_INITIALIZED = 1;
+
     }
 
+
+
     rv |= _run_fuzz(data, size, fuzz_ast_literal_eval);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_elementtree_parsewhole)
+
     static int ELEMENTTREE_PARSEWHOLE_INITIALIZED = 0;
+
     if (!ELEMENTTREE_PARSEWHOLE_INITIALIZED && !init_elementtree_parsewhole()) {
+
         PyErr_Print();
+
         abort();
+
     } else {
+
         ELEMENTTREE_PARSEWHOLE_INITIALIZED = 1;
+
     }
 
+
+
     rv |= _run_fuzz(data, size, fuzz_elementtree_parsewhole);
+
 #endif
+
 #if !defined(_Py_FUZZ_ONE) || defined(_Py_FUZZ_fuzz_pycompile)
+
     rv |= _run_fuzz(data, size, fuzz_pycompile);
+
 #endif
+
   return rv;
+
 }
+
+//$main_begin$
+int main(int argc, char **argv) {
+    LLVMFuzzerInitialize(&argc, &argv);
+
+    FILE *fp = fopen(argv[1], "rb");
+    if (!fp) {
+        return 1;
+    }
+    fseek(fp, 0, SEEK_END);
+    size_t size = ftell(fp);
+    fseek(fp, 0, SEEK_SET);
+    unsigned char *data = (unsigned char *) malloc(size);
+    fread(data, 1, size, fp);
+    fclose(fp);
+    LLVMFuzzerTestOneInput(data, size);
+    return 0;
+}
\ No newline at end of file
diff --git a/Modules/atexitmodule.c b/Modules/atexitmodule.c
index 297a8d74ba3..2f24dff9d32 100644
--- a/Modules/atexitmodule.c
+++ b/Modules/atexitmodule.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  *  atexit - allow programmer to define multiple exit functions to be executed
  *  upon normal program termination.
@@ -69,8 +73,23 @@ atexit_cleanup(struct atexit_state *state)
     atexit_py_callback *cb;
     for (int i = 0; i < state->ncallbacks; i++) {
         cb = state->callbacks[i];
-        if (cb == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1552]) {
+          if ((cb == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 1552\n");
+          else
+            fprintf(stderr, "reached bug index 1552\n");
+        }
+        if ((!FIXREVERTER[1552] && (cb == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             continue;
+            #ifdef FRCOV
+            }
+            #endif
 
         atexit_delete_cb(state, i);
     }
@@ -122,15 +141,45 @@ atexit_callfuncs(struct atexit_state *state)
 {
     assert(!PyErr_Occurred());
 
-    if (state->ncallbacks == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1554]) {
+      if ((state -> ncallbacks == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1554\n");
+      else
+        fprintf(stderr, "reached bug index 1554\n");
+    }
+    if ((!FIXREVERTER[1554] && (state -> ncallbacks == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (int i = state->ncallbacks - 1; i >= 0; i--) {
         atexit_py_callback *cb = state->callbacks[i];
-        if (cb == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1555]) {
+          if ((cb == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 1555\n");
+          else
+            fprintf(stderr, "reached bug index 1555\n");
+        }
+        if ((!FIXREVERTER[1555] && (cb == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         // bpo-46025: Increment the refcount of cb->func as the call itself may unregister it
         PyObject* the_func = Py_NewRef(cb->func);
diff --git a/Modules/posixmodule.c b/Modules/posixmodule.c
index fc218383d5f..e2c51a2c8f7 100644
--- a/Modules/posixmodule.c
+++ b/Modules/posixmodule.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* POSIX module implementation */
 
 /* This file is also used for Windows NT/MS-Win.  In that case the
@@ -16476,9 +16480,24 @@ PyOS_FSPath(PyObject *path)
 
     path_repr = _PyObject_CallNoArgs(func);
     Py_DECREF(func);
-    if (NULL == path_repr) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2909]) {
+      if (((void *) 0 == path_repr ) && !(0))
+        fprintf(stderr, "triggered bug index 2909\n");
+      else
+        fprintf(stderr, "reached bug index 2909\n");
+    }
+    if ((!FIXREVERTER[2909] && ((void *) 0 == path_repr ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!(PyUnicode_Check(path_repr) || PyBytes_Check(path_repr))) {
         PyErr_Format(PyExc_TypeError,
diff --git a/Modules/signalmodule.c b/Modules/signalmodule.c
index 7de5ebe0899..28b144d8f1f 100644
--- a/Modules/signalmodule.c
+++ b/Modules/signalmodule.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Signal module -- many thanks to Lance Ellinghaus */
 
@@ -152,9 +156,24 @@ static inline int
 compare_handler(PyObject *func, PyObject *dfl_ign_handler)
 {
     // See https://github.com/python/cpython/pull/102399
-    if (func == NULL || dfl_ign_handler == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1495]) {
+      if ((func == (void *) 0 || dfl_ign_handler == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1495\n");
+      else
+        fprintf(stderr, "reached bug index 1495\n");
+    }
+    if ((!FIXREVERTER[1495] && (func == (void *) 0 || dfl_ign_handler == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(PyLong_CheckExact(dfl_ign_handler));
     if (!PyLong_CheckExact(func)) {
         return 0;
diff --git a/Objects/bytesobject.c b/Objects/bytesobject.c
index 459df6ceacf..e198a98780a 100644
--- a/Objects/bytesobject.c
+++ b/Objects/bytesobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* bytes object implementation */
 
 #include "Python.h"
@@ -79,9 +83,24 @@ _PyBytes_FromSize(Py_ssize_t size, int use_calloc)
     PyBytesObject *op;
     assert(size >= 0);
 
-    if (size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2679]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2679\n");
+      else
+        fprintf(stderr, "reached bug index 2679\n");
+    }
+    if ((!FIXREVERTER[2679] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return bytes_get_empty();
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if ((size_t)size > (size_t)PY_SSIZE_T_MAX - PyBytesObject_SIZE) {
         PyErr_SetString(PyExc_OverflowError,
@@ -94,9 +113,24 @@ _PyBytes_FromSize(Py_ssize_t size, int use_calloc)
         op = (PyBytesObject *)PyObject_Calloc(1, PyBytesObject_SIZE + size);
     else
         op = (PyBytesObject *)PyObject_Malloc(PyBytesObject_SIZE + size);
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2680]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2680\n");
+      else
+        fprintf(stderr, "reached bug index 2680\n");
+    }
+    if ((!FIXREVERTER[2680] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyObject_InitVar((PyVarObject*)op, &PyBytes_Type, size);
 _Py_COMP_DIAG_PUSH
 _Py_COMP_DIAG_IGNORE_DEPR_DECLS
@@ -112,25 +146,85 @@ PyObject *
 PyBytes_FromStringAndSize(const char *str, Py_ssize_t size)
 {
     PyBytesObject *op;
-    if (size < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2681]) {
+      if ((size < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2681\n");
+      else
+        fprintf(stderr, "reached bug index 2681\n");
+    }
+    if ((!FIXREVERTER[2681] && (size < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_SystemError,
             "Negative size passed to PyBytes_FromStringAndSize");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (size == 1 && str != NULL) {
         op = CHARACTER(*str & 255);
         assert(_Py_IsImmortal(op));
         return (PyObject *)op;
     }
-    if (size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2682]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2682\n");
+      else
+        fprintf(stderr, "reached bug index 2682\n");
+    }
+    if ((!FIXREVERTER[2682] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return bytes_get_empty();
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     op = (PyBytesObject *)_PyBytes_FromSize(size, 0);
-    if (op == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2683]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2683\n");
+      else
+        fprintf(stderr, "reached bug index 2683\n");
+    }
+    if ((!FIXREVERTER[2683] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
-    if (str == NULL)
+        #ifdef FRCOV
+        }
+        #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2684]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2684\n");
+      else
+        fprintf(stderr, "reached bug index 2684\n");
+    }
+    if ((!FIXREVERTER[2684] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return (PyObject *) op;
+        #ifdef FRCOV
+        }
+        #endif
 
     memcpy(op->ob_sval, str, size);
     return (PyObject *) op;
@@ -161,9 +255,24 @@ PyBytes_FromString(const char *str)
 
     /* Inline PyObject_NewVar */
     op = (PyBytesObject *)PyObject_Malloc(PyBytesObject_SIZE + size);
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2685]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2685\n");
+      else
+        fprintf(stderr, "reached bug index 2685\n");
+    }
+    if ((!FIXREVERTER[2685] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyObject_InitVar((PyVarObject*)op, &PyBytes_Type, size);
 _Py_COMP_DIAG_PUSH
 _Py_COMP_DIAG_IGNORE_DEPR_DECLS
@@ -1068,8 +1177,23 @@ PyObject *_PyBytes_DecodeEscape(const char *s,
     _PyBytesWriter_Init(&writer);
 
     p = _PyBytesWriter_Alloc(&writer, len);
-    if (p == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2715]) {
+      if ((p == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2715\n");
+      else
+        fprintf(stderr, "reached bug index 2715\n");
+    }
+    if ((!FIXREVERTER[2715] && (p == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     writer.overallocate = 1;
 
     *first_invalid_escape = NULL;
@@ -1234,10 +1358,25 @@ PyBytes_AsStringAndSize(PyObject *obj,
                          char **s,
                          Py_ssize_t *len)
 {
-    if (s == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2717]) {
+      if ((s == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2717\n");
+      else
+        fprintf(stderr, "reached bug index 2717\n");
+    }
+    if ((!FIXREVERTER[2717] && (s == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!PyBytes_Check(obj)) {
         PyErr_Format(PyExc_TypeError,
@@ -1436,10 +1575,25 @@ bytes_concat(PyObject *a, PyObject *b)
         goto done;
     }
 
-    if (va.len > PY_SSIZE_T_MAX - vb.len) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2723]) {
+      if ((va . len > 9223372036854775807 - vb . len ) && !(0))
+        fprintf(stderr, "triggered bug index 2723\n");
+      else
+        fprintf(stderr, "reached bug index 2723\n");
+    }
+    if ((!FIXREVERTER[2723] && (va . len > 9223372036854775807 - vb . len ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         goto done;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     result = PyBytes_FromStringAndSize(NULL, va.len + vb.len);
     if (result != NULL) {
@@ -3075,10 +3229,25 @@ PyBytes_Concat(PyObject **pv, PyObject *w)
     assert(pv != NULL);
     if (*pv == NULL)
         return;
-    if (w == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2749]) {
+      if ((w == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2749\n");
+      else
+        fprintf(stderr, "reached bug index 2749\n");
+    }
+    if ((!FIXREVERTER[2749] && (w == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_CLEAR(*pv);
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (Py_REFCNT(*pv) == 1 && PyBytes_CheckExact(*pv)) {
         /* Only one reference, so we can resize in place */
@@ -3093,10 +3262,25 @@ PyBytes_Concat(PyObject **pv, PyObject *w)
         }
 
         oldsize = PyBytes_GET_SIZE(*pv);
-        if (oldsize > PY_SSIZE_T_MAX - wb.len) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2750]) {
+          if ((oldsize > 9223372036854775807 - wb . len ) && !(0))
+            fprintf(stderr, "triggered bug index 2750\n");
+          else
+            fprintf(stderr, "reached bug index 2750\n");
+        }
+        if ((!FIXREVERTER[2750] && (oldsize > 9223372036854775807 - wb . len ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             goto error;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (_PyBytes_Resize(pv, oldsize + wb.len) < 0)
             goto error;
 
@@ -3151,20 +3335,50 @@ _PyBytes_Resize(PyObject **pv, Py_ssize_t newsize)
         return -1;
     }
     Py_ssize_t oldsize = PyBytes_GET_SIZE(v);
-    if (oldsize == newsize) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2751]) {
+      if ((oldsize == newsize ) && !(0))
+        fprintf(stderr, "triggered bug index 2751\n");
+      else
+        fprintf(stderr, "reached bug index 2751\n");
+    }
+    if ((!FIXREVERTER[2751] && (oldsize == newsize ))
+    #else
+    if (0
+    #endif
+    ) {
         /* return early if newsize equals to v->ob_size */
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (oldsize == 0) {
         *pv = _PyBytes_FromSize(newsize, 0);
         Py_DECREF(v);
         return (*pv == NULL) ? -1 : 0;
     }
-    if (newsize == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2753]) {
+      if ((newsize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2753\n");
+      else
+        fprintf(stderr, "reached bug index 2753\n");
+    }
+    if ((!FIXREVERTER[2753] && (newsize == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *pv = bytes_get_empty();
         Py_DECREF(v);
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (Py_REFCNT(v) != 1) {
         if (oldsize < newsize) {
             *pv = _PyBytes_FromSize(newsize, 0);
@@ -3488,8 +3702,23 @@ _PyBytesWriter_Resize(_PyBytesWriter *writer, void *str, Py_ssize_t size)
             writer->buffer = PyByteArray_FromStringAndSize(NULL, allocated);
         else
             writer->buffer = PyBytes_FromStringAndSize(NULL, allocated);
-        if (writer->buffer == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2756]) {
+          if ((writer -> buffer == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2756\n");
+          else
+            fprintf(stderr, "reached bug index 2756\n");
+        }
+        if ((!FIXREVERTER[2756] && (writer -> buffer == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto error;
+            #ifdef FRCOV
+            }
+            #endif
 
         if (pos != 0) {
             char *dest;
@@ -3527,20 +3756,65 @@ _PyBytesWriter_Prepare(_PyBytesWriter *writer, void *str, Py_ssize_t size)
     assert(_PyBytesWriter_CheckConsistency(writer, str));
     assert(size >= 0);
 
-    if (size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2757]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2757\n");
+      else
+        fprintf(stderr, "reached bug index 2757\n");
+    }
+    if ((!FIXREVERTER[2757] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* nothing to do */
         return str;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
-    if (writer->min_size > PY_SSIZE_T_MAX - size) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2758]) {
+      if ((writer -> min_size > 9223372036854775807 - size ) && !(0))
+        fprintf(stderr, "triggered bug index 2758\n");
+      else
+        fprintf(stderr, "reached bug index 2758\n");
+    }
+    if ((!FIXREVERTER[2758] && (writer -> min_size > 9223372036854775807 - size ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         _PyBytesWriter_Dealloc(writer);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     new_min_size = writer->min_size + size;
 
-    if (new_min_size > writer->allocated)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2759]) {
+      if ((new_min_size > writer -> allocated ) && !(0))
+        fprintf(stderr, "triggered bug index 2759\n");
+      else
+        fprintf(stderr, "reached bug index 2759\n");
+    }
+    if ((!FIXREVERTER[2759] && (new_min_size > writer -> allocated ))
+    #else
+    if (0
+    #endif
+    )
         str = _PyBytesWriter_Resize(writer, str, new_min_size);
+        #ifdef FRCOV
+        }
+        #endif
 
     writer->min_size = new_min_size;
     return str;
@@ -3630,8 +3904,23 @@ _PyBytesWriter_WriteBytes(_PyBytesWriter *writer, void *ptr,
     char *str = (char *)ptr;
 
     str = _PyBytesWriter_Prepare(writer, str, size);
-    if (str == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2760]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2760\n");
+      else
+        fprintf(stderr, "reached bug index 2760\n");
+    }
+    if ((!FIXREVERTER[2760] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     memcpy(str, bytes, size);
     str += size;
diff --git a/Objects/call.c b/Objects/call.c
index b1610dababd..808102d5ea1 100644
--- a/Objects/call.c
+++ b/Objects/call.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_call.h"          // _PyObject_CallNoArgsTstate()
 #include "pycore_ceval.h"         // _Py_EnterRecursiveCallTstate()
@@ -169,10 +173,25 @@ object_is_not_callable(PyThreadState *tstate, PyObject *callable)
         //   File "<stdin>", line 1, in <module>
         // TypeError: 'module' object is not callable. Did you mean: 'pprint.pprint(...)'?
         PyObject *name = PyModule_GetNameObject(callable);
-        if (name == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3677]) {
+          if ((name == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3677\n");
+          else
+            fprintf(stderr, "reached bug index 3677\n");
+        }
+        if ((!FIXREVERTER[3677] && (name == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             _PyErr_Clear(tstate);
             goto basic_type_error;
         }
+        #ifdef FRCOV
+        }
+        #endif
         PyObject *attr;
         int res = PyObject_GetOptionalAttr(callable, name, &attr);
         if (res < 0) {
@@ -208,15 +227,45 @@ _PyObject_MakeTpCall(PyThreadState *tstate, PyObject *callable,
     /* Slow path: build a temporary tuple for positional arguments and a
      * temporary dictionary for keyword arguments (if any) */
     ternaryfunc call = Py_TYPE(callable)->tp_call;
-    if (call == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3678]) {
+      if ((call == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3678\n");
+      else
+        fprintf(stderr, "reached bug index 3678\n");
+    }
+    if ((!FIXREVERTER[3678] && (call == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         object_is_not_callable(tstate, callable);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *argstuple = _PyTuple_FromArray(args, nargs);
-    if (argstuple == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3679]) {
+      if ((argstuple == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3679\n");
+      else
+        fprintf(stderr, "reached bug index 3679\n");
+    }
+    if ((!FIXREVERTER[3679] && (argstuple == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *kwdict;
     if (keywords == NULL || PyDict_Check(keywords)) {
@@ -226,10 +275,25 @@ _PyObject_MakeTpCall(PyThreadState *tstate, PyObject *callable,
         if (PyTuple_GET_SIZE(keywords)) {
             assert(args != NULL);
             kwdict = _PyStack_AsDict(args + nargs, keywords);
-            if (kwdict == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3680]) {
+              if ((kwdict == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3680\n");
+              else
+                fprintf(stderr, "reached bug index 3680\n");
+            }
+            if ((!FIXREVERTER[3680] && (kwdict == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Py_DECREF(argstuple);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         else {
             keywords = kwdict = NULL;
@@ -279,9 +343,24 @@ _PyVectorcall_Call(PyThreadState *tstate, vectorcallfunc func,
     args = _PyStack_UnpackDict(tstate,
                                _PyTuple_ITEMS(tuple), nargs,
                                kwargs, &kwnames);
-    if (args == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3681]) {
+      if ((args == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3681\n");
+      else
+        fprintf(stderr, "reached bug index 3681\n");
+    }
+    if ((!FIXREVERTER[3681] && (args == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *result = func(callable, args,
                             nargs | PY_VECTORCALL_ARGUMENTS_OFFSET, kwnames);
     _PyStack_UnpackDict_Free(args, nargs, kwnames);
@@ -349,10 +428,25 @@ _PyObject_Call(PyThreadState *tstate, PyObject *callable,
     }
     else {
         call = Py_TYPE(callable)->tp_call;
-        if (call == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3684]) {
+          if ((call == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3684\n");
+          else
+            fprintf(stderr, "reached bug index 3684\n");
+        }
+        if ((!FIXREVERTER[3684] && (call == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             object_is_not_callable(tstate, callable);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (_Py_EnterRecursiveCallTstate(tstate, " while calling a Python object")) {
             return NULL;
@@ -523,9 +617,24 @@ _PyObject_CallFunctionVa(PyThreadState *tstate, PyObject *callable,
     Py_ssize_t nargs, i;
     PyObject *result;
 
-    if (callable == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3687]) {
+      if ((callable == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3687\n");
+      else
+        fprintf(stderr, "reached bug index 3687\n");
+    }
+    if ((!FIXREVERTER[3687] && (callable == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return null_error(tstate);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!format || !*format) {
         return _PyObject_CallNoArgsTstate(tstate, callable);
@@ -533,9 +642,24 @@ _PyObject_CallFunctionVa(PyThreadState *tstate, PyObject *callable,
 
     stack = _Py_VaBuildStack(small_stack, small_stack_len,
                              format, va, &nargs);
-    if (stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3688]) {
+      if ((stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3688\n");
+      else
+        fprintf(stderr, "reached bug index 3688\n");
+    }
+    if ((!FIXREVERTER[3688] && (stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     EVAL_CALL_STAT_INC_IF_FUNCTION(EVAL_CALL_API, callable);
     if (nargs == 1 && PyTuple_Check(stack[0])) {
         /* Special cases for backward compatibility:
@@ -631,14 +755,44 @@ PyObject_CallMethod(PyObject *obj, const char *name, const char *format, ...)
 {
     PyThreadState *tstate = _PyThreadState_GET();
 
-    if (obj == NULL || name == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3689]) {
+      if ((obj == (void *) 0 || name == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3689\n");
+      else
+        fprintf(stderr, "reached bug index 3689\n");
+    }
+    if ((!FIXREVERTER[3689] && (obj == (void *) 0 || name == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return null_error(tstate);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *callable = PyObject_GetAttrString(obj, name);
-    if (callable == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3690]) {
+      if ((callable == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3690\n");
+      else
+        fprintf(stderr, "reached bug index 3690\n");
+    }
+    if ((!FIXREVERTER[3690] && (callable == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     va_list va;
     va_start(va, format);
@@ -680,14 +834,44 @@ _PyObject_CallMethod(PyObject *obj, PyObject *name,
                      const char *format, ...)
 {
     PyThreadState *tstate = _PyThreadState_GET();
-    if (obj == NULL || name == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3691]) {
+      if ((obj == (void *) 0 || name == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3691\n");
+      else
+        fprintf(stderr, "reached bug index 3691\n");
+    }
+    if ((!FIXREVERTER[3691] && (obj == (void *) 0 || name == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return null_error(tstate);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *callable = PyObject_GetAttr(obj, name);
-    if (callable == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3692]) {
+      if ((callable == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3692\n");
+      else
+        fprintf(stderr, "reached bug index 3692\n");
+    }
+    if ((!FIXREVERTER[3692] && (callable == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     va_list va;
     va_start(va, format);
@@ -773,18 +957,48 @@ object_vacall(PyThreadState *tstate, PyObject *base,
     Py_ssize_t i;
     va_list countva;
 
-    if (callable == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3695]) {
+      if ((callable == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3695\n");
+      else
+        fprintf(stderr, "reached bug index 3695\n");
+    }
+    if ((!FIXREVERTER[3695] && (callable == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return null_error(tstate);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Count the number of arguments */
     va_copy(countva, vargs);
     nargs = base ? 1 : 0;
     while (1) {
         PyObject *arg = va_arg(countva, PyObject *);
-        if (arg == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3696]) {
+          if ((arg == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3696\n");
+          else
+            fprintf(stderr, "reached bug index 3696\n");
+        }
+        if ((!FIXREVERTER[3696] && (arg == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             break;
         }
+        #ifdef FRCOV
+        }
+        #endif
         nargs++;
     }
     va_end(countva);
@@ -795,10 +1009,25 @@ object_vacall(PyThreadState *tstate, PyObject *base,
     }
     else {
         stack = PyMem_Malloc(nargs * sizeof(stack[0]));
-        if (stack == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3697]) {
+          if ((stack == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3697\n");
+          else
+            fprintf(stderr, "reached bug index 3697\n");
+        }
+        if ((!FIXREVERTER[3697] && (stack == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     i = 0;
@@ -837,9 +1066,24 @@ PyObject_VectorcallMethod(PyObject *name, PyObject *const *args,
     PyObject *callable = NULL;
     /* Use args[0] as "self" argument */
     int unbound = _PyObject_GetMethod(args[0], name, &callable);
-    if (callable == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3698]) {
+      if ((callable == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3698\n");
+      else
+        fprintf(stderr, "reached bug index 3698\n");
+    }
+    if ((!FIXREVERTER[3698] && (callable == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (unbound) {
         /* We must remove PY_VECTORCALL_ARGUMENTS_OFFSET since
@@ -864,15 +1108,45 @@ PyObject *
 PyObject_CallMethodObjArgs(PyObject *obj, PyObject *name, ...)
 {
     PyThreadState *tstate = _PyThreadState_GET();
-    if (obj == NULL || name == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3699]) {
+      if ((obj == (void *) 0 || name == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3699\n");
+      else
+        fprintf(stderr, "reached bug index 3699\n");
+    }
+    if ((!FIXREVERTER[3699] && (obj == (void *) 0 || name == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return null_error(tstate);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *callable = NULL;
     int is_method = _PyObject_GetMethod(obj, name, &callable);
-    if (callable == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3700]) {
+      if ((callable == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3700\n");
+      else
+        fprintf(stderr, "reached bug index 3700\n");
+    }
+    if ((!FIXREVERTER[3700] && (callable == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     obj = is_method ? obj : NULL;
 
     va_list vargs;
@@ -970,23 +1244,68 @@ _PyStack_UnpackDict(PyThreadState *tstate,
      * in this check cannot overflow: both maxnargs and nkwargs are
      * non-negative signed integers, so their difference fits in the type. */
     Py_ssize_t maxnargs = PY_SSIZE_T_MAX / sizeof(args[0]) - 1;
-    if (nargs > maxnargs - nkwargs) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3703]) {
+      if ((nargs > maxnargs - nkwargs ) && !(0))
+        fprintf(stderr, "triggered bug index 3703\n");
+      else
+        fprintf(stderr, "reached bug index 3703\n");
+    }
+    if ((!FIXREVERTER[3703] && (nargs > maxnargs - nkwargs ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyErr_NoMemory(tstate);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Add 1 to support PY_VECTORCALL_ARGUMENTS_OFFSET */
     PyObject **stack = PyMem_Malloc((1 + nargs + nkwargs) * sizeof(args[0]));
-    if (stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3704]) {
+      if ((stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3704\n");
+      else
+        fprintf(stderr, "reached bug index 3704\n");
+    }
+    if ((!FIXREVERTER[3704] && (stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyErr_NoMemory(tstate);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *kwnames = PyTuple_New(nkwargs);
-    if (kwnames == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3705]) {
+      if ((kwnames == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3705\n");
+      else
+        fprintf(stderr, "reached bug index 3705\n");
+    }
+    if ((!FIXREVERTER[3705] && (kwnames == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyMem_Free(stack);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     stack++;  /* For PY_VECTORCALL_ARGUMENTS_OFFSET */
 
diff --git a/Objects/capsule.c b/Objects/capsule.c
index 555979dab2b..3108aafabbc 100644
--- a/Objects/capsule.c
+++ b/Objects/capsule.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Wrap void * pointers to be passed between C modules */
 
 #include "Python.h"
@@ -27,9 +31,24 @@ _is_legal_capsule(PyObject *op, const char *invalid_capsule)
     }
     PyCapsule *capsule = (PyCapsule *)op;
 
-    if (capsule->pointer == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2940]) {
+      if ((capsule -> pointer == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2940\n");
+      else
+        fprintf(stderr, "reached bug index 2940\n");
+    }
+    if ((!FIXREVERTER[2940] && (capsule -> pointer == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return 1;
 
 error:
@@ -65,9 +84,24 @@ PyCapsule_New(void *pointer, const char *name, PyCapsule_Destructor destructor)
     }
 
     capsule = PyObject_GC_New(PyCapsule, &PyCapsule_Type);
-    if (capsule == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2941]) {
+      if ((capsule == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2941\n");
+      else
+        fprintf(stderr, "reached bug index 2941\n");
+    }
+    if ((!FIXREVERTER[2941] && (capsule == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     capsule->pointer = pointer;
     capsule->name = name;
diff --git a/Objects/codeobject.c b/Objects/codeobject.c
index 7493280c898..0649afcabab 100644
--- a/Objects/codeobject.c
+++ b/Objects/codeobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include <stdbool.h>
 
 #include "Python.h"
@@ -181,9 +185,24 @@ intern_constants(PyObject *tuple, int *modified)
         else if (PyFrozenSet_CheckExact(v)) {
             PyObject *w = v;
             PyObject *tmp = PySequence_Tuple(v);
-            if (tmp == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[6188]) {
+              if ((tmp == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 6188\n");
+              else
+                fprintf(stderr, "reached bug index 6188\n");
+            }
+            if ((!FIXREVERTER[6188] && (tmp == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return -1;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int tmp_modified = 0;
             if (intern_constants(tmp, &tmp_modified) < 0) {
                 Py_DECREF(tmp);
@@ -191,10 +210,25 @@ intern_constants(PyObject *tuple, int *modified)
             }
             if (tmp_modified) {
                 v = PyFrozenSet_New(tmp);
-                if (v == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[6189]) {
+                  if ((v == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 6189\n");
+                  else
+                    fprintf(stderr, "reached bug index 6189\n");
+                }
+                if ((!FIXREVERTER[6189] && (v == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     Py_DECREF(tmp);
                     return -1;
                 }
+                #ifdef FRCOV
+                }
+                #endif
 
                 PyTuple_SET_ITEM(tuple, i, v);
                 Py_DECREF(w);
@@ -307,10 +341,25 @@ static int
 init_co_cached(PyCodeObject *self) {
     if (self->_co_cached == NULL) {
         self->_co_cached = PyMem_New(_PyCoCached, 1);
-        if (self->_co_cached == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6192]) {
+          if ((self -> _co_cached == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6192\n");
+          else
+            fprintf(stderr, "reached bug index 6192\n");
+        }
+        if ((!FIXREVERTER[6192] && (self -> _co_cached == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         self->_co_cached->_co_code = NULL;
         self->_co_cached->_co_cellvars = NULL;
         self->_co_cached->_co_freevars = NULL;
@@ -371,9 +420,24 @@ static PyObject *
 get_localsplus_names(PyCodeObject *co, _PyLocals_Kind kind, int num)
 {
     PyObject *names = PyTuple_New(num);
-    if (names == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6193]) {
+      if ((names == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6193\n");
+      else
+        fprintf(stderr, "reached bug index 6193\n");
+    }
+    if ((!FIXREVERTER[6193] && (names == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int index = 0;
     for (int offset = 0; offset < co->co_nlocalsplus; offset++) {
         _PyLocals_Kind k = _PyLocals_GetKind(co->co_localspluskinds, offset);
@@ -576,10 +640,25 @@ remove_column_info(PyObject *locations)
     Py_ssize_t offset = 0;
     const uint8_t *data = (const uint8_t *)PyBytes_AS_STRING(locations);
     PyObject *res = PyBytes_FromStringAndSize(NULL, 32);
-    if (res == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6195]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6195\n");
+      else
+        fprintf(stderr, "reached bug index 6195\n");
+    }
+    if ((!FIXREVERTER[6195] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     uint8_t *output = (uint8_t *)PyBytes_AS_STRING(res);
     while (offset < PyBytes_GET_SIZE(locations)) {
         Py_ssize_t write_offset = output - (uint8_t *)PyBytes_AS_STRING(res);
@@ -656,9 +735,24 @@ _PyCode_New(struct _PyCodeConstructor *con)
     // ranges.
     if (!_Py_GetConfig()->code_debug_ranges) {
         replacement_locations = remove_column_info(con->linetable);
-        if (replacement_locations == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6196]) {
+          if ((replacement_locations == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6196\n");
+          else
+            fprintf(stderr, "reached bug index 6196\n");
+        }
+        if ((!FIXREVERTER[6196] && (replacement_locations == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         con->linetable = replacement_locations;
     }
 
@@ -669,11 +763,26 @@ _PyCode_New(struct _PyCodeConstructor *con)
 #else
     co = PyObject_NewVar(PyCodeObject, &PyCode_Type, size);
 #endif
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6197]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6197\n");
+      else
+        fprintf(stderr, "reached bug index 6197\n");
+    }
+    if ((!FIXREVERTER[6197] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_XDECREF(replacement_locations);
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     init_code(co, con);
 #ifdef Py_GIL_DISABLED
     _PyObject_SetDeferredRefcount((PyObject *)co);
@@ -1549,9 +1658,24 @@ get_cached_locals(PyCodeObject *co, PyObject **cached_field,
     }
     assert(*cached_field == NULL);
     PyObject *varnames = get_localsplus_names(co, kind, num);
-    if (varnames == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6218]) {
+      if ((varnames == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6218\n");
+      else
+        fprintf(stderr, "reached bug index 6218\n");
+    }
+    if ((!FIXREVERTER[6218] && (varnames == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     *cached_field = Py_NewRef(varnames);
     return varnames;
 }
@@ -2427,18 +2551,48 @@ _PyCode_ConstantKey(PyObject *op)
 
         len = PyTuple_GET_SIZE(op);
         tuple = PyTuple_New(len);
-        if (tuple == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6240]) {
+          if ((tuple == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6240\n");
+          else
+            fprintf(stderr, "reached bug index 6240\n");
+        }
+        if ((!FIXREVERTER[6240] && (tuple == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
 
         for (i=0; i < len; i++) {
             PyObject *item, *item_key;
 
             item = PyTuple_GET_ITEM(op, i);
             item_key = _PyCode_ConstantKey(item);
-            if (item_key == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[6241]) {
+              if ((item_key == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 6241\n");
+              else
+                fprintf(stderr, "reached bug index 6241\n");
+            }
+            if ((!FIXREVERTER[6241] && (item_key == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Py_DECREF(tuple);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             PyTuple_SET_ITEM(tuple, i, item_key);
         }
@@ -2455,18 +2609,48 @@ _PyCode_ConstantKey(PyObject *op)
 
         len = PySet_GET_SIZE(op);
         tuple = PyTuple_New(len);
-        if (tuple == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6242]) {
+          if ((tuple == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6242\n");
+          else
+            fprintf(stderr, "reached bug index 6242\n");
+        }
+        if ((!FIXREVERTER[6242] && (tuple == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
 
         i = 0;
         while (_PySet_NextEntry(op, &pos, &item, &hash)) {
             PyObject *item_key;
 
             item_key = _PyCode_ConstantKey(item);
-            if (item_key == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[6243]) {
+              if ((item_key == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 6243\n");
+              else
+                fprintf(stderr, "reached bug index 6243\n");
+            }
+            if ((!FIXREVERTER[6243] && (item_key == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Py_DECREF(tuple);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             assert(i < len);
             PyTuple_SET_ITEM(tuple, i, item_key);
@@ -2474,8 +2658,23 @@ _PyCode_ConstantKey(PyObject *op)
         }
         set = PyFrozenSet_New(tuple);
         Py_DECREF(tuple);
-        if (set == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6244]) {
+          if ((set == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6244\n");
+          else
+            fprintf(stderr, "reached bug index 6244\n");
+        }
+        if ((!FIXREVERTER[6244] && (set == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
 
         key = PyTuple_Pack(2, set, op);
         Py_DECREF(set);
@@ -2485,8 +2684,23 @@ _PyCode_ConstantKey(PyObject *op)
         /* for other types, use the object identifier as a unique identifier
          * to ensure that they are seen as unequal. */
         PyObject *obj_id = PyLong_FromVoidPtr(op);
-        if (obj_id == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6245]) {
+          if ((obj_id == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6245\n");
+          else
+            fprintf(stderr, "reached bug index 6245\n");
+        }
+        if ((!FIXREVERTER[6245] && (obj_id == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
 
         key = PyTuple_Pack(2, obj_id, op);
         Py_DECREF(obj_id);
diff --git a/Objects/complexobject.c b/Objects/complexobject.c
index 7b62fe30b2b..0653b7689ad 100644
--- a/Objects/complexobject.c
+++ b/Objects/complexobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Complex object implementation */
 
@@ -230,9 +234,24 @@ PyComplex_FromCComplex(Py_complex cval)
 {
     /* Inline PyObject_New */
     PyComplexObject *op = PyObject_Malloc(sizeof(PyComplexObject));
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[666]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 666\n");
+      else
+        fprintf(stderr, "reached bug index 666\n");
+    }
+    if ((!FIXREVERTER[666] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyObject_Init((PyObject*)op, &PyComplex_Type);
     op->cval = cval;
     return (PyObject *) op;
diff --git a/Objects/descrobject.c b/Objects/descrobject.c
index 4eccd1704eb..23a00b0d8b5 100644
--- a/Objects/descrobject.c
+++ b/Objects/descrobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Descriptors -- a new, flexible way to describe attributes */
 
 #include "Python.h"
@@ -975,8 +979,23 @@ PyDescr_NewClassMethod(PyTypeObject *type, PyMethodDef *method)
 
     descr = (PyMethodDescrObject *)descr_new(&PyClassMethodDescr_Type,
                                              type, method->ml_name);
-    if (descr != NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2219]) {
+      if ((descr != (void *) 0  ) && !(0))
+        fprintf(stderr, "triggered bug index 2219\n");
+      else
+        fprintf(stderr, "reached bug index 2219\n");
+    }
+    if ((!FIXREVERTER[2219] && (descr != (void *) 0  ))
+    #else
+    if (0
+    #endif
+    )
         descr->d_method = method;
+        #ifdef FRCOV
+        }
+        #endif
     return (PyObject *)descr;
 }
 
@@ -993,8 +1012,23 @@ PyDescr_NewMember(PyTypeObject *type, PyMemberDef *member)
     }
     descr = (PyMemberDescrObject *)descr_new(&PyMemberDescr_Type,
                                              type, member->name);
-    if (descr != NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2220]) {
+      if ((descr != (void *) 0  ) && !(0))
+        fprintf(stderr, "triggered bug index 2220\n");
+      else
+        fprintf(stderr, "reached bug index 2220\n");
+    }
+    if ((!FIXREVERTER[2220] && (descr != (void *) 0  ))
+    #else
+    if (0
+    #endif
+    )
         descr->d_member = member;
+        #ifdef FRCOV
+        }
+        #endif
     return (PyObject *)descr;
 }
 
@@ -1005,8 +1039,23 @@ PyDescr_NewGetSet(PyTypeObject *type, PyGetSetDef *getset)
 
     descr = (PyGetSetDescrObject *)descr_new(&PyGetSetDescr_Type,
                                              type, getset->name);
-    if (descr != NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2221]) {
+      if ((descr != (void *) 0  ) && !(0))
+        fprintf(stderr, "triggered bug index 2221\n");
+      else
+        fprintf(stderr, "reached bug index 2221\n");
+    }
+    if ((!FIXREVERTER[2221] && (descr != (void *) 0  ))
+    #else
+    if (0
+    #endif
+    )
         descr->d_getset = getset;
+        #ifdef FRCOV
+        }
+        #endif
     return (PyObject *)descr;
 }
 
diff --git a/Objects/dictobject.c b/Objects/dictobject.c
index 5d325465608..90590c38526 100644
--- a/Objects/dictobject.c
+++ b/Objects/dictobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Dictionary object implementation using a hash table */
 
 /* The distribution includes a separate file, Objects/dictnotes.txt,
@@ -809,10 +813,25 @@ new_keys_object(PyInterpreterState *interp, uint8_t log2_size, bool unicode)
         dk = PyMem_Malloc(sizeof(PyDictKeysObject)
                           + ((size_t)1 << log2_bytes)
                           + entry_size * usable);
-        if (dk == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[390]) {
+          if ((dk == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 390\n");
+          else
+            fprintf(stderr, "reached bug index 390\n");
+        }
+        if ((!FIXREVERTER[390] && (dk == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 #ifdef Py_REF_DEBUG
     _Py_IncRefTotal(_PyThreadState_GET());
@@ -872,9 +891,24 @@ new_values(size_t size)
 {
     size_t n = values_size_from_count(size);
     PyDictValues *res = (PyDictValues *)PyMem_Malloc(n);
-    if (res == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[391]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 391\n");
+      else
+        fprintf(stderr, "reached bug index 391\n");
+    }
+    if ((!FIXREVERTER[391] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     res->embedded = 0;
     res->size = 0;
     assert(size < 256);
@@ -916,13 +950,28 @@ new_dict(PyInterpreterState *interp,
 #endif
     {
         mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
-        if (mp == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[392]) {
+          if ((mp == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 392\n");
+          else
+            fprintf(stderr, "reached bug index 392\n");
+        }
+        if ((!FIXREVERTER[392] && (mp == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             dictkeys_decref(interp, keys, false);
             if (free_values_on_failure) {
                 free_values(values, false);
             }
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     mp->ma_keys = keys;
     mp->ma_values = values;
@@ -961,10 +1010,25 @@ clone_combined_dict_keys(PyDictObject *orig)
 
     size_t keys_size = _PyDict_KeysSize(orig->ma_keys);
     PyDictKeysObject *keys = PyMem_Malloc(keys_size);
-    if (keys == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[394]) {
+      if ((keys == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 394\n");
+      else
+        fprintf(stderr, "reached bug index 394\n");
+    }
+    if ((!FIXREVERTER[394] && (keys == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     memcpy(keys, orig->ma_keys, keys_size);
 
@@ -1849,11 +1913,26 @@ insert_to_emptydict(PyInterpreterState *interp, PyDictObject *mp,
     int unicode = PyUnicode_CheckExact(key);
     PyDictKeysObject *newkeys = new_keys_object(
             interp, PyDict_LOG_MINSIZE, unicode);
-    if (newkeys == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[398]) {
+      if ((newkeys == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 398\n");
+      else
+        fprintf(stderr, "reached bug index 398\n");
+    }
+    if ((!FIXREVERTER[398] && (newkeys == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(key);
         Py_DECREF(value);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     /* We don't decref Py_EMPTY_KEYS here because it is immortal. */
     assert(mp->ma_values == NULL);
 
@@ -1963,9 +2042,24 @@ dictresize(PyInterpreterState *interp, PyDictObject *mp,
 
     /* Allocate a new table. */
     newkeys = new_keys_object(interp, log2_newsize, unicode);
-    if (newkeys == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[399]) {
+      if ((newkeys == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 399\n");
+      else
+        fprintf(stderr, "reached bug index 399\n");
+    }
+    if ((!FIXREVERTER[399] && (newkeys == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     // New table must be large enough.
     assert(newkeys->dk_usable >= mp->ma_used);
 
@@ -2108,8 +2202,23 @@ dict_new_presized(PyInterpreterState *interp, Py_ssize_t minused, bool unicode)
     }
 
     new_keys = new_keys_object(interp, log2_newsize, unicode);
-    if (new_keys == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[400]) {
+      if ((new_keys == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 400\n");
+      else
+        fprintf(stderr, "reached bug index 400\n");
+    }
+    if ((!FIXREVERTER[400] && (new_keys == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     return new_dict(interp, new_keys, NULL, 0, 0);
 }
 
@@ -2138,9 +2247,24 @@ _PyDict_FromItems(PyObject *const *keys, Py_ssize_t keys_offset,
     }
 
     PyObject *dict = dict_new_presized(interp, length, unicode);
-    if (dict == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[401]) {
+      if ((dict == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 401\n");
+      else
+        fprintf(stderr, "reached bug index 401\n");
+    }
+    if ((!FIXREVERTER[401] && (dict == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     ks = keys;
     PyObject *const *vs = values;
@@ -2287,10 +2411,25 @@ _PyDict_GetItemRef_KnownHash(PyDictObject *op, PyObject *key, Py_hash_t hash, Py
         *result = NULL;
         return -1;
     }
-    if (value == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[402]) {
+      if ((value == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 402\n");
+      else
+        fprintf(stderr, "reached bug index 402\n");
+    }
+    if ((!FIXREVERTER[402] && (value == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *result = NULL;
         return 0;  // missing key
     }
+    #ifdef FRCOV
+    }
+    #endif
 #ifdef Py_GIL_DISABLED
     *result = value;
 #else
@@ -2812,8 +2951,23 @@ _PyDict_Next(PyObject *op, Py_ssize_t *ppos, PyObject **pkey,
     i = *ppos;
     if (_PyDict_HasSplitTable(mp)) {
         assert(mp->ma_used <= SHARED_KEYS_MAX_SIZE);
-        if (i < 0 || i >= mp->ma_used)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[406]) {
+          if ((i < 0 || i >= mp -> ma_used ) && !(0))
+            fprintf(stderr, "triggered bug index 406\n");
+          else
+            fprintf(stderr, "reached bug index 406\n");
+        }
+        if ((!FIXREVERTER[406] && (i < 0 || i >= mp -> ma_used ))
+        #else
+        if (0
+        #endif
+        )
             return 0;
+            #ifdef FRCOV
+            }
+            #endif
         int index = get_index_from_order(mp, i);
         value = mp->ma_values->values[index];
         key = LOAD_SHARED_KEY(DK_UNICODE_ENTRIES(mp->ma_keys)[index].me_key);
@@ -2822,16 +2976,46 @@ _PyDict_Next(PyObject *op, Py_ssize_t *ppos, PyObject **pkey,
     }
     else {
         Py_ssize_t n = mp->ma_keys->dk_nentries;
-        if (i < 0 || i >= n)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[407]) {
+          if ((i < 0 || i >= n ) && !(0))
+            fprintf(stderr, "triggered bug index 407\n");
+          else
+            fprintf(stderr, "reached bug index 407\n");
+        }
+        if ((!FIXREVERTER[407] && (i < 0 || i >= n ))
+        #else
+        if (0
+        #endif
+        )
             return 0;
+            #ifdef FRCOV
+            }
+            #endif
         if (DK_IS_UNICODE(mp->ma_keys)) {
             PyDictUnicodeEntry *entry_ptr = &DK_UNICODE_ENTRIES(mp->ma_keys)[i];
             while (i < n && entry_ptr->me_value == NULL) {
                 entry_ptr++;
                 i++;
             }
-            if (i >= n)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[408]) {
+              if ((i >= n ) && !(0))
+                fprintf(stderr, "triggered bug index 408\n");
+              else
+                fprintf(stderr, "reached bug index 408\n");
+            }
+            if ((!FIXREVERTER[408] && (i >= n ))
+            #else
+            if (0
+            #endif
+            )
                 return 0;
+                #ifdef FRCOV
+                }
+                #endif
             key = entry_ptr->me_key;
             hash = unicode_get_hash(entry_ptr->me_key);
             value = entry_ptr->me_value;
@@ -2842,8 +3026,23 @@ _PyDict_Next(PyObject *op, Py_ssize_t *ppos, PyObject **pkey,
                 entry_ptr++;
                 i++;
             }
-            if (i >= n)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[409]) {
+              if ((i >= n ) && !(0))
+                fprintf(stderr, "triggered bug index 409\n");
+              else
+                fprintf(stderr, "reached bug index 409\n");
+            }
+            if ((!FIXREVERTER[409] && (i >= n ))
+            #else
+            if (0
+            #endif
+            )
                 return 0;
+                #ifdef FRCOV
+                }
+                #endif
             key = entry_ptr->me_key;
             hash = entry_ptr->me_hash;
             value = entry_ptr->me_value;
@@ -2893,12 +3092,27 @@ _PyDict_Pop_KnownHash(PyDictObject *mp, PyObject *key, Py_hash_t hash,
 
     ASSERT_DICT_LOCKED(mp);
 
-    if (mp->ma_used == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[410]) {
+      if ((mp -> ma_used == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 410\n");
+      else
+        fprintf(stderr, "reached bug index 410\n");
+    }
+    if ((!FIXREVERTER[410] && (mp -> ma_used == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (result) {
             *result = NULL;
         }
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *old_value;
     Py_ssize_t ix = _Py_dict_lookup(mp, key, hash, &old_value);
@@ -2946,12 +3160,27 @@ pop_lock_held(PyObject *op, PyObject *key, PyObject **result)
     }
     PyDictObject *dict = (PyDictObject *)op;
 
-    if (dict->ma_used == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[411]) {
+      if ((dict -> ma_used == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 411\n");
+      else
+        fprintf(stderr, "reached bug index 411\n");
+    }
+    if ((!FIXREVERTER[411] && (dict -> ma_used == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (result) {
             *result = NULL;
         }
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Py_hash_t hash;
     if (!PyUnicode_CheckExact(key) || (hash = unicode_get_hash(key)) == -1) {
@@ -3352,15 +3581,45 @@ keys_lock_held(PyObject *dict)
   again:
     n = mp->ma_used;
     v = PyList_New(n);
-    if (v == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[423]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 423\n");
+      else
+        fprintf(stderr, "reached bug index 423\n");
+    }
+    if ((!FIXREVERTER[423] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
-    if (n != mp->ma_used) {
+        #ifdef FRCOV
+        }
+        #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[424]) {
+      if ((n != mp -> ma_used ) && !(0))
+        fprintf(stderr, "triggered bug index 424\n");
+      else
+        fprintf(stderr, "reached bug index 424\n");
+    }
+    if ((!FIXREVERTER[424] && (n != mp -> ma_used ))
+    #else
+    if (0
+    #endif
+    ) {
         /* Durnit.  The allocations caused the dict to resize.
          * Just start over, this shouldn't normally happen.
          */
         Py_DECREF(v);
         goto again;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Nothing we do below makes any function calls. */
     Py_ssize_t j = 0, pos = 0;
@@ -3698,8 +3957,23 @@ dict_dict_merge(PyInterpreterState *interp, PyDictObject *mp, PyDictObject *othe
             uint64_t new_version = _PyDict_NotifyEvent(
                     interp, PyDict_EVENT_CLONED, mp, (PyObject *)other, NULL);
             PyDictKeysObject *keys = clone_combined_dict_keys(other);
-            if (keys == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[436]) {
+              if ((keys == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 436\n");
+              else
+                fprintf(stderr, "reached bug index 436\n");
+            }
+            if ((!FIXREVERTER[436] && (keys == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return -1;
+                #ifdef FRCOV
+                }
+                #endif
 
             ensure_shared_on_resize(mp);
             dictkeys_decref(interp, mp->ma_keys, IS_DICT_SHARED(mp));
@@ -3807,7 +4081,19 @@ dict_merge(PyInterpreterState *interp, PyObject *a, PyObject *b, int override)
         PyObject *key, *value;
         int status;
 
-        if (keys == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[438]) {
+          if ((keys == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 438\n");
+          else
+            fprintf(stderr, "reached bug index 438\n");
+        }
+        if ((!FIXREVERTER[438] && (keys == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             /* Docstring says this is equivalent to E.keys() so
              * if E doesn't have a .keys() method we want
              * AttributeError to percolate up.  Might as well
@@ -3816,13 +4102,31 @@ dict_merge(PyInterpreterState *interp, PyObject *a, PyObject *b, int override)
             res = -1;
             goto slow_exit;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         iter = PyObject_GetIter(keys);
         Py_DECREF(keys);
-        if (iter == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[439]) {
+          if ((iter == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 439\n");
+          else
+            fprintf(stderr, "reached bug index 439\n");
+        }
+        if ((!FIXREVERTER[439] && (iter == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             res = -1;
             goto slow_exit;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         for (key = PyIter_Next(iter); key; key = PyIter_Next(iter)) {
             if (override != 1) {
@@ -3913,10 +4217,25 @@ static PyDictValues *
 copy_values(PyDictValues *values)
 {
     PyDictValues *newvalues = new_values(values->capacity);
-    if (newvalues == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[441]) {
+      if ((newvalues == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 441\n");
+      else
+        fprintf(stderr, "reached bug index 441\n");
+    }
+    if ((!FIXREVERTER[441] && (newvalues == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     newvalues->size = values->size;
     uint8_t *values_order = get_insertion_order_array(values);
     uint8_t *new_values_order = get_insertion_order_array(newvalues);
@@ -3938,22 +4257,67 @@ copy_lock_held(PyObject *o)
     ASSERT_DICT_LOCKED(o);
 
     mp = (PyDictObject *)o;
-    if (mp->ma_used == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[442]) {
+      if ((mp -> ma_used == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 442\n");
+      else
+        fprintf(stderr, "reached bug index 442\n");
+    }
+    if ((!FIXREVERTER[442] && (mp -> ma_used == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* The dict is empty; just return a new dict. */
         return PyDict_New();
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (_PyDict_HasSplitTable(mp)) {
         PyDictObject *split_copy;
         PyDictValues *newvalues = copy_values(mp->ma_values);
-        if (newvalues == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[443]) {
+          if ((newvalues == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 443\n");
+          else
+            fprintf(stderr, "reached bug index 443\n");
+        }
+        if ((!FIXREVERTER[443] && (newvalues == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return PyErr_NoMemory();
         }
+        #ifdef FRCOV
+        }
+        #endif
         split_copy = PyObject_GC_New(PyDictObject, &PyDict_Type);
-        if (split_copy == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[444]) {
+          if ((split_copy == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 444\n");
+          else
+            fprintf(stderr, "reached bug index 444\n");
+        }
+        if ((!FIXREVERTER[444] && (split_copy == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             free_values(newvalues, false);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         for (size_t i = 0; i < newvalues->capacity; i++) {
             Py_XINCREF(newvalues->values[i]);
         }
@@ -3986,15 +4350,45 @@ copy_lock_held(PyObject *o)
            PyDict_Merge, which produces a compacted copy.
         */
         PyDictKeysObject *keys = clone_combined_dict_keys(mp);
-        if (keys == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[445]) {
+          if ((keys == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 445\n");
+          else
+            fprintf(stderr, "reached bug index 445\n");
+        }
+        if ((!FIXREVERTER[445] && (keys == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         PyDictObject *new = (PyDictObject *)new_dict(interp, keys, NULL, 0, 0);
-        if (new == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[446]) {
+          if ((new == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 446\n");
+          else
+            fprintf(stderr, "reached bug index 446\n");
+        }
+        if ((!FIXREVERTER[446] && (new == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             /* In case of an error, `new_dict()` takes care of
                cleaning up `keys`. */
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         new->ma_used = mp->ma_used;
         ASSERT_CONSISTENT(new);
@@ -4007,8 +4401,23 @@ copy_lock_held(PyObject *o)
     }
 
     copy = PyDict_New();
-    if (copy == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[447]) {
+      if ((copy == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 447\n");
+      else
+        fprintf(stderr, "reached bug index 447\n");
+    }
+    if ((!FIXREVERTER[447] && (copy == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     if (dict_merge(interp, copy, o, 1) == 0)
         return copy;
     Py_DECREF(copy);
@@ -4890,10 +5299,25 @@ int
 PyDict_GetItemStringRef(PyObject *v, const char *key, PyObject **result)
 {
     PyObject *key_obj = PyUnicode_FromString(key);
-    if (key_obj == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[461]) {
+      if ((key_obj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 461\n");
+      else
+        fprintf(stderr, "reached bug index 461\n");
+    }
+    if ((!FIXREVERTER[461] && (key_obj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *result = NULL;
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int res = PyDict_GetItemRef(v, key_obj, result);
     Py_DECREF(key_obj);
     return res;
@@ -4915,8 +5339,23 @@ PyDict_SetItemString(PyObject *v, const char *key, PyObject *item)
     PyObject *kv;
     int err;
     kv = PyUnicode_FromString(key);
-    if (kv == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[463]) {
+      if ((kv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 463\n");
+      else
+        fprintf(stderr, "reached bug index 463\n");
+    }
+    if ((!FIXREVERTER[463] && (kv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     PyInterpreterState *interp = _PyInterpreterState_GET();
     _PyUnicode_InternImmortal(interp, &kv); /* XXX Should we really? */
     err = PyDict_SetItem(v, kv, item);
@@ -4939,8 +5378,23 @@ PyDict_DelItemString(PyObject *v, const char *key)
     PyObject *kv;
     int err;
     kv = PyUnicode_FromString(key);
-    if (kv == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[465]) {
+      if ((kv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 465\n");
+      else
+        fprintf(stderr, "reached bug index 465\n");
+    }
+    if ((!FIXREVERTER[465] && (kv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     err = PyDict_DelItem(v, kv);
     Py_DECREF(kv);
     return err;
@@ -7322,10 +7776,25 @@ uint32_t _PyDictKeys_GetVersionForCurrentState(PyInterpreterState *interp,
 static inline int
 validate_watcher_id(PyInterpreterState *interp, int watcher_id)
 {
-    if (watcher_id < 0 || watcher_id >= DICT_MAX_WATCHERS) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[540]) {
+      if ((watcher_id < 0 || watcher_id >= 8 ) && !(0))
+        fprintf(stderr, "triggered bug index 540\n");
+      else
+        fprintf(stderr, "reached bug index 540\n");
+    }
+    if ((!FIXREVERTER[540] && (watcher_id < 0 || watcher_id >= 8 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Format(PyExc_ValueError, "Invalid dict watcher ID %d", watcher_id);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!interp->dict_state.watchers[watcher_id]) {
         PyErr_Format(PyExc_ValueError, "No dict watcher set for ID %d", watcher_id);
         return -1;
diff --git a/Objects/exceptions.c b/Objects/exceptions.c
index 6376f2f012a..0ad1dbe0aae 100644
--- a/Objects/exceptions.c
+++ b/Objects/exceptions.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * New exceptions.c written in Iceland by Richard Jones and Georg Brandl.
  *
@@ -248,9 +252,24 @@ BaseException_add_note(PyObject *self, PyObject *note)
     }
     if (notes == NULL) {
         notes = PyList_New(0);
-        if (notes == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2421]) {
+          if ((notes == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2421\n");
+          else
+            fprintf(stderr, "reached bug index 2421\n");
+        }
+        if ((!FIXREVERTER[2421] && (notes == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (PyObject_SetAttr(self, &_Py_ID(__notes__), notes) < 0) {
             Py_DECREF(notes);
             return NULL;
@@ -319,10 +338,25 @@ BaseException_get_tb(PyBaseExceptionObject *self, void *Py_UNUSED(ignored))
 static int
 BaseException_set_tb(PyBaseExceptionObject *self, PyObject *tb, void *Py_UNUSED(ignored))
 {
-    if (tb == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2425]) {
+      if ((tb == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2425\n");
+      else
+        fprintf(stderr, "reached bug index 2425\n");
+    }
+    if ((!FIXREVERTER[2425] && (tb == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_TypeError, "__traceback__ may not be deleted");
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (PyTraceBack_Check(tb)) {
         Py_XSETREF(self->traceback, Py_NewRef(tb));
     }
@@ -3347,9 +3381,24 @@ get_memory_error(int allow_allocation, PyObject *args, PyObject *kwds)
     self->args = PyTuple_New(0);
     /* This shouldn't happen since the empty tuple is persistent */
 
-    if (self->args == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2463]) {
+      if ((self -> args == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2463\n");
+      else
+        fprintf(stderr, "reached bug index 2463\n");
+    }
+    if ((!FIXREVERTER[2463] && (self -> args == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     state->memerrors_freelist = (PyBaseExceptionObject *) self->dict;
     state->memerrors_numfree--;
diff --git a/Objects/fileobject.c b/Objects/fileobject.c
index bae49d367b6..b8f71e39d99 100644
--- a/Objects/fileobject.c
+++ b/Objects/fileobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* File object implementation (what's left of it -- see io.py) */
 
 #include "Python.h"
@@ -53,10 +57,25 @@ PyFile_GetLine(PyObject *f, int n)
 {
     PyObject *result;
 
-    if (f == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2361]) {
+      if ((f == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2361\n");
+      else
+        fprintf(stderr, "reached bug index 2361\n");
+    }
+    if ((!FIXREVERTER[2361] && (f == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (n <= 0) {
         result = PyObject_CallMethodNoArgs(f, &_Py_ID(readline));
@@ -106,27 +125,87 @@ PyFile_WriteObject(PyObject *v, PyObject *f, int flags)
 {
     PyObject *writer, *value, *result;
 
-    if (f == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2362]) {
+      if ((f == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2362\n");
+      else
+        fprintf(stderr, "reached bug index 2362\n");
+    }
+    if ((!FIXREVERTER[2362] && (f == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_TypeError, "writeobject with NULL file");
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     writer = PyObject_GetAttr(f, &_Py_ID(write));
-    if (writer == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2363]) {
+      if ((writer == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2363\n");
+      else
+        fprintf(stderr, "reached bug index 2363\n");
+    }
+    if ((!FIXREVERTER[2363] && (writer == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     if (flags & Py_PRINT_RAW) {
         value = PyObject_Str(v);
     }
     else
         value = PyObject_Repr(v);
-    if (value == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2364]) {
+      if ((value == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2364\n");
+      else
+        fprintf(stderr, "reached bug index 2364\n");
+    }
+    if ((!FIXREVERTER[2364] && (value == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(writer);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     result = PyObject_CallOneArg(writer, value);
     Py_DECREF(value);
     Py_DECREF(writer);
-    if (result == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2365]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2365\n");
+      else
+        fprintf(stderr, "reached bug index 2365\n");
+    }
+    if ((!FIXREVERTER[2365] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     Py_DECREF(result);
     return 0;
 }
@@ -144,8 +223,23 @@ PyFile_WriteString(const char *s, PyObject *f)
     else if (!PyErr_Occurred()) {
         PyObject *v = PyUnicode_FromString(s);
         int err;
-        if (v == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2366]) {
+          if ((v == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2366\n");
+          else
+            fprintf(stderr, "reached bug index 2366\n");
+        }
+        if ((!FIXREVERTER[2366] && (v == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
         err = PyFile_WriteObject(v, f, Py_PRINT_RAW);
         Py_DECREF(v);
         return err;
@@ -183,8 +277,23 @@ PyObject_AsFileDescriptor(PyObject *o)
     else if (meth != NULL) {
         PyObject *fno = _PyObject_CallNoArgs(meth);
         Py_DECREF(meth);
-        if (fno == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2367]) {
+          if ((fno == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2367\n");
+          else
+            fprintf(stderr, "reached bug index 2367\n");
+        }
+        if ((!FIXREVERTER[2367] && (fno == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
 
         if (PyLong_Check(fno)) {
             fd = PyLong_AsInt(fno);
@@ -205,12 +314,27 @@ PyObject_AsFileDescriptor(PyObject *o)
 
     if (fd == -1 && PyErr_Occurred())
         return -1;
-    if (fd < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2368]) {
+      if ((fd < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2368\n");
+      else
+        fprintf(stderr, "reached bug index 2368\n");
+    }
+    if ((!FIXREVERTER[2368] && (fd < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Format(PyExc_ValueError,
                      "file descriptor cannot be a negative integer (%i)",
                      fd);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return fd;
 }
 
@@ -534,9 +658,24 @@ int
 _PyFile_Flush(PyObject *file)
 {
     PyObject *tmp = PyObject_CallMethodNoArgs(file, &_Py_ID(flush));
-    if (tmp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2373]) {
+      if ((tmp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2373\n");
+      else
+        fprintf(stderr, "reached bug index 2373\n");
+    }
+    if ((!FIXREVERTER[2373] && (tmp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_DECREF(tmp);
     return 0;
 }
diff --git a/Objects/floatobject.c b/Objects/floatobject.c
index 2627ba80eed..f005adf2298 100644
--- a/Objects/floatobject.c
+++ b/Objects/floatobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Float object implementation */
 
 /* XXX There should be overflow checks here, but it's hard to check
@@ -286,17 +290,44 @@ PyFloat_AsDouble(PyObject *op)
     PyObject *res;
     double val;
 
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1119]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1119\n");
+      else
+        fprintf(stderr, "reached bug index 1119\n");
+    }
+    if ((!FIXREVERTER[1119] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadArgument();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (PyFloat_Check(op)) {
         return PyFloat_AS_DOUBLE(op);
     }
 
     nb = Py_TYPE(op)->tp_as_number;
-    if (nb == NULL || nb->nb_float == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1120]) {
+      if ((nb == (void *) 0 || nb -> nb_float == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1120\n");
+      else
+        fprintf(stderr, "reached bug index 1120\n");
+    }
+    if ((!FIXREVERTER[1120] && (nb == (void *) 0 || nb -> nb_float == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (nb && nb->nb_index) {
             PyObject *res = _PyNumber_Index(op);
             if (!res) {
@@ -310,11 +341,29 @@ PyFloat_AsDouble(PyObject *op)
                      Py_TYPE(op)->tp_name);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     res = (*nb->nb_float) (op);
-    if (res == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1121]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1121\n");
+      else
+        fprintf(stderr, "reached bug index 1121\n");
+    }
+    if ((!FIXREVERTER[1121] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyFloat_CheckExact(res)) {
         if (!PyFloat_Check(res)) {
             PyErr_Format(PyExc_TypeError,
diff --git a/Objects/frameobject.c b/Objects/frameobject.c
index 3dc9ff058a5..f607e76c1c3 100644
--- a/Objects/frameobject.c
+++ b/Objects/frameobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Frame object implementation */
 
 #include "Python.h"
@@ -786,15 +790,45 @@ PyFrame_GetLineNumber(PyFrameObject *f)
         // We should calculate it once. If we can't get the line number,
         // set f->f_lineno to 0.
         f->f_lineno = PyUnstable_InterpreterFrame_GetLine(f->f_frame);
-        if (f->f_lineno < 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3303]) {
+          if ((f -> f_lineno < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3303\n");
+          else
+            fprintf(stderr, "reached bug index 3303\n");
+        }
+        if ((!FIXREVERTER[3303] && (f -> f_lineno < 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             f->f_lineno = 0;
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
-    if (f->f_lineno > 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3304]) {
+      if ((f -> f_lineno > 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3304\n");
+      else
+        fprintf(stderr, "reached bug index 3304\n");
+    }
+    if ((!FIXREVERTER[3304] && (f -> f_lineno > 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return f->f_lineno;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return PyUnstable_InterpreterFrame_GetLine(f->f_frame);
 }
 
@@ -1778,9 +1812,24 @@ _PyFrame_New_NoTrack(PyCodeObject *code)
     CALL_STAT_INC(frame_objects_created);
     int slots = code->co_nlocalsplus + code->co_stacksize;
     PyFrameObject *f = PyObject_GC_NewVar(PyFrameObject, &PyFrame_Type, slots);
-    if (f == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3320]) {
+      if ((f == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3320\n");
+      else
+        fprintf(stderr, "reached bug index 3320\n");
+    }
+    if ((!FIXREVERTER[3320] && (f == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     f->f_back = NULL;
     f->f_trace = NULL;
     f->f_trace_lines = 1;
diff --git a/Objects/listobject.c b/Objects/listobject.c
index 9eae9626f7c..2c002872924 100644
--- a/Objects/listobject.c
+++ b/Objects/listobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* List object implementation */
 
 #include "Python.h"
@@ -123,8 +127,23 @@ list_resize(PyListObject *self, Py_ssize_t newsize)
     if (newsize - Py_SIZE(self) > (Py_ssize_t)(new_allocated - newsize))
         new_allocated = ((size_t)newsize + 3) & ~(size_t)3;
 
-    if (newsize == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3459]) {
+      if ((newsize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3459\n");
+      else
+        fprintf(stderr, "reached bug index 3459\n");
+    }
+    if ((!FIXREVERTER[3459] && (newsize == 0 ))
+    #else
+    if (0
+    #endif
+    )
         new_allocated = 0;
+        #ifdef FRCOV
+        }
+        #endif
 
 #ifdef Py_GIL_DISABLED
     _PyListArray *array = list_allocate_array(new_allocated);
@@ -161,10 +180,25 @@ list_resize(PyListObject *self, Py_ssize_t newsize)
         // integer overflow
         items = NULL;
     }
-    if (items == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3460]) {
+      if ((items == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3460\n");
+      else
+        fprintf(stderr, "reached bug index 3460\n");
+    }
+    if ((!FIXREVERTER[3460] && (items == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     self->ob_item = items;
     Py_SET_SIZE(self, newsize);
     self->allocated = new_allocated;
@@ -238,10 +272,25 @@ PyList_New(Py_ssize_t size)
 {
     PyListObject *op;
 
-    if (size < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3462]) {
+      if ((size < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3462\n");
+      else
+        fprintf(stderr, "reached bug index 3462\n");
+    }
+    if ((!FIXREVERTER[3462] && (size < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 #ifdef WITH_FREELISTS
     struct _Py_list_freelist *list_freelist = get_list_freelist();
@@ -255,9 +304,24 @@ PyList_New(Py_ssize_t size)
 #endif
     {
         op = PyObject_GC_New(PyListObject, &PyList_Type);
-        if (op == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3463]) {
+          if ((op == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3463\n");
+          else
+            fprintf(stderr, "reached bug index 3463\n");
+        }
+        if ((!FIXREVERTER[3463] && (op == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     if (size <= 0) {
         op->ob_item = NULL;
@@ -274,10 +338,25 @@ PyList_New(Py_ssize_t size)
 #else
         op->ob_item = (PyObject **) PyMem_Calloc(size, sizeof(PyObject *));
 #endif
-        if (op->ob_item == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3464]) {
+          if ((op -> ob_item == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3464\n");
+          else
+            fprintf(stderr, "reached bug index 3464\n");
+        }
+        if ((!FIXREVERTER[3464] && (op -> ob_item == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(op);
             return PyErr_NoMemory();
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     Py_SET_SIZE(op, size);
     op->allocated = size;
@@ -290,9 +369,24 @@ list_new_prealloc(Py_ssize_t size)
 {
     assert(size > 0);
     PyListObject *op = (PyListObject *) PyList_New(0);
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3465]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3465\n");
+      else
+        fprintf(stderr, "reached bug index 3465\n");
+    }
+    if ((!FIXREVERTER[3465] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(op->ob_item == NULL);
 #ifdef Py_GIL_DISABLED
     _PyListArray *array = list_allocate_array(size);
@@ -303,10 +397,25 @@ list_new_prealloc(Py_ssize_t size)
     op->ob_item = array->ob_item;
 #else
     op->ob_item = PyMem_New(PyObject *, size);
-    if (op->ob_item == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3466]) {
+      if ((op -> ob_item == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3466\n");
+      else
+        fprintf(stderr, "reached bug index 3466\n");
+    }
+    if ((!FIXREVERTER[3466] && (op -> ob_item == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(op);
         return PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
 #endif
     op->allocated = size;
     return (PyObject *) op;
@@ -679,12 +788,42 @@ list_slice_lock_held(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh)
     PyObject **src, **dest;
     Py_ssize_t i, len;
     len = ihigh - ilow;
-    if (len <= 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3475]) {
+      if ((len <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3475\n");
+      else
+        fprintf(stderr, "reached bug index 3475\n");
+    }
+    if ((!FIXREVERTER[3475] && (len <= 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyList_New(0);
     }
+    #ifdef FRCOV
+    }
+    #endif
     np = (PyListObject *) list_new_prealloc(len);
-    if (np == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3476]) {
+      if ((np == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3476\n");
+      else
+        fprintf(stderr, "reached bug index 3476\n");
+    }
+    if ((!FIXREVERTER[3476] && (np == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     src = a->ob_item + ilow;
     dest = np->ob_item;
@@ -828,9 +967,24 @@ static void
 list_clear_impl(PyListObject *a, bool is_resize)
 {
     PyObject **items = a->ob_item;
-    if (items == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3480]) {
+      if ((items == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3480\n");
+      else
+        fprintf(stderr, "reached bug index 3480\n");
+    }
+    if ((!FIXREVERTER[3480] && (items == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Because XDECREF can recursively invoke operations on
        this list, we make it empty first. */
@@ -895,8 +1049,23 @@ list_ass_slice_lock_held(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyO
         n = 0;
     else {
         v_as_SF = PySequence_Fast(v, "can only assign an iterable");
-        if(v_as_SF == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3481]) {
+          if ((v_as_SF == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3481\n");
+          else
+            fprintf(stderr, "reached bug index 3481\n");
+        }
+        if ((!FIXREVERTER[3481] && (v_as_SF == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto Error;
+            #ifdef FRCOV
+            }
+            #endif
         n = PySequence_Fast_GET_SIZE(v_as_SF);
         vitem = PySequence_Fast_ITEMS(v_as_SF);
     }
@@ -925,10 +1094,25 @@ list_ass_slice_lock_held(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyO
     if (s) {
         if (s > sizeof(recycle_on_stack)) {
             recycle = (PyObject **)PyMem_Malloc(s);
-            if (recycle == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3482]) {
+              if ((recycle == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3482\n");
+              else
+                fprintf(stderr, "reached bug index 3482\n");
+            }
+            if ((!FIXREVERTER[3482] && (recycle == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 PyErr_NoMemory();
                 goto Error;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         memcpy(recycle, &item[ilow], s);
     }
@@ -975,9 +1159,24 @@ list_ass_slice(PyListObject *a, Py_ssize_t ilow, Py_ssize_t ihigh, PyObject *v)
         Py_BEGIN_CRITICAL_SECTION(a);
         Py_ssize_t n = PyList_GET_SIZE(a);
         PyObject *copy = list_slice_lock_held(a, 0, n);
-        if (copy == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3483]) {
+          if ((copy == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3483\n");
+          else
+            fprintf(stderr, "reached bug index 3483\n");
+        }
+        if ((!FIXREVERTER[3483] && (copy == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         ret = list_ass_slice_lock_held(a, ilow, ihigh, copy);
         Py_DECREF(copy);
         Py_END_CRITICAL_SECTION();
@@ -1892,8 +2091,23 @@ count_run(MergeState *ms, sortslice *slo, Py_ssize_t nremaining)
         IF_NEXT_SMALLER
             break;
     }
-    if (n == nremaining)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3492]) {
+      if ((n == nremaining ) && !(0))
+        fprintf(stderr, "triggered bug index 3492\n");
+      else
+        fprintf(stderr, "reached bug index 3492\n");
+    }
+    if ((!FIXREVERTER[3492] && (n == nremaining ))
+    #else
+    if (0
+    #endif
+    )
         return n;
+        #ifdef FRCOV
+        }
+        #endif
     /* lo[n] is strictly less */
     /* If n is 1 now, then the first compare established it's a descending
      * run, so fall through to the descending case. But if n > 1, there are
@@ -2153,8 +2367,23 @@ merge_init(MergeState *ms, Py_ssize_t list_size, int has_keyfunc,
         /* ms->alloced describes how many keys will be stored at
            ms->temparray, but we also need to store the values.  Hence,
            ms->alloced is capped at half of MERGESTATE_TEMP_SIZE. */
-        if (MERGESTATE_TEMP_SIZE / 2 < ms->alloced)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3493]) {
+          if ((256 / 2 < ms -> alloced  ) && !(0))
+            fprintf(stderr, "triggered bug index 3493\n");
+          else
+            fprintf(stderr, "reached bug index 3493\n");
+        }
+        if ((!FIXREVERTER[3493] && (256 / 2 < ms -> alloced  ))
+        #else
+        if (0
+        #endif
+        )
             ms->alloced = MERGESTATE_TEMP_SIZE / 2;
+            #ifdef FRCOV
+            }
+            #endif
         ms->a.values = &ms->temparray[ms->alloced];
     }
     else {
@@ -2191,8 +2420,23 @@ merge_getmem(MergeState *ms, Py_ssize_t need)
     int multiplier;
 
     assert(ms != NULL);
-    if (need <= ms->alloced)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3494]) {
+      if ((need <= ms -> alloced ) && !(0))
+        fprintf(stderr, "triggered bug index 3494\n");
+      else
+        fprintf(stderr, "reached bug index 3494\n");
+    }
+    if ((!FIXREVERTER[3494] && (need <= ms -> alloced ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
 
     multiplier = ms->a.values != NULL ? 2 : 1;
 
@@ -2243,10 +2487,40 @@ merge_lo(MergeState *ms, sortslice ssa, Py_ssize_t na,
 
     sortslice_copy_incr(&dest, &ssb);
     --nb;
-    if (nb == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3495]) {
+      if ((nb == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3495\n");
+      else
+        fprintf(stderr, "reached bug index 3495\n");
+    }
+    if ((!FIXREVERTER[3495] && (nb == 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto Succeed;
-    if (na == 1)
+        #ifdef FRCOV
+        }
+        #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3496]) {
+      if ((na == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 3496\n");
+      else
+        fprintf(stderr, "reached bug index 3496\n");
+    }
+    if ((!FIXREVERTER[3496] && (na == 1 ))
+    #else
+    if (0
+    #endif
+    )
         goto CopyB;
+        #ifdef FRCOV
+        }
+        #endif
 
     min_gallop = ms->min_gallop;
     for (;;) {
@@ -2260,26 +2534,101 @@ merge_lo(MergeState *ms, sortslice ssa, Py_ssize_t na,
             assert(na > 1 && nb > 0);
             k = ISLT(ssb.keys[0], ssa.keys[0]);
             if (k) {
-                if (k < 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3497]) {
+                  if ((k < 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3497\n");
+                  else
+                    fprintf(stderr, "reached bug index 3497\n");
+                }
+                if ((!FIXREVERTER[3497] && (k < 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Fail;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 sortslice_copy_incr(&dest, &ssb);
                 ++bcount;
                 acount = 0;
                 --nb;
-                if (nb == 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3498]) {
+                  if ((nb == 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3498\n");
+                  else
+                    fprintf(stderr, "reached bug index 3498\n");
+                }
+                if ((!FIXREVERTER[3498] && (nb == 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Succeed;
-                if (bcount >= min_gallop)
+                    #ifdef FRCOV
+                    }
+                    #endif
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3499]) {
+                  if ((bcount >= min_gallop ) && !(0))
+                    fprintf(stderr, "triggered bug index 3499\n");
+                  else
+                    fprintf(stderr, "reached bug index 3499\n");
+                }
+                if ((!FIXREVERTER[3499] && (bcount >= min_gallop ))
+                #else
+                if (0
+                #endif
+                )
                     break;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
             else {
                 sortslice_copy_incr(&dest, &ssa);
                 ++acount;
                 bcount = 0;
                 --na;
-                if (na == 1)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3500]) {
+                  if ((na == 1 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3500\n");
+                  else
+                    fprintf(stderr, "reached bug index 3500\n");
+                }
+                if ((!FIXREVERTER[3500] && (na == 1 ))
+                #else
+                if (0
+                #endif
+                )
                     goto CopyB;
-                if (acount >= min_gallop)
+                    #ifdef FRCOV
+                    }
+                    #endif
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3501]) {
+                  if ((acount >= min_gallop ) && !(0))
+                    fprintf(stderr, "triggered bug index 3501\n");
+                  else
+                    fprintf(stderr, "reached bug index 3501\n");
+                }
+                if ((!FIXREVERTER[3501] && (acount >= min_gallop ))
+                #else
+                if (0
+                #endif
+                )
                     break;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
         }
 
@@ -2296,42 +2645,147 @@ merge_lo(MergeState *ms, sortslice ssa, Py_ssize_t na,
             k = gallop_right(ms, ssb.keys[0], ssa.keys, na, 0);
             acount = k;
             if (k) {
-                if (k < 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3502]) {
+                  if ((k < 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3502\n");
+                  else
+                    fprintf(stderr, "reached bug index 3502\n");
+                }
+                if ((!FIXREVERTER[3502] && (k < 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Fail;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 sortslice_memcpy(&dest, 0, &ssa, 0, k);
                 sortslice_advance(&dest, k);
                 sortslice_advance(&ssa, k);
                 na -= k;
-                if (na == 1)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3503]) {
+                  if ((na == 1 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3503\n");
+                  else
+                    fprintf(stderr, "reached bug index 3503\n");
+                }
+                if ((!FIXREVERTER[3503] && (na == 1 ))
+                #else
+                if (0
+                #endif
+                )
                     goto CopyB;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 /* na==0 is impossible now if the comparison
                  * function is consistent, but we can't assume
                  * that it is.
                  */
-                if (na == 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3504]) {
+                  if ((na == 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3504\n");
+                  else
+                    fprintf(stderr, "reached bug index 3504\n");
+                }
+                if ((!FIXREVERTER[3504] && (na == 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Succeed;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
             sortslice_copy_incr(&dest, &ssb);
             --nb;
-            if (nb == 0)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3505]) {
+              if ((nb == 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3505\n");
+              else
+                fprintf(stderr, "reached bug index 3505\n");
+            }
+            if ((!FIXREVERTER[3505] && (nb == 0 ))
+            #else
+            if (0
+            #endif
+            )
                 goto Succeed;
+                #ifdef FRCOV
+                }
+                #endif
 
             k = gallop_left(ms, ssa.keys[0], ssb.keys, nb, 0);
             bcount = k;
             if (k) {
-                if (k < 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3506]) {
+                  if ((k < 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3506\n");
+                  else
+                    fprintf(stderr, "reached bug index 3506\n");
+                }
+                if ((!FIXREVERTER[3506] && (k < 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Fail;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 sortslice_memmove(&dest, 0, &ssb, 0, k);
                 sortslice_advance(&dest, k);
                 sortslice_advance(&ssb, k);
                 nb -= k;
-                if (nb == 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3507]) {
+                  if ((nb == 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3507\n");
+                  else
+                    fprintf(stderr, "reached bug index 3507\n");
+                }
+                if ((!FIXREVERTER[3507] && (nb == 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Succeed;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
             sortslice_copy_incr(&dest, &ssa);
             --na;
-            if (na == 1)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3508]) {
+              if ((na == 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 3508\n");
+              else
+                fprintf(stderr, "reached bug index 3508\n");
+            }
+            if ((!FIXREVERTER[3508] && (na == 1 ))
+            #else
+            if (0
+            #endif
+            )
                 goto CopyB;
+                #ifdef FRCOV
+                }
+                #endif
         } while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
         ++min_gallop;           /* penalize it for leaving galloping mode */
         ms->min_gallop = min_gallop;
@@ -2375,16 +2829,61 @@ merge_hi(MergeState *ms, sortslice ssa, Py_ssize_t na,
     basea = ssa;
     baseb = ms->a;
     ssb.keys = ms->a.keys + nb - 1;
-    if (ssb.values != NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3509]) {
+      if ((ssb . values != (void *) 0  ) && !(0))
+        fprintf(stderr, "triggered bug index 3509\n");
+      else
+        fprintf(stderr, "reached bug index 3509\n");
+    }
+    if ((!FIXREVERTER[3509] && (ssb . values != (void *) 0  ))
+    #else
+    if (0
+    #endif
+    )
         ssb.values = ms->a.values + nb - 1;
+        #ifdef FRCOV
+        }
+        #endif
     sortslice_advance(&ssa, na - 1);
 
     sortslice_copy_decr(&dest, &ssa);
     --na;
-    if (na == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3510]) {
+      if ((na == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3510\n");
+      else
+        fprintf(stderr, "reached bug index 3510\n");
+    }
+    if ((!FIXREVERTER[3510] && (na == 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto Succeed;
-    if (nb == 1)
+        #ifdef FRCOV
+        }
+        #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3511]) {
+      if ((nb == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 3511\n");
+      else
+        fprintf(stderr, "reached bug index 3511\n");
+    }
+    if ((!FIXREVERTER[3511] && (nb == 1 ))
+    #else
+    if (0
+    #endif
+    )
         goto CopyA;
+        #ifdef FRCOV
+        }
+        #endif
 
     min_gallop = ms->min_gallop;
     for (;;) {
@@ -2398,26 +2897,101 @@ merge_hi(MergeState *ms, sortslice ssa, Py_ssize_t na,
             assert(na > 0 && nb > 1);
             k = ISLT(ssb.keys[0], ssa.keys[0]);
             if (k) {
-                if (k < 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3512]) {
+                  if ((k < 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3512\n");
+                  else
+                    fprintf(stderr, "reached bug index 3512\n");
+                }
+                if ((!FIXREVERTER[3512] && (k < 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Fail;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 sortslice_copy_decr(&dest, &ssa);
                 ++acount;
                 bcount = 0;
                 --na;
-                if (na == 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3513]) {
+                  if ((na == 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3513\n");
+                  else
+                    fprintf(stderr, "reached bug index 3513\n");
+                }
+                if ((!FIXREVERTER[3513] && (na == 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Succeed;
-                if (acount >= min_gallop)
+                    #ifdef FRCOV
+                    }
+                    #endif
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3514]) {
+                  if ((acount >= min_gallop ) && !(0))
+                    fprintf(stderr, "triggered bug index 3514\n");
+                  else
+                    fprintf(stderr, "reached bug index 3514\n");
+                }
+                if ((!FIXREVERTER[3514] && (acount >= min_gallop ))
+                #else
+                if (0
+                #endif
+                )
                     break;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
             else {
                 sortslice_copy_decr(&dest, &ssb);
                 ++bcount;
                 acount = 0;
                 --nb;
-                if (nb == 1)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3515]) {
+                  if ((nb == 1 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3515\n");
+                  else
+                    fprintf(stderr, "reached bug index 3515\n");
+                }
+                if ((!FIXREVERTER[3515] && (nb == 1 ))
+                #else
+                if (0
+                #endif
+                )
                     goto CopyA;
-                if (bcount >= min_gallop)
+                    #ifdef FRCOV
+                    }
+                    #endif
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3516]) {
+                  if ((bcount >= min_gallop ) && !(0))
+                    fprintf(stderr, "triggered bug index 3516\n");
+                  else
+                    fprintf(stderr, "reached bug index 3516\n");
+                }
+                if ((!FIXREVERTER[3516] && (bcount >= min_gallop ))
+                #else
+                if (0
+                #endif
+                )
                     break;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
         }
 
@@ -2432,8 +3006,23 @@ merge_hi(MergeState *ms, sortslice ssa, Py_ssize_t na,
             min_gallop -= min_gallop > 1;
             ms->min_gallop = min_gallop;
             k = gallop_right(ms, ssb.keys[0], basea.keys, na, na-1);
-            if (k < 0)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3517]) {
+              if ((k < 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3517\n");
+              else
+                fprintf(stderr, "reached bug index 3517\n");
+            }
+            if ((!FIXREVERTER[3517] && (k < 0 ))
+            #else
+            if (0
+            #endif
+            )
                 goto Fail;
+                #ifdef FRCOV
+                }
+                #endif
             k = na - k;
             acount = k;
             if (k) {
@@ -2441,17 +3030,62 @@ merge_hi(MergeState *ms, sortslice ssa, Py_ssize_t na,
                 sortslice_advance(&ssa, -k);
                 sortslice_memmove(&dest, 1, &ssa, 1, k);
                 na -= k;
-                if (na == 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3518]) {
+                  if ((na == 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3518\n");
+                  else
+                    fprintf(stderr, "reached bug index 3518\n");
+                }
+                if ((!FIXREVERTER[3518] && (na == 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Succeed;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
             sortslice_copy_decr(&dest, &ssb);
             --nb;
-            if (nb == 1)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3519]) {
+              if ((nb == 1 ) && !(0))
+                fprintf(stderr, "triggered bug index 3519\n");
+              else
+                fprintf(stderr, "reached bug index 3519\n");
+            }
+            if ((!FIXREVERTER[3519] && (nb == 1 ))
+            #else
+            if (0
+            #endif
+            )
                 goto CopyA;
+                #ifdef FRCOV
+                }
+                #endif
 
             k = gallop_left(ms, ssa.keys[0], baseb.keys, nb, nb-1);
-            if (k < 0)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3520]) {
+              if ((k < 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3520\n");
+              else
+                fprintf(stderr, "reached bug index 3520\n");
+            }
+            if ((!FIXREVERTER[3520] && (k < 0 ))
+            #else
+            if (0
+            #endif
+            )
                 goto Fail;
+                #ifdef FRCOV
+                }
+                #endif
             k = nb - k;
             bcount = k;
             if (k) {
@@ -2459,19 +3093,64 @@ merge_hi(MergeState *ms, sortslice ssa, Py_ssize_t na,
                 sortslice_advance(&ssb, -k);
                 sortslice_memcpy(&dest, 1, &ssb, 1, k);
                 nb -= k;
-                if (nb == 1)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3521]) {
+                  if ((nb == 1 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3521\n");
+                  else
+                    fprintf(stderr, "reached bug index 3521\n");
+                }
+                if ((!FIXREVERTER[3521] && (nb == 1 ))
+                #else
+                if (0
+                #endif
+                )
                     goto CopyA;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 /* nb==0 is impossible now if the comparison
                  * function is consistent, but we can't assume
                  * that it is.
                  */
-                if (nb == 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3522]) {
+                  if ((nb == 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3522\n");
+                  else
+                    fprintf(stderr, "reached bug index 3522\n");
+                }
+                if ((!FIXREVERTER[3522] && (nb == 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto Succeed;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
             sortslice_copy_decr(&dest, &ssa);
             --na;
-            if (na == 0)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3523]) {
+              if ((na == 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3523\n");
+              else
+                fprintf(stderr, "reached bug index 3523\n");
+            }
+            if ((!FIXREVERTER[3523] && (na == 0 ))
+            #else
+            if (0
+            #endif
+            )
                 goto Succeed;
+                #ifdef FRCOV
+                }
+                #endif
         } while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
         ++min_gallop;           /* penalize it for leaving galloping mode */
         ms->min_gallop = min_gallop;
@@ -2527,19 +3206,64 @@ merge_at(MergeState *ms, Py_ssize_t i)
      * ignored (already in place).
      */
     k = gallop_right(ms, *ssb.keys, ssa.keys, na, 0);
-    if (k < 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3524]) {
+      if ((k < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3524\n");
+      else
+        fprintf(stderr, "reached bug index 3524\n");
+    }
+    if ((!FIXREVERTER[3524] && (k < 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     sortslice_advance(&ssa, k);
     na -= k;
-    if (na == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3525]) {
+      if ((na == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3525\n");
+      else
+        fprintf(stderr, "reached bug index 3525\n");
+    }
+    if ((!FIXREVERTER[3525] && (na == 0 ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Where does a end in b?  Elements in b after that can be
      * ignored (already in place).
      */
     nb = gallop_left(ms, ssa.keys[na-1], ssb.keys, nb, nb-1);
-    if (nb <= 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3526]) {
+      if ((nb <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3526\n");
+      else
+        fprintf(stderr, "reached bug index 3526\n");
+    }
+    if ((!FIXREVERTER[3526] && (nb <= 0 ))
+    #else
+    if (0
+    #endif
+    )
         return nb;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Merge what remains of the runs, using a temp array with
      * min(na, nb) elements.
@@ -2895,10 +3619,25 @@ list_sort_impl(PyListObject *self, PyObject *keyfunc, int reverse)
             keys = &ms.temparray[saved_ob_size+1];
         else {
             keys = PyMem_Malloc(sizeof(PyObject *) * saved_ob_size);
-            if (keys == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3532]) {
+              if ((keys == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3532\n");
+              else
+                fprintf(stderr, "reached bug index 3532\n");
+            }
+            if ((!FIXREVERTER[3532] && (keys == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 PyErr_NoMemory();
                 goto keyfunc_fail;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
 
         for (i = 0; i < saved_ob_size ; i++) {
@@ -3037,8 +3776,23 @@ list_sort_impl(PyListObject *self, PyObject *keyfunc, int reverse)
 
         /* Identify next run. */
         n = count_run(&ms, &lo, nremaining);
-        if (n < 0)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3534]) {
+          if ((n < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3534\n");
+          else
+            fprintf(stderr, "reached bug index 3534\n");
+        }
+        if ((!FIXREVERTER[3534] && (n < 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto fail;
+            #ifdef FRCOV
+            }
+            #endif
         /* If short, extend to min(minrun, nremaining). */
         if (n < minrun) {
             const Py_ssize_t force = nremaining <= minrun ?
@@ -3128,8 +3882,23 @@ PyList_Sort(PyObject *v)
     Py_BEGIN_CRITICAL_SECTION(v);
     v = list_sort_impl((PyListObject *)v, NULL, 0);
     Py_END_CRITICAL_SECTION();
-    if (v == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3535]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3535\n");
+      else
+        fprintf(stderr, "reached bug index 3535\n");
+    }
+    if ((!FIXREVERTER[3535] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     Py_DECREF(v);
     return 0;
 }
diff --git a/Objects/longobject.c b/Objects/longobject.c
index 4ca259fb08e..4c5ea62268e 100644
--- a/Objects/longobject.c
+++ b/Objects/longobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Long (arbitrary precision) integer object implementation */
 
 /* XXX The functional organization of this file is terrible */
@@ -207,10 +211,25 @@ _PyLong_FromMedium(sdigit x)
     assert(is_medium_int(x));
     /* We could use a freelist here */
     PyLongObject *v = PyObject_Malloc(sizeof(PyLongObject));
-    if (v == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2230]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2230\n");
+      else
+        fprintf(stderr, "reached bug index 2230\n");
+    }
+    if ((!FIXREVERTER[2230] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     digit abs_x = x < 0 ? -x : x;
     _PyLong_SetSignAndDigitCount(v, x<0?-1:1, 1);
     _PyObject_Init((PyObject*)v, &PyLong_Type);
@@ -468,18 +487,48 @@ PyLong_AsLongAndOverflow(PyObject *vv, int *overflow)
     int do_decref = 0; /* if PyNumber_Index was called */
 
     *overflow = 0;
-    if (vv == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2232]) {
+      if ((vv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2232\n");
+      else
+        fprintf(stderr, "reached bug index 2232\n");
+    }
+    if ((!FIXREVERTER[2232] && (vv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (PyLong_Check(vv)) {
         v = (PyLongObject *)vv;
     }
     else {
         v = (PyLongObject *)_PyNumber_Index(vv);
-        if (v == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2233]) {
+          if ((v == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2233\n");
+          else
+            fprintf(stderr, "reached bug index 2233\n");
+        }
+        if ((!FIXREVERTER[2233] && (v == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
         do_decref = 1;
     }
     if (_PyLong_IsCompact(v)) {
@@ -572,10 +621,25 @@ PyLong_AsSsize_t(PyObject *vv) {
     Py_ssize_t i;
     int sign;
 
-    if (vv == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2234]) {
+      if ((vv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2234\n");
+      else
+        fprintf(stderr, "reached bug index 2234\n");
+    }
+    if ((!FIXREVERTER[2234] && (vv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyLong_Check(vv)) {
         PyErr_SetString(PyExc_TypeError, "an integer is required");
         return -1;
@@ -621,10 +685,25 @@ PyLong_AsUnsignedLong(PyObject *vv)
     unsigned long x, prev;
     Py_ssize_t i;
 
-    if (vv == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2235]) {
+      if ((vv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2235\n");
+      else
+        fprintf(stderr, "reached bug index 2235\n");
+    }
+    if ((!FIXREVERTER[2235] && (vv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return (unsigned long)-1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyLong_Check(vv)) {
         PyErr_SetString(PyExc_TypeError, "an integer is required");
         return (unsigned long)-1;
@@ -674,10 +753,25 @@ PyLong_AsSize_t(PyObject *vv)
     size_t x, prev;
     Py_ssize_t i;
 
-    if (vv == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2236]) {
+      if ((vv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2236\n");
+      else
+        fprintf(stderr, "reached bug index 2236\n");
+    }
+    if ((!FIXREVERTER[2236] && (vv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return (size_t) -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyLong_Check(vv)) {
         PyErr_SetString(PyExc_TypeError, "an integer is required");
         return (size_t)-1;
@@ -739,18 +833,48 @@ PyLong_AsUnsignedLongMask(PyObject *op)
     PyLongObject *lo;
     unsigned long val;
 
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2237]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2237\n");
+      else
+        fprintf(stderr, "reached bug index 2237\n");
+    }
+    if ((!FIXREVERTER[2237] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return (unsigned long)-1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (PyLong_Check(op)) {
         return _PyLong_AsUnsignedLongMask(op);
     }
 
     lo = (PyLongObject *)_PyNumber_Index(op);
-    if (lo == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2238]) {
+      if ((lo == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2238\n");
+      else
+        fprintf(stderr, "reached bug index 2238\n");
+    }
+    if ((!FIXREVERTER[2238] && (lo == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return (unsigned long)-1;
+        #ifdef FRCOV
+        }
+        #endif
 
     val = _PyLong_AsUnsignedLongMask((PyObject *)lo);
     Py_DECREF(lo);
@@ -1022,8 +1146,23 @@ _PyLong_AsByteArray(PyLongObject* v,
 
         /* Store as many bytes as possible. */
         while (accumbits >= 8) {
-            if (j >= n)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[2242]) {
+              if ((j >= n ) && !(0))
+                fprintf(stderr, "triggered bug index 2242\n");
+              else
+                fprintf(stderr, "reached bug index 2242\n");
+            }
+            if ((!FIXREVERTER[2242] && (j >= n ))
+            #else
+            if (0
+            #endif
+            )
                 goto Overflow;
+                #ifdef FRCOV
+                }
+                #endif
             ++j;
             *p = (unsigned char)(accum & 0xff);
             p += pincr;
@@ -1036,8 +1175,23 @@ _PyLong_AsByteArray(PyLongObject* v,
     assert(accumbits < 8);
     assert(carry == 0);  /* else do_twos_comp and *every* digit was 0 */
     if (accumbits > 0) {
-        if (j >= n)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2243]) {
+          if ((j >= n ) && !(0))
+            fprintf(stderr, "triggered bug index 2243\n");
+          else
+            fprintf(stderr, "reached bug index 2243\n");
+        }
+        if ((!FIXREVERTER[2243] && (j >= n ))
+        #else
+        if (0
+        #endif
+        )
             goto Overflow;
+            #ifdef FRCOV
+            }
+            #endif
         ++j;
         if (do_twos_comp) {
             /* Fill leading bits of the byte with sign bits
@@ -1484,18 +1638,48 @@ PyLong_AsLongLong(PyObject *vv)
     int res;
     int do_decref = 0; /* if PyNumber_Index was called */
 
-    if (vv == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2246]) {
+      if ((vv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2246\n");
+      else
+        fprintf(stderr, "reached bug index 2246\n");
+    }
+    if ((!FIXREVERTER[2246] && (vv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (PyLong_Check(vv)) {
         v = (PyLongObject *)vv;
     }
     else {
         v = (PyLongObject *)_PyNumber_Index(vv);
-        if (v == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2247]) {
+          if ((v == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2247\n");
+          else
+            fprintf(stderr, "reached bug index 2247\n");
+        }
+        if ((!FIXREVERTER[2247] && (v == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
         do_decref = 1;
     }
 
@@ -1588,18 +1772,48 @@ PyLong_AsUnsignedLongLongMask(PyObject *op)
     PyLongObject *lo;
     unsigned long long val;
 
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2249]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2249\n");
+      else
+        fprintf(stderr, "reached bug index 2249\n");
+    }
+    if ((!FIXREVERTER[2249] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return (unsigned long long)-1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (PyLong_Check(op)) {
         return _PyLong_AsUnsignedLongLongMask(op);
     }
 
     lo = (PyLongObject *)_PyNumber_Index(op);
-    if (lo == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2250]) {
+      if ((lo == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2250\n");
+      else
+        fprintf(stderr, "reached bug index 2250\n");
+    }
+    if ((!FIXREVERTER[2250] && (lo == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return (unsigned long long)-1;
+        #ifdef FRCOV
+        }
+        #endif
 
     val = _PyLong_AsUnsignedLongLongMask((PyObject *)lo);
     Py_DECREF(lo);
@@ -2541,10 +2755,25 @@ long_from_binary_base(const char *start, const char *end, Py_ssize_t digits, int
     }
     n = (digits * bits_per_char + PyLong_SHIFT - 1) / PyLong_SHIFT;
     z = _PyLong_New(n);
-    if (z == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2261]) {
+      if ((z == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2261\n");
+      else
+        fprintf(stderr, "reached bug index 2261\n");
+    }
+    if ((!FIXREVERTER[2261] && (z == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *res = NULL;
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     /* Read string from right, and fill in int from left; i.e.,
      * from least to most significant in both.
      */
@@ -2588,20 +2817,65 @@ static int
 pylong_int_from_string(const char *start, const char *end, PyLongObject **res)
 {
     PyObject *mod = PyImport_ImportModule("_pylong");
-    if (mod == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2262]) {
+      if ((mod == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2262\n");
+      else
+        fprintf(stderr, "reached bug index 2262\n");
+    }
+    if ((!FIXREVERTER[2262] && (mod == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *s = PyUnicode_FromStringAndSize(start, end-start);
-    if (s == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2263]) {
+      if ((s == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2263\n");
+      else
+        fprintf(stderr, "reached bug index 2263\n");
+    }
+    if ((!FIXREVERTER[2263] && (s == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(mod);
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *result = PyObject_CallMethod(mod, "int_from_string", "O", s);
     Py_DECREF(s);
     Py_DECREF(mod);
-    if (result == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2264]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2264\n");
+      else
+        fprintf(stderr, "reached bug index 2264\n");
+    }
+    if ((!FIXREVERTER[2264] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyLong_Check(result)) {
         Py_DECREF(result);
         PyErr_SetString(PyExc_TypeError,
@@ -2757,10 +3031,25 @@ long_from_non_binary_base(const char *start, const char *end, Py_ssize_t digits,
     /* size_z = 1; */
     assert(size_z > 0);
     z = _PyLong_New(size_z);
-    if (z == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2265]) {
+      if ((z == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2265\n");
+      else
+        fprintf(stderr, "reached bug index 2265\n");
+    }
+    if ((!FIXREVERTER[2265] && (z == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *res = NULL;
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyLong_SetSignAndDigitCount(z, 0, 0);
 
     /* `convwidth` consecutive input digits are treated as a single
@@ -2820,11 +3109,26 @@ long_from_non_binary_base(const char *start, const char *end, Py_ssize_t digits,
                 /* Extremely rare.  Get more space. */
                 assert(_PyLong_DigitCount(z) == size_z);
                 tmp = _PyLong_New(size_z + 1);
-                if (tmp == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[2266]) {
+                  if ((tmp == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 2266\n");
+                  else
+                    fprintf(stderr, "reached bug index 2266\n");
+                }
+                if ((!FIXREVERTER[2266] && (tmp == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     Py_DECREF(z);
                     *res = NULL;
                     return 0;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 memcpy(tmp->long_value.ob_digit,
                        z->long_value.ob_digit,
                        sizeof(digit) * size_z);
@@ -3011,10 +3315,25 @@ PyLong_FromString(const char *str, char **pend, int base)
         /* Syntax error. */
         goto onError;
     }
-    if (z == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2267]) {
+      if ((z == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2267\n");
+      else
+        fprintf(stderr, "reached bug index 2267\n");
+    }
+    if ((!FIXREVERTER[2267] && (z == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* Error. exception already set. */
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (error_if_nonzero) {
         /* reset the base to 0, else the exception message
@@ -3046,9 +3365,24 @@ PyLong_FromString(const char *str, char **pend, int base)
     Py_XDECREF(z);
     slen = strlen(orig_str) < 200 ? strlen(orig_str) : 200;
     strobj = PyUnicode_FromStringAndSize(orig_str, slen);
-    if (strobj == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2268]) {
+      if ((strobj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2268\n");
+      else
+        fprintf(stderr, "reached bug index 2268\n");
+    }
+    if ((!FIXREVERTER[2268] && (strobj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyErr_Format(PyExc_ValueError,
                  "invalid literal for int() with base %d: %.200R",
                  base, strobj);
@@ -3383,11 +3717,26 @@ _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e)
     static const int half_even_correction[8] = {0, -1, -2, 1, 0, -1, 2, 1};
 
     a_size = _PyLong_DigitCount(a);
-    if (a_size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2277]) {
+      if ((a_size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2277\n");
+      else
+        fprintf(stderr, "reached bug index 2277\n");
+    }
+    if ((!FIXREVERTER[2277] && (a_size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* Special case for 0: significand 0.0, exponent 0. */
         *e = 0;
         return 0.0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     a_bits = bit_length_digit(a->long_value.ob_digit[a_size-1]);
     /* The following is an overflow-free version of the check
        "if ((a_size - 1) * PyLong_SHIFT + a_bits > PY_SSIZE_T_MAX) ..." */
@@ -3461,8 +3810,23 @@ _PyLong_Frexp(PyLongObject *a, Py_ssize_t *e)
     /* Rescale;  make correction if result is 1.0. */
     dx /= 4.0 * EXP2_DBL_MANT_DIG;
     if (dx == 1.0) {
-        if (a_bits == PY_SSIZE_T_MAX)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2278]) {
+          if ((a_bits == 9223372036854775807 ) && !(0))
+            fprintf(stderr, "triggered bug index 2278\n");
+          else
+            fprintf(stderr, "reached bug index 2278\n");
+        }
+        if ((!FIXREVERTER[2278] && (a_bits == 9223372036854775807 ))
+        #else
+        if (0
+        #endif
+        )
             goto overflow;
+            #ifdef FRCOV
+            }
+            #endif
         dx = 0.5;
         a_bits += 1;
     }
@@ -3487,10 +3851,25 @@ PyLong_AsDouble(PyObject *v)
     Py_ssize_t exponent;
     double x;
 
-    if (v == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2279]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2279\n");
+      else
+        fprintf(stderr, "reached bug index 2279\n");
+    }
+    if ((!FIXREVERTER[2279] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return -1.0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyLong_Check(v)) {
         PyErr_SetString(PyExc_TypeError, "an integer is required");
         return -1.0;
diff --git a/Objects/memoryobject.c b/Objects/memoryobject.c
index 226bd6defde..85e0ec23496 100644
--- a/Objects/memoryobject.c
+++ b/Objects/memoryobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * Memoryview object implementation
  * --------------------------------
@@ -75,8 +79,23 @@ mbuf_alloc(void)
 
     mbuf = (_PyManagedBufferObject *)
         PyObject_GC_New(_PyManagedBufferObject, &_PyManagedBuffer_Type);
-    if (mbuf == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5138]) {
+      if ((mbuf == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5138\n");
+      else
+        fprintf(stderr, "reached bug index 5138\n");
+    }
+    if ((!FIXREVERTER[5138] && (mbuf == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     mbuf->flags = 0;
     mbuf->exports = 0;
     mbuf->master.obj = NULL;
@@ -559,16 +578,46 @@ init_shape_strides(Py_buffer *dest, const Py_buffer *src)
 {
     Py_ssize_t i;
 
-    if (src->ndim == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5145]) {
+      if ((src -> ndim == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5145\n");
+      else
+        fprintf(stderr, "reached bug index 5145\n");
+    }
+    if ((!FIXREVERTER[5145] && (src -> ndim == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         dest->shape = NULL;
         dest->strides = NULL;
         return;
     }
-    if (src->ndim == 1) {
+    #ifdef FRCOV
+    }
+    #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5146]) {
+      if ((src -> ndim == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 5146\n");
+      else
+        fprintf(stderr, "reached bug index 5146\n");
+    }
+    if ((!FIXREVERTER[5146] && (src -> ndim == 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         dest->shape[0] = src->shape ? src->shape[0] : src->len / src->itemsize;
         dest->strides[0] = src->strides ? src->strides[0] : src->itemsize;
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i = 0; i < src->ndim; i++)
         dest->shape[i] = src->shape[i];
@@ -586,10 +635,25 @@ init_suboffsets(Py_buffer *dest, const Py_buffer *src)
 {
     Py_ssize_t i;
 
-    if (src->suboffsets == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5147]) {
+      if ((src -> suboffsets == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5147\n");
+      else
+        fprintf(stderr, "reached bug index 5147\n");
+    }
+    if ((!FIXREVERTER[5147] && (src -> suboffsets == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         dest->suboffsets = NULL;
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (i = 0; i < src->ndim; i++)
         dest->suboffsets[i] = src->suboffsets[i];
 }
@@ -649,8 +713,23 @@ memory_alloc(int ndim)
 
     mv = (PyMemoryViewObject *)
         PyObject_GC_NewVar(PyMemoryViewObject, &PyMemoryView_Type, 3*ndim);
-    if (mv == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5148]) {
+      if ((mv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5148\n");
+      else
+        fprintf(stderr, "reached bug index 5148\n");
+    }
+    if ((!FIXREVERTER[5148] && (mv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     mv->mbuf = NULL;
     mv->hash = -1;
@@ -680,19 +759,64 @@ mbuf_add_view(_PyManagedBufferObject *mbuf, const Py_buffer *src)
     PyMemoryViewObject *mv;
     Py_buffer *dest;
 
-    if (src == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5149]) {
+      if ((src == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5149\n");
+      else
+        fprintf(stderr, "reached bug index 5149\n");
+    }
+    if ((!FIXREVERTER[5149] && (src == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         src = &mbuf->master;
-
-    if (src->ndim > PyBUF_MAX_NDIM) {
+        #ifdef FRCOV
+        }
+        #endif
+
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5150]) {
+      if ((src -> ndim > 64 ) && !(0))
+        fprintf(stderr, "triggered bug index 5150\n");
+      else
+        fprintf(stderr, "reached bug index 5150\n");
+    }
+    if ((!FIXREVERTER[5150] && (src -> ndim > 64 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_ValueError,
             "memoryview: number of dimensions must not exceed "
             Py_STRINGIFY(PyBUF_MAX_NDIM));
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     mv = memory_alloc(src->ndim);
-    if (mv == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5151]) {
+      if ((mv == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5151\n");
+      else
+        fprintf(stderr, "reached bug index 5151\n");
+    }
+    if ((!FIXREVERTER[5151] && (mv == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     dest = &mv->view;
     init_shared_values(dest, src);
@@ -774,15 +898,45 @@ PyMemoryView_FromBuffer(const Py_buffer *info)
     _PyManagedBufferObject *mbuf;
     PyObject *mv;
 
-    if (info->buf == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5155]) {
+      if ((info -> buf == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5155\n");
+      else
+        fprintf(stderr, "reached bug index 5155\n");
+    }
+    if ((!FIXREVERTER[5155] && (info -> buf == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_ValueError,
             "PyMemoryView_FromBuffer(): info->buf must not be NULL");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     mbuf = mbuf_alloc();
-    if (mbuf == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5156]) {
+      if ((mbuf == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5156\n");
+      else
+        fprintf(stderr, "reached bug index 5156\n");
+    }
+    if ((!FIXREVERTER[5156] && (mbuf == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* info->obj is either NULL or a borrowed reference. This reference
        should not be decremented in PyBuffer_Release(). */
diff --git a/Objects/methodobject.c b/Objects/methodobject.c
index d6773a26410..ec0ad1e909b 100644
--- a/Objects/methodobject.c
+++ b/Objects/methodobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Method object implementation */
 
@@ -86,9 +90,24 @@ PyCMethod_New(PyMethodDef *ml, PyObject *self, PyObject *module, PyTypeObject *c
             return NULL;
         }
         PyCMethodObject *om = PyObject_GC_New(PyCMethodObject, &PyCMethod_Type);
-        if (om == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3384]) {
+          if ((om == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3384\n");
+          else
+            fprintf(stderr, "reached bug index 3384\n");
+        }
+        if ((!FIXREVERTER[3384] && (om == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         om->mm_class = (PyTypeObject*)Py_NewRef(cls);
         op = (PyCFunctionObject *)om;
     } else {
@@ -99,9 +118,24 @@ PyCMethod_New(PyMethodDef *ml, PyObject *self, PyObject *module, PyTypeObject *c
             return NULL;
         }
         op = PyObject_GC_New(PyCFunctionObject, &PyCFunction_Type);
-        if (op == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3385]) {
+          if ((op == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3385\n");
+          else
+            fprintf(stderr, "reached bug index 3385\n");
+        }
+        if ((!FIXREVERTER[3385] && (op == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     op->m_weakreflist = NULL;
diff --git a/Objects/moduleobject.c b/Objects/moduleobject.c
index 73ad9711b6b..20f9d157a98 100644
--- a/Objects/moduleobject.c
+++ b/Objects/moduleobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Module object implementation */
 
@@ -793,9 +797,24 @@ module_repr(PyModuleObject *m)
 int
 _PyModuleSpec_IsInitializing(PyObject *spec)
 {
-    if (spec == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5566]) {
+      if ((spec == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5566\n");
+      else
+        fprintf(stderr, "reached bug index 5566\n");
+    }
+    if ((!FIXREVERTER[5566] && (spec == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *value;
     int rc = PyObject_GetOptionalAttr(spec, &_Py_ID(_initializing), &value);
     if (rc > 0) {
@@ -811,9 +830,24 @@ _PyModuleSpec_IsInitializing(PyObject *spec)
 int
 _PyModuleSpec_IsUninitializedSubmodule(PyObject *spec, PyObject *name)
 {
-    if (spec == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5567]) {
+      if ((spec == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5567\n");
+      else
+        fprintf(stderr, "reached bug index 5567\n");
+    }
+    if ((!FIXREVERTER[5567] && (spec == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
          return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *value;
     int rc = PyObject_GetOptionalAttr(spec, &_Py_ID(_uninitialized_submodules), &value);
@@ -865,9 +899,24 @@ _is_module_possibly_shadowing(PyObject *origin)
     // return not sys.flags.safe_path and root == (sys.path[0] or os.getcwd())
     // Returns 0 otherwise (or if we aren't sure)
     // Returns -1 if an error occurred that should be propagated
-    if (origin == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5571]) {
+      if ((origin == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5571\n");
+      else
+        fprintf(stderr, "reached bug index 5571\n");
+    }
+    if ((!FIXREVERTER[5571] && (origin == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // not sys.flags.safe_path
     const PyConfig *config = _Py_GetConfig();
@@ -878,23 +927,68 @@ _is_module_possibly_shadowing(PyObject *origin)
     // root = os.path.dirname(origin.removesuffix(os.sep + "__init__.py"))
     wchar_t root[MAXPATHLEN + 1];
     Py_ssize_t size = PyUnicode_AsWideChar(origin, root, MAXPATHLEN);
-    if (size < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5572]) {
+      if ((size < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5572\n");
+      else
+        fprintf(stderr, "reached bug index 5572\n");
+    }
+    if ((!FIXREVERTER[5572] && (size < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(size <= MAXPATHLEN);
     root[size] = L'\0';
 
     wchar_t *sep = wcsrchr(root, SEP);
-    if (sep == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5573]) {
+      if ((sep == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5573\n");
+      else
+        fprintf(stderr, "reached bug index 5573\n");
+    }
+    if ((!FIXREVERTER[5573] && (sep == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     // If it's a package then we need to look one directory further up
     if (wcscmp(sep + 1, L"__init__.py") == 0) {
         *sep = L'\0';
         sep = wcsrchr(root, SEP);
-        if (sep == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5574]) {
+          if ((sep == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5574\n");
+          else
+            fprintf(stderr, "reached bug index 5574\n");
+        }
+        if ((!FIXREVERTER[5574] && (sep == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return 0;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     *sep = L'\0';
 
@@ -972,13 +1066,28 @@ _Py_module_getattro_impl(PyModuleObject *m, PyObject *name, int suppress)
         Py_DECREF(mod_name);
         return NULL;
     }
-    if (spec == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5576]) {
+      if ((spec == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5576\n");
+      else
+        fprintf(stderr, "reached bug index 5576\n");
+    }
+    if ((!FIXREVERTER[5576] && (spec == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Format(PyExc_AttributeError,
                      "module '%U' has no attribute '%U'",
                      mod_name, name);
         Py_DECREF(mod_name);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *origin = NULL;
     if (_get_file_origin_from_spec(spec, &origin) < 0) {
diff --git a/Objects/object.c b/Objects/object.c
index c4622359bb1..6e1cc0001fb 100644
--- a/Objects/object.c
+++ b/Objects/object.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Generic object operations; and implementation of None */
 
@@ -455,9 +459,24 @@ PyObject *
 _PyObject_New(PyTypeObject *tp)
 {
     PyObject *op = (PyObject *) PyObject_Malloc(_PyObject_SIZE(tp));
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1782]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1782\n");
+      else
+        fprintf(stderr, "reached bug index 1782\n");
+    }
+    if ((!FIXREVERTER[1782] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyObject_Init(op, tp);
     return op;
 }
@@ -468,9 +487,24 @@ _PyObject_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
     PyVarObject *op;
     const size_t size = _PyObject_VAR_SIZE(tp, nitems);
     op = (PyVarObject *) PyObject_Malloc(size);
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1783]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1783\n");
+      else
+        fprintf(stderr, "reached bug index 1783\n");
+    }
+    if ((!FIXREVERTER[1783] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return (PyVarObject *)PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyObject_InitVar(op, tp, nitems);
     return op;
 }
@@ -659,8 +693,23 @@ PyObject_Repr(PyObject *v)
         return NULL;
     }
 #endif
-    if (v == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1785]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1785\n");
+      else
+        fprintf(stderr, "reached bug index 1785\n");
+    }
+    if ((!FIXREVERTER[1785] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return PyUnicode_FromString("<NULL>");
+        #ifdef FRCOV
+        }
+        #endif
     if (Py_TYPE(v)->tp_repr == NULL)
         return PyUnicode_FromFormat("<%s object at %p>",
                                     Py_TYPE(v)->tp_name, v);
@@ -682,9 +731,24 @@ PyObject_Repr(PyObject *v)
     res = (*Py_TYPE(v)->tp_repr)(v);
     _Py_LeaveRecursiveCallTstate(tstate);
 
-    if (res == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1786]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1786\n");
+      else
+        fprintf(stderr, "reached bug index 1786\n");
+    }
+    if ((!FIXREVERTER[1786] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyUnicode_Check(res)) {
         _PyErr_Format(tstate, PyExc_TypeError,
                       "__repr__ returned non-string (type %.200s)",
@@ -707,8 +771,23 @@ PyObject_Str(PyObject *v)
         return NULL;
     }
 #endif
-    if (v == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1787]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1787\n");
+      else
+        fprintf(stderr, "reached bug index 1787\n");
+    }
+    if ((!FIXREVERTER[1787] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return PyUnicode_FromString("<NULL>");
+        #ifdef FRCOV
+        }
+        #endif
     if (PyUnicode_CheckExact(v)) {
         return Py_NewRef(v);
     }
@@ -731,9 +810,24 @@ PyObject_Str(PyObject *v)
     res = (*Py_TYPE(v)->tp_str)(v);
     _Py_LeaveRecursiveCallTstate(tstate);
 
-    if (res == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1788]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1788\n");
+      else
+        fprintf(stderr, "reached bug index 1788\n");
+    }
+    if ((!FIXREVERTER[1788] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyUnicode_Check(res)) {
         _PyErr_Format(tstate, PyExc_TypeError,
                       "__str__ returned non-string (type %.200s)",
@@ -751,8 +845,23 @@ PyObject_ASCII(PyObject *v)
     PyObject *repr, *ascii, *res;
 
     repr = PyObject_Repr(v);
-    if (repr == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1789]) {
+      if ((repr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1789\n");
+      else
+        fprintf(stderr, "reached bug index 1789\n");
+    }
+    if ((!FIXREVERTER[1789] && (repr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (PyUnicode_IS_ASCII(repr))
         return repr;
@@ -760,8 +869,23 @@ PyObject_ASCII(PyObject *v)
     /* repr is guaranteed to be a PyUnicode object by PyObject_Repr */
     ascii = _PyUnicode_AsASCIIString(repr, "backslashreplace");
     Py_DECREF(repr);
-    if (ascii == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1790]) {
+      if ((ascii == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1790\n");
+      else
+        fprintf(stderr, "reached bug index 1790\n");
+    }
+    if ((!FIXREVERTER[1790] && (ascii == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     res = PyUnicode_DecodeASCII(
         PyBytes_AS_STRING(ascii),
@@ -964,12 +1088,27 @@ PyObject_RichCompare(PyObject *v, PyObject *w, int op)
     PyThreadState *tstate = _PyThreadState_GET();
 
     assert(Py_LT <= op && op <= Py_GE);
-    if (v == NULL || w == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1798]) {
+      if ((v == (void *) 0 || w == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1798\n");
+      else
+        fprintf(stderr, "reached bug index 1798\n");
+    }
+    if ((!FIXREVERTER[1798] && (v == (void *) 0 || w == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (!_PyErr_Occurred(tstate)) {
             PyErr_BadInternalCall();
         }
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_Py_EnterRecursiveCallTstate(tstate, " in comparison")) {
         return NULL;
     }
@@ -991,13 +1130,43 @@ PyObject_RichCompareBool(PyObject *v, PyObject *w, int op)
     if (v == w) {
         if (op == Py_EQ)
             return 1;
-        else if (op == Py_NE)
+        else 
+        #ifdef FRCOV
+        {if (FIXREVERTER[1799]) {
+          if ((op == 3 ) && !(0))
+            fprintf(stderr, "triggered bug index 1799\n");
+          else
+            fprintf(stderr, "reached bug index 1799\n");
+        }
+        if ((!FIXREVERTER[1799] && (op == 3 ))
+        #else
+        if (0
+        #endif
+        )
             return 0;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
     res = PyObject_RichCompare(v, w, op);
-    if (res == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1800]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1800\n");
+      else
+        fprintf(stderr, "reached bug index 1800\n");
+    }
+    if ((!FIXREVERTER[1800] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     if (PyBool_Check(res))
         ok = (res == Py_True);
     else
@@ -1043,8 +1212,23 @@ PyObject_GetAttrString(PyObject *v, const char *name)
     if (Py_TYPE(v)->tp_getattr != NULL)
         return (*Py_TYPE(v)->tp_getattr)(v, (char*)name);
     w = PyUnicode_FromString(name);
-    if (w == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1801]) {
+      if ((w == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1801\n");
+      else
+        fprintf(stderr, "reached bug index 1801\n");
+    }
+    if ((!FIXREVERTER[1801] && (w == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     res = PyObject_GetAttr(v, w);
     Py_DECREF(w);
     return res;
@@ -1168,9 +1352,24 @@ PyObject_GetAttr(PyObject *v, PyObject *name)
     }
     else if (tp->tp_getattr != NULL) {
         const char *name_str = PyUnicode_AsUTF8(name);
-        if (name_str == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1805]) {
+          if ((name_str == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 1805\n");
+          else
+            fprintf(stderr, "reached bug index 1805\n");
+        }
+        if ((!FIXREVERTER[1805] && (name_str == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         result = (*tp->tp_getattr)(v, (char *)name_str);
     }
     else {
@@ -1232,10 +1431,25 @@ PyObject_GetOptionalAttr(PyObject *v, PyObject *name, PyObject **result)
     }
     else if (tp->tp_getattr != NULL) {
         const char *name_str = PyUnicode_AsUTF8(name);
-        if (name_str == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1806]) {
+          if ((name_str == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 1806\n");
+          else
+            fprintf(stderr, "reached bug index 1806\n");
+        }
+        if ((!FIXREVERTER[1806] && (name_str == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             *result = NULL;
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         *result = (*tp->tp_getattr)(v, (char *)name_str);
     }
     else {
@@ -1324,10 +1538,25 @@ PyObject_SetAttr(PyObject *v, PyObject *name, PyObject *value)
     }
     if (tp->tp_setattr != NULL) {
         const char *name_str = PyUnicode_AsUTF8(name);
-        if (name_str == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1809]) {
+          if ((name_str == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 1809\n");
+          else
+            fprintf(stderr, "reached bug index 1809\n");
+        }
+        if ((!FIXREVERTER[1809] && (name_str == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(name);
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         err = (*tp->tp_setattr)(v, (char *)name_str, value);
         Py_DECREF(name);
         return err;
@@ -1364,9 +1593,24 @@ _PyObject_ComputedDictPointer(PyObject *obj)
     assert((tp->tp_flags & Py_TPFLAGS_MANAGED_DICT) == 0);
 
     Py_ssize_t dictoffset = tp->tp_dictoffset;
-    if (dictoffset == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1810]) {
+      if ((dictoffset == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1810\n");
+      else
+        fprintf(stderr, "reached bug index 1810\n");
+    }
+    if ((!FIXREVERTER[1810] && (dictoffset == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (dictoffset < 0) {
         assert(dictoffset != -1);
@@ -1586,10 +1830,25 @@ _PyObject_GenericGetAttrWithDict(PyObject *obj, PyObject *name,
             }
             else {
                 dict = (PyObject *)_PyObject_MaterializeManagedDict(obj);
-                if (dict == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[1812]) {
+                  if ((dict == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 1812\n");
+                  else
+                    fprintf(stderr, "reached bug index 1812\n");
+                }
+                if ((!FIXREVERTER[1812] && (dict == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     res = NULL;
                     goto done;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
         }
         else if ((tp->tp_flags & Py_TPFLAGS_MANAGED_DICT)) {
@@ -1835,8 +2094,23 @@ PyObject_Not(PyObject *v)
 int
 PyCallable_Check(PyObject *x)
 {
-    if (x == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1816]) {
+      if ((x == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1816\n");
+      else
+        fprintf(stderr, "reached bug index 1816\n");
+    }
+    if ((!FIXREVERTER[1816] && (x == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
     return Py_TYPE(x)->tp_call != NULL;
 }
 
diff --git a/Objects/obmalloc.c b/Objects/obmalloc.c
index d033e2bad18..7923f28c4f6 100644
--- a/Objects/obmalloc.c
+++ b/Objects/obmalloc.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Python's malloc wrappers (see pymem.h) */
 
 #include "Python.h"
@@ -1435,9 +1439,24 @@ _PyInterpreterState_GetAllocatedBlocks(PyInterpreterState *interp)
 #endif
     OMState *state = interp->obmalloc;
 
-    if (state == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3438]) {
+      if ((state == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3438\n");
+      else
+        fprintf(stderr, "reached bug index 3438\n");
+    }
+    if ((!FIXREVERTER[3438] && (state == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Py_ssize_t n = raw_allocated_blocks;
     /* add up allocated blocks for used pools */
@@ -3180,14 +3199,44 @@ free_obmalloc_arenas(PyInterpreterState *interp)
     // by arena_map_mark_used() but not freed when arenas are freed.
     for (int i1 = 0; i1 < MAP_TOP_LENGTH; i1++) {
          arena_map_mid_t *mid = arena_map_root.ptrs[i1];
-         if (mid == NULL) {
+         
+         #ifdef FRCOV
+         {if (FIXREVERTER[3456]) {
+           if ((mid == (void *) 0 ) && !(0))
+             fprintf(stderr, "triggered bug index 3456\n");
+           else
+             fprintf(stderr, "reached bug index 3456\n");
+         }
+         if ((!FIXREVERTER[3456] && (mid == (void *) 0 ))
+         #else
+         if (0
+         #endif
+         ) {
              continue;
          }
+         #ifdef FRCOV
+         }
+         #endif
          for (int i2 = 0; i2 < MAP_MID_LENGTH; i2++) {
             arena_map_bot_t *bot = arena_map_root.ptrs[i1]->ptrs[i2];
-            if (bot == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3457]) {
+              if ((bot == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3457\n");
+              else
+                fprintf(stderr, "reached bug index 3457\n");
+            }
+            if ((!FIXREVERTER[3457] && (bot == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 continue;
             }
+            #ifdef FRCOV
+            }
+            #endif
             PyMem_RawFree(bot);
          }
          PyMem_RawFree(mid);
@@ -3358,10 +3407,25 @@ pymalloc_print_stats(FILE *out)
         size_t b = numblocks[i];
         size_t f = numfreeblocks[i];
         uint size = INDEX2SIZE(i);
-        if (p == 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3458]) {
+          if ((p == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3458\n");
+          else
+            fprintf(stderr, "reached bug index 3458\n");
+        }
+        if ((!FIXREVERTER[3458] && (p == 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             assert(b == 0 && f == 0);
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         fprintf(out, "%5u %6u %11zu %15zu %13zu\n",
                 i, size, p, b, f);
         allocated_bytes += b * size;
diff --git a/Objects/setobject.c b/Objects/setobject.c
index 68986bb6a6b..6928a999938 100644
--- a/Objects/setobject.c
+++ b/Objects/setobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* set object implementation
 
@@ -182,8 +186,23 @@ set_add_entry(PySetObject *so, PyObject *key, Py_hash_t hash)
     }
 
   found_unused_or_dummy:
-    if (freeslot == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2555]) {
+      if ((freeslot == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2555\n");
+      else
+        fprintf(stderr, "reached bug index 2555\n");
+    }
+    if ((!FIXREVERTER[2555] && (freeslot == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto found_unused;
+        #ifdef FRCOV
+        }
+        #endif
     so->used++;
     freeslot->key = key;
     freeslot->hash = hash;
@@ -225,13 +244,43 @@ set_insert_clean(setentry *table, size_t mask, PyObject *key, Py_hash_t hash)
 
     while (1) {
         entry = &table[i];
-        if (entry->key == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2556]) {
+          if ((entry -> key == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2556\n");
+          else
+            fprintf(stderr, "reached bug index 2556\n");
+        }
+        if ((!FIXREVERTER[2556] && (entry -> key == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto found_null;
+            #ifdef FRCOV
+            }
+            #endif
         if (i + LINEAR_PROBES <= mask) {
             for (j = 0; j < LINEAR_PROBES; j++) {
                 entry++;
-                if (entry->key == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[2557]) {
+                  if ((entry -> key == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 2557\n");
+                  else
+                    fprintf(stderr, "reached bug index 2557\n");
+                }
+                if ((!FIXREVERTER[2557] && (entry -> key == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto found_null;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
         }
         perturb >>= PERTURB_SHIFT;
@@ -277,10 +326,25 @@ set_table_resize(PySetObject *so, Py_ssize_t minused)
         /* A large table is shrinking, or we can't get any smaller. */
         newtable = so->smalltable;
         if (newtable == oldtable) {
-            if (so->fill == so->used) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[2558]) {
+              if ((so -> fill == so -> used ) && !(0))
+                fprintf(stderr, "triggered bug index 2558\n");
+              else
+                fprintf(stderr, "reached bug index 2558\n");
+            }
+            if ((!FIXREVERTER[2558] && (so -> fill == so -> used ))
+            #else
+            if (0
+            #endif
+            ) {
                 /* No dummies, so no point doing anything. */
                 return 0;
             }
+            #ifdef FRCOV
+            }
+            #endif
             /* We're not going to resize it, but rebuild the
                table anyway to purge old dummy entries.
                Subtle:  This is *necessary* if fill==size,
@@ -294,10 +358,25 @@ set_table_resize(PySetObject *so, Py_ssize_t minused)
     }
     else {
         newtable = PyMem_NEW(setentry, newsize);
-        if (newtable == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2559]) {
+          if ((newtable == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2559\n");
+          else
+            fprintf(stderr, "reached bug index 2559\n");
+        }
+        if ((!FIXREVERTER[2559] && (newtable == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     /* Make the set empty, using the new table. */
@@ -350,10 +429,40 @@ set_discard_entry(PySetObject *so, PyObject *key, Py_hash_t hash)
     PyObject *old_key;
 
     entry = set_lookkey(so, key, hash);
-    if (entry == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2560]) {
+      if ((entry == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2560\n");
+      else
+        fprintf(stderr, "reached bug index 2560\n");
+    }
+    if ((!FIXREVERTER[2560] && (entry == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
-    if (entry->key == NULL)
+        #ifdef FRCOV
+        }
+        #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2561]) {
+      if ((entry -> key == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2561\n");
+      else
+        fprintf(stderr, "reached bug index 2561\n");
+    }
+    if ((!FIXREVERTER[2561] && (entry -> key == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return DISCARD_NOTFOUND;
+        #ifdef FRCOV
+        }
+        #endif
     old_key = entry->key;
     entry->key = dummy;
     entry->hash = -1;
@@ -494,8 +603,23 @@ set_next(PySetObject *so, Py_ssize_t *pos_ptr, setentry **entry_ptr)
         entry++;
     }
     *pos_ptr = i+1;
-    if (i > mask)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2562]) {
+      if ((i > mask ) && !(0))
+        fprintf(stderr, "triggered bug index 2562\n");
+      else
+        fprintf(stderr, "reached bug index 2562\n");
+    }
+    if ((!FIXREVERTER[2562] && (i > mask ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
     assert(entry != NULL);
     *entry_ptr = entry;
     return 1;
@@ -678,14 +802,44 @@ set_pop_impl(PySetObject *so)
     setentry *limit = so->table + so->mask;
     PyObject *key;
 
-    if (so->used == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2568]) {
+      if ((so -> used == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2568\n");
+      else
+        fprintf(stderr, "reached bug index 2568\n");
+    }
+    if ((!FIXREVERTER[2568] && (so -> used == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_KeyError, "pop from an empty set");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     while (entry->key == NULL || entry->key==dummy) {
         entry++;
-        if (entry > limit)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2569]) {
+          if ((entry > limit ) && !(0))
+            fprintf(stderr, "triggered bug index 2569\n");
+          else
+            fprintf(stderr, "reached bug index 2569\n");
+        }
+        if ((!FIXREVERTER[2569] && (entry > limit ))
+        #else
+        if (0
+        #endif
+        )
             entry = so->table;
+            #ifdef FRCOV
+            }
+            #endif
     }
     key = entry->key;
     entry->key = dummy;
@@ -959,9 +1113,24 @@ set_update_iterable_lock_held(PySetObject *so, PyObject *other)
     _Py_CRITICAL_SECTION_ASSERT_OBJECT_LOCKED(so);
 
     PyObject *it = PyObject_GetIter(other);
-    if (it == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2575]) {
+      if ((it == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2575\n");
+      else
+        fprintf(stderr, "reached bug index 2575\n");
+    }
+    if ((!FIXREVERTER[2575] && (it == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *key;
     while ((key = PyIter_Next(it)) != NULL) {
@@ -1077,8 +1246,23 @@ make_new_set(PyTypeObject *type, PyObject *iterable)
     PySetObject *so;
 
     so = (PySetObject *)type->tp_alloc(type, 0);
-    if (so == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[2576]) {
+      if ((so == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 2576\n");
+      else
+        fprintf(stderr, "reached bug index 2576\n");
+    }
+    if ((!FIXREVERTER[2576] && (so == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     so->fill = 0;
     so->used = 0;
diff --git a/Objects/structseq.c b/Objects/structseq.c
index d8289f2638d..a8cc48d5cb7 100644
--- a/Objects/structseq.c
+++ b/Objects/structseq.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Implementation helper: a struct that looks like a tuple.
    See timemodule and posixmodule for example uses.
 
@@ -53,17 +57,62 @@ PyStructSequence_New(PyTypeObject *type)
 {
     PyStructSequence *obj;
     Py_ssize_t size = REAL_SIZE_TP(type), i;
-    if (size < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[671]) {
+      if ((size < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 671\n");
+      else
+        fprintf(stderr, "reached bug index 671\n");
+    }
+    if ((!FIXREVERTER[671] && (size < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_ssize_t vsize = VISIBLE_SIZE_TP(type);
-    if (vsize < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[672]) {
+      if ((vsize < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 672\n");
+      else
+        fprintf(stderr, "reached bug index 672\n");
+    }
+    if ((!FIXREVERTER[672] && (vsize < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     obj = PyObject_GC_NewVar(PyStructSequence, type, size);
-    if (obj == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[673]) {
+      if ((obj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 673\n");
+      else
+        fprintf(stderr, "reached bug index 673\n");
+    }
+    if ((!FIXREVERTER[673] && (obj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     /* Hack the size of the variable object, so invisible fields don't appear
      to Python code. */
     Py_SET_SIZE(obj, vsize);
diff --git a/Objects/tupleobject.c b/Objects/tupleobject.c
index 5ae1ee9a89a..c7a59f65740 100644
--- a/Objects/tupleobject.c
+++ b/Objects/tupleobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Tuple object implementation */
 
@@ -34,10 +38,25 @@ static inline int maybe_freelist_push(PyTupleObject *);
 static PyTupleObject *
 tuple_alloc(Py_ssize_t size)
 {
-    if (size < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1461]) {
+      if ((size < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1461\n");
+      else
+        fprintf(stderr, "reached bug index 1461\n");
+    }
+    if ((!FIXREVERTER[1461] && (size < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 #ifdef Py_DEBUG
     assert(size != 0);    // The empty tuple is statically allocated.
 #endif
@@ -50,8 +69,23 @@ tuple_alloc(Py_ssize_t size)
             return (PyTupleObject *)PyErr_NoMemory();
         }
         op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size);
-        if (op == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1462]) {
+          if ((op == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 1462\n");
+          else
+            fprintf(stderr, "reached bug index 1462\n");
+        }
+        if ((!FIXREVERTER[1462] && (op == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
     }
     return op;
 }
@@ -70,13 +104,43 @@ PyObject *
 PyTuple_New(Py_ssize_t size)
 {
     PyTupleObject *op;
-    if (size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1463]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1463\n");
+      else
+        fprintf(stderr, "reached bug index 1463\n");
+    }
+    if ((!FIXREVERTER[1463] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return tuple_get_empty();
     }
+    #ifdef FRCOV
+    }
+    #endif
     op = tuple_alloc(size);
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1464]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1464\n");
+      else
+        fprintf(stderr, "reached bug index 1464\n");
+    }
+    if ((!FIXREVERTER[1464] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (Py_ssize_t i = 0; i < size; i++) {
         op->ob_item[i] = NULL;
     }
@@ -159,16 +223,46 @@ PyTuple_Pack(Py_ssize_t n, ...)
     PyObject **items;
     va_list vargs;
 
-    if (n == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1465]) {
+      if ((n == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1465\n");
+      else
+        fprintf(stderr, "reached bug index 1465\n");
+    }
+    if ((!FIXREVERTER[1465] && (n == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return tuple_get_empty();
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     va_start(vargs, n);
     PyTupleObject *result = tuple_alloc(n);
-    if (result == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1466]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1466\n");
+      else
+        fprintf(stderr, "reached bug index 1466\n");
+    }
+    if ((!FIXREVERTER[1466] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         va_end(vargs);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     items = result->ob_item;
     for (i = 0; i < n; i++) {
         o = va_arg(vargs, PyObject *);
@@ -373,14 +467,44 @@ tupleitem(PyTupleObject *a, Py_ssize_t i)
 PyObject *
 _PyTuple_FromArray(PyObject *const *src, Py_ssize_t n)
 {
-    if (n == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1470]) {
+      if ((n == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1470\n");
+      else
+        fprintf(stderr, "reached bug index 1470\n");
+    }
+    if ((!FIXREVERTER[1470] && (n == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return tuple_get_empty();
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyTupleObject *tuple = tuple_alloc(n);
-    if (tuple == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1471]) {
+      if ((tuple == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1471\n");
+      else
+        fprintf(stderr, "reached bug index 1471\n");
+    }
+    if ((!FIXREVERTER[1471] && (tuple == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject **dst = tuple->ob_item;
     for (Py_ssize_t i = 0; i < n; i++) {
         PyObject *item = src[i];
@@ -1128,9 +1252,24 @@ maybe_freelist_pop(Py_ssize_t size)
 {
 #ifdef WITH_FREELISTS
     struct _Py_object_freelists *freelists = _Py_object_freelists_GET();
-    if (size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1494]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1494\n");
+      else
+        fprintf(stderr, "reached bug index 1494\n");
+    }
+    if ((!FIXREVERTER[1494] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(size > 0);
     if (size < PyTuple_MAXSAVESIZE) {
         Py_ssize_t index = size - 1;
diff --git a/Objects/typeobject.c b/Objects/typeobject.c
index d374a8e6393..5f703e3cc50 100644
--- a/Objects/typeobject.c
+++ b/Objects/typeobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Type object implementation */
 
 #include "Python.h"
@@ -109,9 +113,24 @@ static inline PyTypeObject *
 type_from_ref(PyObject *ref)
 {
     PyObject *obj = _PyWeakref_GET_REF(ref);
-    if (obj == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5832]) {
+      if ((obj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5832\n");
+      else
+        fprintf(stderr, "reached bug index 5832\n");
+    }
+    if ((!FIXREVERTER[5832] && (obj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return _PyType_CAST(obj);
 }
 
@@ -163,9 +182,24 @@ static_ext_type_lookup(PyInterpreterState *interp, size_t index,
     *p_interp_count = interp_count;
 
     PyTypeObject *type = interp->types.for_extensions.initialized[index].type;
-    if (type == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5833]) {
+      if ((type == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5833\n");
+      else
+        fprintf(stderr, "reached bug index 5833\n");
+    }
+    if ((!FIXREVERTER[5833] && (type == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(!interp->types.for_extensions.initialized[index].isbuiltin);
     assert(type == _PyRuntime.types.managed_static.types[full_index].type);
     assert(managed_static_type_index_is_set(type));
@@ -182,9 +216,24 @@ managed_static_type_state_get(PyInterpreterState *interp, PyTypeObject *self)
     if (state->type == self) {
         return state;
     }
-    if (index > _Py_MAX_MANAGED_STATIC_EXT_TYPES) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5834]) {
+      if ((index > 10 ) && !(0))
+        fprintf(stderr, "triggered bug index 5834\n");
+      else
+        fprintf(stderr, "reached bug index 5834\n");
+    }
+    if ((!FIXREVERTER[5834] && (index > 10 ))
+    #else
+    if (0
+    #endif
+    ) {
         return state;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return &(interp->types.for_extensions.initialized[index]);
 }
 
@@ -549,9 +598,24 @@ static PyObject *
 init_tp_subclasses(PyTypeObject *self)
 {
     PyObject *subclasses = PyDict_New();
-    if (subclasses == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5835]) {
+      if ((subclasses == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5835\n");
+      else
+        fprintf(stderr, "reached bug index 5835\n");
+    }
+    if ((!FIXREVERTER[5835] && (subclasses == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (self->tp_flags & _Py_TPFLAGS_STATIC_BUILTIN) {
         PyInterpreterState *interp = _PyInterpreterState_GET();
         managed_static_type_state *state = _PyStaticType_GetState(interp, self);
@@ -1013,9 +1077,24 @@ type_modified_unlocked(PyTypeObject *type)
        We don't assign new version tags eagerly, but only as
        needed.
      */
-    if (type->tp_version_tag == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5840]) {
+      if ((type -> tp_version_tag == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5840\n");
+      else
+        fprintf(stderr, "reached bug index 5840\n");
+    }
+    if ((!FIXREVERTER[5840] && (type -> tp_version_tag == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *subclasses = lookup_tp_subclasses(type);
     if (subclasses != NULL) {
@@ -1025,9 +1104,24 @@ type_modified_unlocked(PyTypeObject *type)
         PyObject *ref;
         while (PyDict_Next(subclasses, &i, NULL, &ref)) {
             PyTypeObject *subclass = type_from_ref(ref);
-            if (subclass == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5841]) {
+              if ((subclass == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5841\n");
+              else
+                fprintf(stderr, "reached bug index 5841\n");
+            }
+            if ((!FIXREVERTER[5841] && (subclass == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 continue;
             }
+            #ifdef FRCOV
+            }
+            #endif
             type_modified_unlocked(subclass);
             Py_DECREF(subclass);
         }
@@ -1065,9 +1159,24 @@ void
 PyType_Modified(PyTypeObject *type)
 {
     // Quick check without the lock held
-    if (type->tp_version_tag == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5842]) {
+      if ((type -> tp_version_tag == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5842\n");
+      else
+        fprintf(stderr, "reached bug index 5842\n");
+    }
+    if ((!FIXREVERTER[5842] && (type -> tp_version_tag == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     BEGIN_TYPE_LOCK();
     type_modified_unlocked(type);
@@ -1100,15 +1209,45 @@ type_mro_modified(PyTypeObject *type, PyObject *bases) {
         PyObject *mro_meth, *type_mro_meth;
         mro_meth = lookup_maybe_method(
             (PyObject *)type, &_Py_ID(mro), &unbound);
-        if (mro_meth == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5843]) {
+          if ((mro_meth == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5843\n");
+          else
+            fprintf(stderr, "reached bug index 5843\n");
+        }
+        if ((!FIXREVERTER[5843] && (mro_meth == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto clear;
         }
+        #ifdef FRCOV
+        }
+        #endif
         type_mro_meth = lookup_maybe_method(
             (PyObject *)&PyType_Type, &_Py_ID(mro), &unbound);
-        if (type_mro_meth == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5844]) {
+          if ((type_mro_meth == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5844\n");
+          else
+            fprintf(stderr, "reached bug index 5844\n");
+        }
+        if ((!FIXREVERTER[5844] && (type_mro_meth == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(mro_meth);
             goto clear;
         }
+        #ifdef FRCOV
+        }
+        #endif
         int custom_mro = (mro_meth != type_mro_meth);
         Py_DECREF(mro_meth);
         Py_DECREF(type_mro_meth);
@@ -1191,15 +1330,45 @@ assign_version_tag(PyInterpreterState *interp, PyTypeObject *type)
      * To respect the invariant, this must first be done on all super classes.
      * Return 0 if this cannot be done, 1 if tp_version_tag is set.
     */
-    if (type->tp_version_tag != 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5845]) {
+      if ((type -> tp_version_tag != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5845\n");
+      else
+        fprintf(stderr, "reached bug index 5845\n");
+    }
+    if ((!FIXREVERTER[5845] && (type -> tp_version_tag != 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!_PyType_HasFeature(type, Py_TPFLAGS_READY)) {
         return 0;
     }
-    if (type->tp_versions_used >= MAX_VERSIONS_PER_CLASS) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5846]) {
+      if ((type -> tp_versions_used >= 1000 ) && !(0))
+        fprintf(stderr, "triggered bug index 5846\n");
+      else
+        fprintf(stderr, "reached bug index 5846\n");
+    }
+    if ((!FIXREVERTER[5846] && (type -> tp_versions_used >= 1000 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *bases = lookup_tp_bases(type);
     Py_ssize_t n = PyTuple_GET_SIZE(bases);
@@ -1421,15 +1590,45 @@ _PyType_GetFullyQualifiedName(PyTypeObject *type, char sep)
     }
 
     PyObject *qualname = type_qualname(type, NULL);
-    if (qualname == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5848]) {
+      if ((qualname == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5848\n");
+      else
+        fprintf(stderr, "reached bug index 5848\n");
+    }
+    if ((!FIXREVERTER[5848] && (qualname == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *module = type_module(type);
-    if (module == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5849]) {
+      if ((module == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5849\n");
+      else
+        fprintf(stderr, "reached bug index 5849\n");
+    }
+    if ((!FIXREVERTER[5849] && (module == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(qualname);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *result;
     if (PyUnicode_Check(module)
@@ -2197,9 +2396,24 @@ _PyType_AllocNoTrack(PyTypeObject *type, Py_ssize_t nitems)
         size += _PyInlineValuesSize(type);
     }
     char *alloc = _PyObject_MallocWithType(type, size + presize);
-    if (alloc  == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5873]) {
+      if ((alloc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5873\n");
+      else
+        fprintf(stderr, "reached bug index 5873\n");
+    }
+    if ((!FIXREVERTER[5873] && (alloc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     obj = (PyObject *)(alloc + presize);
     if (presize) {
         ((PyObject **)alloc)[0] = NULL;
@@ -2226,9 +2440,24 @@ PyObject *
 PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)
 {
     PyObject *obj = _PyType_AllocNoTrack(type, nitems);
-    if (obj == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5874]) {
+      if ((obj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5874\n");
+      else
+        fprintf(stderr, "reached bug index 5874\n");
+    }
+    if ((!FIXREVERTER[5874] && (obj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (_PyType_IS_GC(type)) {
         _PyObject_GC_TRACK(obj);
@@ -2703,9 +2932,24 @@ static PyObject *
 lookup_maybe_method(PyObject *self, PyObject *attr, int *unbound)
 {
     PyObject *res = _PyType_LookupRef(Py_TYPE(self), attr);
-    if (res == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5876]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5876\n");
+      else
+        fprintf(stderr, "reached bug index 5876\n");
+    }
+    if ((!FIXREVERTER[5876] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (_PyType_HasFeature(Py_TYPE(res), Py_TPFLAGS_METHOD_DESCRIPTOR)) {
         /* Avoid temporary PyMethodObject */
@@ -2927,11 +3171,26 @@ consistent method resolution order (MRO) for bases");
                 name_str = "?";
             }
         }
-        if (name_str == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5879]) {
+          if ((name_str == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5879\n");
+          else
+            fprintf(stderr, "reached bug index 5879\n");
+        }
+        if ((!FIXREVERTER[5879] && (name_str == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_XDECREF(name);
             Py_DECREF(set);
             return;
         }
+        #ifdef FRCOV
+        }
+        #endif
         off += PyOS_snprintf(buf + off, sizeof(buf) - off, " %s", name_str);
         Py_XDECREF(name);
         if (--n && (size_t)(off+1) < sizeof(buf)) {
@@ -2955,10 +3214,25 @@ pmerge(PyObject *acc, PyObject **to_merge, Py_ssize_t to_merge_size)
        that is not included in acc.
     */
     remain = PyMem_New(int, to_merge_size);
-    if (remain == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5880]) {
+      if ((remain == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5880\n");
+      else
+        fprintf(stderr, "reached bug index 5880\n");
+    }
+    if ((!FIXREVERTER[5880] && (remain == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (i = 0; i < to_merge_size; i++)
         remain[i] = 0;
 
@@ -3044,11 +3318,26 @@ mro_implementation_unlocked(PyTypeObject *type)
         PyObject *base_mro = lookup_tp_mro(base);
         Py_ssize_t k = PyTuple_GET_SIZE(base_mro);
         PyObject *result = PyTuple_New(k + 1);
-        if (result == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5882]) {
+          if ((result == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5882\n");
+          else
+            fprintf(stderr, "reached bug index 5882\n");
+        }
+        if ((!FIXREVERTER[5882] && (result == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
 
         ;
+        #ifdef FRCOV
+        }
+        #endif
         PyTuple_SET_ITEM(result, 0, Py_NewRef(type));
         for (Py_ssize_t i = 0; i < k; i++) {
             PyObject *cls = PyTuple_GET_ITEM(base_mro, i);
@@ -3071,10 +3360,25 @@ mro_implementation_unlocked(PyTypeObject *type)
        to_merge is the declared tuple of bases.
     */
     PyObject **to_merge = PyMem_New(PyObject *, n + 1);
-    if (to_merge == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5883]) {
+      if ((to_merge == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5883\n");
+      else
+        fprintf(stderr, "reached bug index 5883\n");
+    }
+    if ((!FIXREVERTER[5883] && (to_merge == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (Py_ssize_t i = 0; i < n; i++) {
         PyTypeObject *base = _PyType_CAST(PyTuple_GET_ITEM(bases, i));
@@ -3083,10 +3387,25 @@ mro_implementation_unlocked(PyTypeObject *type)
     to_merge[n] = bases;
 
     PyObject *result = PyList_New(1);
-    if (result == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5884]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5884\n");
+      else
+        fprintf(stderr, "reached bug index 5884\n");
+    }
+    if ((!FIXREVERTER[5884] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyMem_Free(to_merge);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyList_SET_ITEM(result, 0, Py_NewRef(type));
     if (pmerge(result, to_merge, n + 1) < 0) {
@@ -3185,22 +3504,67 @@ mro_invoke(PyTypeObject *type)
         int unbound;
         PyObject *mro_meth = lookup_method(
             (PyObject *)type, &_Py_ID(mro), &unbound);
-        if (mro_meth == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5885]) {
+          if ((mro_meth == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5885\n");
+          else
+            fprintf(stderr, "reached bug index 5885\n");
+        }
+        if ((!FIXREVERTER[5885] && (mro_meth == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
         mro_result = call_unbound_noarg(unbound, mro_meth, (PyObject *)type);
         Py_DECREF(mro_meth);
     }
     else {
         mro_result = mro_implementation_unlocked(type);
     }
-    if (mro_result == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5886]) {
+      if ((mro_result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5886\n");
+      else
+        fprintf(stderr, "reached bug index 5886\n");
+    }
+    if ((!FIXREVERTER[5886] && (mro_result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     new_mro = PySequence_Tuple(mro_result);
     Py_DECREF(mro_result);
-    if (new_mro == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5887]) {
+      if ((new_mro == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5887\n");
+      else
+        fprintf(stderr, "reached bug index 5887\n");
+    }
+    if ((!FIXREVERTER[5887] && (new_mro == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (PyTuple_GET_SIZE(new_mro) == 0) {
         Py_DECREF(new_mro);
@@ -3252,9 +3616,24 @@ mro_internal_unlocked(PyTypeObject *type, int initial, PyObject **p_old_mro)
     new_mro = mro_invoke(type);  /* might cause reentrance */
     reent = (lookup_tp_mro(type) != old_mro);
     Py_XDECREF(old_mro);
-    if (new_mro == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5888]) {
+      if ((new_mro == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5888\n");
+      else
+        fprintf(stderr, "reached bug index 5888\n");
+    }
+    if ((!FIXREVERTER[5888] && (new_mro == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (reent) {
         Py_DECREF(new_mro);
@@ -5272,10 +5651,25 @@ find_name_in_mro(PyTypeObject *type, PyObject *name, int *error)
             }
             mro = lookup_tp_mro(type);
         }
-        if (mro == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5939]) {
+          if ((mro == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5939\n");
+          else
+            fprintf(stderr, "reached bug index 5939\n");
+        }
+        if ((!FIXREVERTER[5939] && (mro == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             *error = 1;
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     PyObject *res = NULL;
@@ -5769,9 +6163,24 @@ static void
 clear_static_tp_subclasses(PyTypeObject *type, int isbuiltin)
 {
     PyObject *subclasses = lookup_tp_subclasses(type);
-    if (subclasses == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5943]) {
+      if ((subclasses == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5943\n");
+      else
+        fprintf(stderr, "reached bug index 5943\n");
+    }
+    if ((!FIXREVERTER[5943] && (subclasses == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Normally it would be a problem to finalize the type if its
        tp_subclasses wasn't cleared first.  However, this is only
@@ -5857,9 +6266,24 @@ _PyTypes_FiniExtTypes(PyInterpreterState *interp)
         }
         int64_t count = 0;
         PyTypeObject *type = static_ext_type_lookup(interp, i-1, &count);
-        if (type == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5944]) {
+          if ((type == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5944\n");
+          else
+            fprintf(stderr, "reached bug index 5944\n");
+        }
+        if ((!FIXREVERTER[5944] && (type == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         int final = (count == 1);
         fini_static_type(interp, type, 0, final);
     }
@@ -7461,9 +7885,24 @@ type_add_method(PyTypeObject *type, PyMethodDef *meth)
     }
     else if (meth->ml_flags & METH_STATIC) {
         PyObject *cfunc = PyCFunction_NewEx(meth, (PyObject*)type, NULL);
-        if (cfunc == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5978]) {
+          if ((cfunc == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5978\n");
+          else
+            fprintf(stderr, "reached bug index 5978\n");
+        }
+        if ((!FIXREVERTER[5978] && (cfunc == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         descr = PyStaticMethod_New(cfunc);
         isdescr = 0;  // PyStaticMethod is not PyDescrObject
         Py_DECREF(cfunc);
@@ -7471,9 +7910,24 @@ type_add_method(PyTypeObject *type, PyMethodDef *meth)
     else {
         descr = PyDescr_NewMethod(type, meth);
     }
-    if (descr == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5979]) {
+      if ((descr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5979\n");
+      else
+        fprintf(stderr, "reached bug index 5979\n");
+    }
+    if ((!FIXREVERTER[5979] && (descr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *name;
     if (isdescr) {
@@ -7481,10 +7935,25 @@ type_add_method(PyTypeObject *type, PyMethodDef *meth)
     }
     else {
         name = PyUnicode_FromString(meth->ml_name);
-        if (name == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5980]) {
+          if ((name == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5980\n");
+          else
+            fprintf(stderr, "reached bug index 5980\n");
+        }
+        if ((!FIXREVERTER[5980] && (name == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(descr);
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     int err;
@@ -7511,9 +7980,24 @@ static int
 type_add_methods(PyTypeObject *type)
 {
     PyMethodDef *meth = type->tp_methods;
-    if (meth == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5981]) {
+      if ((meth == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5981\n");
+      else
+        fprintf(stderr, "reached bug index 5981\n");
+    }
+    if ((!FIXREVERTER[5981] && (meth == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (; meth->ml_name != NULL; meth++) {
         if (type_add_method(type, meth) < 0) {
@@ -7528,15 +8012,45 @@ static int
 type_add_members(PyTypeObject *type)
 {
     PyMemberDef *memb = type->tp_members;
-    if (memb == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5982]) {
+      if ((memb == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5982\n");
+      else
+        fprintf(stderr, "reached bug index 5982\n");
+    }
+    if ((!FIXREVERTER[5982] && (memb == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *dict = lookup_tp_dict(type);
     for (; memb->name != NULL; memb++) {
         PyObject *descr = PyDescr_NewMember(type, memb);
-        if (descr == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5983]) {
+          if ((descr == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5983\n");
+          else
+            fprintf(stderr, "reached bug index 5983\n");
+        }
+        if ((!FIXREVERTER[5983] && (descr == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
 
         if (PyDict_SetDefaultRef(dict, PyDescr_NAME(descr), descr, NULL) < 0) {
             Py_DECREF(descr);
@@ -7552,16 +8066,46 @@ static int
 type_add_getset(PyTypeObject *type)
 {
     PyGetSetDef *gsp = type->tp_getset;
-    if (gsp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5984]) {
+      if ((gsp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5984\n");
+      else
+        fprintf(stderr, "reached bug index 5984\n");
+    }
+    if ((!FIXREVERTER[5984] && (gsp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *dict = lookup_tp_dict(type);
     for (; gsp->name != NULL; gsp++) {
         PyObject *descr = PyDescr_NewGetSet(type, gsp);
-        if (descr == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5985]) {
+          if ((descr == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5985\n");
+          else
+            fprintf(stderr, "reached bug index 5985\n");
+        }
+        if ((!FIXREVERTER[5985] && (descr == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (PyDict_SetDefaultRef(dict, PyDescr_NAME(descr), descr, NULL) < 0) {
             Py_DECREF(descr);
@@ -7581,15 +8125,60 @@ inherit_special(PyTypeObject *type, PyTypeObject *base)
         (base->tp_flags & Py_TPFLAGS_HAVE_GC) &&
         (!type->tp_traverse && !type->tp_clear)) {
         type->tp_flags |= Py_TPFLAGS_HAVE_GC;
-        if (type->tp_traverse == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5986]) {
+          if ((type -> tp_traverse == (void *) 0  ) && !(0))
+            fprintf(stderr, "triggered bug index 5986\n");
+          else
+            fprintf(stderr, "reached bug index 5986\n");
+        }
+        if ((!FIXREVERTER[5986] && (type -> tp_traverse == (void *) 0  ))
+        #else
+        if (0
+        #endif
+        )
             type->tp_traverse = base->tp_traverse;
-        if (type->tp_clear == NULL)
+            #ifdef FRCOV
+            }
+            #endif
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5987]) {
+          if ((type -> tp_clear == (void *) 0  ) && !(0))
+            fprintf(stderr, "triggered bug index 5987\n");
+          else
+            fprintf(stderr, "reached bug index 5987\n");
+        }
+        if ((!FIXREVERTER[5987] && (type -> tp_clear == (void *) 0  ))
+        #else
+        if (0
+        #endif
+        )
             type->tp_clear = base->tp_clear;
+            #ifdef FRCOV
+            }
+            #endif
     }
     type->tp_flags |= (base->tp_flags & Py_TPFLAGS_PREHEADER);
 
-    if (type->tp_basicsize == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5988]) {
+      if ((type -> tp_basicsize == 0  ) && !(0))
+        fprintf(stderr, "triggered bug index 5988\n");
+      else
+        fprintf(stderr, "reached bug index 5988\n");
+    }
+    if ((!FIXREVERTER[5988] && (type -> tp_basicsize == 0  ))
+    #else
+    if (0
+    #endif
+    )
         type->tp_basicsize = base->tp_basicsize;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Copy other non-function slots */
 
@@ -7679,10 +8268,40 @@ inherit_slots(PyTypeObject *type, PyTypeObject *base)
     /* This won't inherit indirect slots (from tp_as_number etc.)
        if type doesn't provide the space. */
 
-    if (type->tp_as_number != NULL && base->tp_as_number != NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5990]) {
+      fprintf(stderr, "reached bug index 5990\n");
+    }
+    if ((FIXREVERTER[5990] && (type -> tp_as_number != (void *) 0 )) || (!FIXREVERTER[5990] && (type -> tp_as_number != (void *) 0 && base -> tp_as_number != (void *) 0 ))
+    #else
+    if (type -> tp_as_number != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(base -> tp_as_number != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5990\n");
+      #endif
+    
         basebase = base->tp_base;
-        if (basebase->tp_as_number == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5989]) {
+          if ((basebase -> tp_as_number == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5989\n");
+          else
+            fprintf(stderr, "reached bug index 5989\n");
+        }
+        if ((!FIXREVERTER[5989] && (basebase -> tp_as_number == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             basebase = NULL;
+            #ifdef FRCOV
+            }
+            #endif
         COPYNUM(nb_add);
         COPYNUM(nb_subtract);
         COPYNUM(nb_multiply);
@@ -7719,20 +8338,86 @@ inherit_slots(PyTypeObject *type, PyTypeObject *base)
         COPYNUM(nb_matrix_multiply);
         COPYNUM(nb_inplace_matrix_multiply);
     }
-
-    if (type->tp_as_async != NULL && base->tp_as_async != NULL) {
+    #ifdef FRCOV
+    }
+    #endif
+
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5992]) {
+      fprintf(stderr, "reached bug index 5992\n");
+    }
+    if ((FIXREVERTER[5992] && (type -> tp_as_async != (void *) 0 )) || (!FIXREVERTER[5992] && (type -> tp_as_async != (void *) 0 && base -> tp_as_async != (void *) 0 ))
+    #else
+    if (type -> tp_as_async != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(base -> tp_as_async != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5992\n");
+      #endif
+    
         basebase = base->tp_base;
-        if (basebase->tp_as_async == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5991]) {
+          if ((basebase -> tp_as_async == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5991\n");
+          else
+            fprintf(stderr, "reached bug index 5991\n");
+        }
+        if ((!FIXREVERTER[5991] && (basebase -> tp_as_async == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             basebase = NULL;
+            #ifdef FRCOV
+            }
+            #endif
         COPYASYNC(am_await);
         COPYASYNC(am_aiter);
         COPYASYNC(am_anext);
     }
-
-    if (type->tp_as_sequence != NULL && base->tp_as_sequence != NULL) {
+    #ifdef FRCOV
+    }
+    #endif
+
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5994]) {
+      fprintf(stderr, "reached bug index 5994\n");
+    }
+    if ((FIXREVERTER[5994] && (type -> tp_as_sequence != (void *) 0 )) || (!FIXREVERTER[5994] && (type -> tp_as_sequence != (void *) 0 && base -> tp_as_sequence != (void *) 0 ))
+    #else
+    if (type -> tp_as_sequence != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(base -> tp_as_sequence != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5994\n");
+      #endif
+    
         basebase = base->tp_base;
-        if (basebase->tp_as_sequence == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5993]) {
+          if ((basebase -> tp_as_sequence == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5993\n");
+          else
+            fprintf(stderr, "reached bug index 5993\n");
+        }
+        if ((!FIXREVERTER[5993] && (basebase -> tp_as_sequence == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             basebase = NULL;
+            #ifdef FRCOV
+            }
+            #endif
         COPYSEQ(sq_length);
         COPYSEQ(sq_concat);
         COPYSEQ(sq_repeat);
@@ -7742,23 +8427,92 @@ inherit_slots(PyTypeObject *type, PyTypeObject *base)
         COPYSEQ(sq_inplace_concat);
         COPYSEQ(sq_inplace_repeat);
     }
-
-    if (type->tp_as_mapping != NULL && base->tp_as_mapping != NULL) {
+    #ifdef FRCOV
+    }
+    #endif
+
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5996]) {
+      fprintf(stderr, "reached bug index 5996\n");
+    }
+    if ((FIXREVERTER[5996] && (type -> tp_as_mapping != (void *) 0 )) || (!FIXREVERTER[5996] && (type -> tp_as_mapping != (void *) 0 && base -> tp_as_mapping != (void *) 0 ))
+    #else
+    if (type -> tp_as_mapping != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(base -> tp_as_mapping != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5996\n");
+      #endif
+    
         basebase = base->tp_base;
-        if (basebase->tp_as_mapping == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5995]) {
+          if ((basebase -> tp_as_mapping == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5995\n");
+          else
+            fprintf(stderr, "reached bug index 5995\n");
+        }
+        if ((!FIXREVERTER[5995] && (basebase -> tp_as_mapping == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             basebase = NULL;
+            #ifdef FRCOV
+            }
+            #endif
         COPYMAP(mp_length);
         COPYMAP(mp_subscript);
         COPYMAP(mp_ass_subscript);
     }
-
-    if (type->tp_as_buffer != NULL && base->tp_as_buffer != NULL) {
+    #ifdef FRCOV
+    }
+    #endif
+
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5998]) {
+      fprintf(stderr, "reached bug index 5998\n");
+    }
+    if ((FIXREVERTER[5998] && (type -> tp_as_buffer != (void *) 0 )) || (!FIXREVERTER[5998] && (type -> tp_as_buffer != (void *) 0 && base -> tp_as_buffer != (void *) 0 ))
+    #else
+    if (type -> tp_as_buffer != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(base -> tp_as_buffer != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5998\n");
+      #endif
+    
         basebase = base->tp_base;
-        if (basebase->tp_as_buffer == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5997]) {
+          if ((basebase -> tp_as_buffer == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5997\n");
+          else
+            fprintf(stderr, "reached bug index 5997\n");
+        }
+        if ((!FIXREVERTER[5997] && (basebase -> tp_as_buffer == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             basebase = NULL;
+            #ifdef FRCOV
+            }
+            #endif
         COPYBUF(bf_getbuffer);
         COPYBUF(bf_releasebuffer);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     basebase = base->tp_base;
 
@@ -7873,11 +8627,26 @@ type_ready_pre_checks(PyTypeObject *type)
      * Py_TPFLAGS_SEQUENCE and Py_TPFLAGS_MAPPING are mutually exclusive */
     _PyObject_ASSERT((PyObject *)type, (type->tp_flags & COLLECTION_FLAGS) != COLLECTION_FLAGS);
 
-    if (type->tp_name == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6000]) {
+      if ((type -> tp_name == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6000\n");
+      else
+        fprintf(stderr, "reached bug index 6000\n");
+    }
+    if ((!FIXREVERTER[6000] && (type -> tp_name == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Format(PyExc_SystemError,
                      "Type does not define the tp_name field.");
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return 0;
 }
 
@@ -7949,9 +8718,24 @@ type_ready_set_bases(PyTypeObject *type, int initial)
         else {
             bases = PyTuple_Pack(1, base);
         }
-        if (bases == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6001]) {
+          if ((bases == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6001\n");
+          else
+            fprintf(stderr, "reached bug index 6001\n");
+        }
+        if ((!FIXREVERTER[6001] && (bases == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         set_tp_bases(type, bases, 1);
     }
     return 0;
@@ -7966,9 +8750,24 @@ type_ready_set_dict(PyTypeObject *type)
     }
 
     PyObject *dict = PyDict_New();
-    if (dict == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6002]) {
+      if ((dict == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6002\n");
+      else
+        fprintf(stderr, "reached bug index 6002\n");
+    }
+    if ((!FIXREVERTER[6002] && (dict == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     set_tp_dict(type, dict);
     return 0;
 }
@@ -7992,9 +8791,24 @@ type_dict_set_doc(PyTypeObject *type)
         const char *doc_str;
         doc_str = _PyType_DocWithoutSignature(type->tp_name, type->tp_doc);
         PyObject *doc = PyUnicode_FromString(doc_str);
-        if (doc == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6005]) {
+          if ((doc == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6005\n");
+          else
+            fprintf(stderr, "reached bug index 6005\n");
+        }
+        if ((!FIXREVERTER[6005] && (doc == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (PyDict_SetItem(dict, &_Py_ID(__doc__), doc) < 0) {
             Py_DECREF(doc);
@@ -8288,10 +9102,25 @@ type_ready_managed_dict(PyTypeObject *type)
     PyHeapTypeObject* et = (PyHeapTypeObject*)type;
     if (et->ht_cached_keys == NULL) {
         et->ht_cached_keys = _PyDict_NewKeysForClass();
-        if (et->ht_cached_keys == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6008]) {
+          if ((et -> ht_cached_keys == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6008\n");
+          else
+            fprintf(stderr, "reached bug index 6008\n");
+        }
+        if ((!FIXREVERTER[6008] && (et -> ht_cached_keys == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     if (type->tp_itemsize == 0 && type->tp_basicsize == sizeof(PyObject)) {
         type->tp_flags |= Py_TPFLAGS_INLINE_VALUES;
@@ -8494,14 +9323,44 @@ static int
 add_subclass(PyTypeObject *base, PyTypeObject *type)
 {
     PyObject *key = PyLong_FromVoidPtr((void *) type);
-    if (key == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6009]) {
+      if ((key == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6009\n");
+      else
+        fprintf(stderr, "reached bug index 6009\n");
+    }
+    if ((!FIXREVERTER[6009] && (key == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     PyObject *ref = PyWeakref_NewRef((PyObject *)type, NULL);
-    if (ref == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6010]) {
+      if ((ref == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6010\n");
+      else
+        fprintf(stderr, "reached bug index 6010\n");
+    }
+    if ((!FIXREVERTER[6010] && (ref == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(key);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // Only get tp_subclasses after creating the key and value.
     // PyWeakref_NewRef() can trigger a garbage collection which can execute
@@ -8509,11 +9368,26 @@ add_subclass(PyTypeObject *base, PyTypeObject *type)
     PyObject *subclasses = lookup_tp_subclasses(base);
     if (subclasses == NULL) {
         subclasses = init_tp_subclasses(base);
-        if (subclasses == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6011]) {
+          if ((subclasses == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6011\n");
+          else
+            fprintf(stderr, "reached bug index 6011\n");
+        }
+        if ((!FIXREVERTER[6011] && (subclasses == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(key);
             Py_DECREF(ref);
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     assert(PyDict_CheckExact(subclasses));
 
@@ -8556,9 +9430,24 @@ get_subclasses_key(PyTypeObject *type, PyTypeObject *base)
     if (subclasses != NULL) {
         while (PyDict_Next(subclasses, &i, &key, &ref)) {
             PyTypeObject *subclass = type_from_ref(ref);
-            if (subclass == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[6012]) {
+              if ((subclass == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 6012\n");
+              else
+                fprintf(stderr, "reached bug index 6012\n");
+            }
+            if ((!FIXREVERTER[6012] && (subclass == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 continue;
             }
+            #ifdef FRCOV
+            }
+            #endif
             if (subclass == type) {
                 Py_DECREF(subclass);
                 return Py_NewRef(key);
@@ -8574,9 +9463,24 @@ static void
 remove_subclass(PyTypeObject *base, PyTypeObject *type)
 {
     PyObject *subclasses = lookup_tp_subclasses(base);  // borrowed ref
-    if (subclasses == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6013]) {
+      if ((subclasses == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6013\n");
+      else
+        fprintf(stderr, "reached bug index 6013\n");
+    }
+    if ((!FIXREVERTER[6013] && (subclasses == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(PyDict_CheckExact(subclasses));
 
     PyObject *key = get_subclasses_key(type, base);
@@ -9259,9 +10163,24 @@ add_tp_new_wrapper(PyTypeObject *type)
     }
 
     PyObject *func = PyCFunction_NewEx(tp_new_methoddef, (PyObject *)type, NULL);
-    if (func == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6024]) {
+      if ((func == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6024\n");
+      else
+        fprintf(stderr, "reached bug index 6024\n");
+    }
+    if ((!FIXREVERTER[6024] && (func == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     r = PyDict_SetItem(dict, &_Py_ID(__new__), func);
     Py_DECREF(func);
     return r;
@@ -11069,8 +11988,23 @@ add_operators(PyTypeObject *type)
     void **ptr;
 
     for (p = slotdefs; p->name; p++) {
-        if (p->wrapper == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6068]) {
+          if ((p -> wrapper == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6068\n");
+          else
+            fprintf(stderr, "reached bug index 6068\n");
+        }
+        if ((!FIXREVERTER[6068] && (p -> wrapper == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             continue;
+            #ifdef FRCOV
+            }
+            #endif
         ptr = slotptr(type, p->offset);
         if (!ptr || !*ptr)
             continue;
@@ -11089,8 +12023,23 @@ add_operators(PyTypeObject *type)
         }
         else {
             descr = PyDescr_NewWrapper(type, p, *ptr);
-            if (descr == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[6071]) {
+              if ((descr == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 6071\n");
+              else
+                fprintf(stderr, "reached bug index 6071\n");
+            }
+            if ((!FIXREVERTER[6071] && (descr == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return -1;
+                #ifdef FRCOV
+                }
+                #endif
             if (PyDict_SetItem(dict, p->name_strobj, descr) < 0) {
                 Py_DECREF(descr);
                 return -1;
diff --git a/Objects/unicodeobject.c b/Objects/unicodeobject.c
index 9738442ab96..b177e490bc6 100644
--- a/Objects/unicodeobject.c
+++ b/Objects/unicodeobject.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
 
 Unicode implementation based on original code by Fredrik Lundh,
@@ -580,9 +584,24 @@ unicode_check_encoding_errors(const char *encoding, const char *errors)
         && strcmp(encoding, "ascii") != 0)
     {
         PyObject *handler = _PyCodec_Lookup(encoding);
-        if (handler == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4313]) {
+          if ((handler == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4313\n");
+          else
+            fprintf(stderr, "reached bug index 4313\n");
+        }
+        if ((!FIXREVERTER[4313] && (handler == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         Py_DECREF(handler);
     }
 
@@ -595,9 +614,24 @@ unicode_check_encoding_errors(const char *encoding, const char *errors)
         && strcmp(errors, "surrogatepass") != 0)
     {
         PyObject *handler = PyCodec_LookupError(errors);
-        if (handler == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4314]) {
+          if ((handler == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4314\n");
+          else
+            fprintf(stderr, "reached bug index 4314\n");
+        }
+        if ((!FIXREVERTER[4314] && (handler == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         Py_DECREF(handler);
     }
     return 0;
@@ -793,17 +827,47 @@ backslashreplace(_PyBytesWriter *writer, char *str,
             assert(ch <= MAX_UNICODE);
             incr = 2+8;
         }
-        if (size > PY_SSIZE_T_MAX - incr) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4317]) {
+          if ((size > 9223372036854775807 - incr ) && !(0))
+            fprintf(stderr, "triggered bug index 4317\n");
+          else
+            fprintf(stderr, "reached bug index 4317\n");
+        }
+        if ((!FIXREVERTER[4317] && (size > 9223372036854775807 - incr ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_SetString(PyExc_OverflowError,
                             "encoded result is too long for a Python string");
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         size += incr;
     }
 
     str = _PyBytesWriter_Prepare(writer, str, size);
-    if (str == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4318]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4318\n");
+      else
+        fprintf(stderr, "reached bug index 4318\n");
+    }
+    if ((!FIXREVERTER[4318] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* generate replacement */
     for (i = collstart; i < collend; ++i) {
@@ -867,24 +931,69 @@ xmlcharrefreplace(_PyBytesWriter *writer, char *str,
             assert(ch <= MAX_UNICODE);
             incr = 2+7+1;
         }
-        if (size > PY_SSIZE_T_MAX - incr) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4319]) {
+          if ((size > 9223372036854775807 - incr ) && !(0))
+            fprintf(stderr, "triggered bug index 4319\n");
+          else
+            fprintf(stderr, "reached bug index 4319\n");
+        }
+        if ((!FIXREVERTER[4319] && (size > 9223372036854775807 - incr ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_SetString(PyExc_OverflowError,
                             "encoded result is too long for a Python string");
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         size += incr;
     }
 
     str = _PyBytesWriter_Prepare(writer, str, size);
-    if (str == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4320]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4320\n");
+      else
+        fprintf(stderr, "reached bug index 4320\n");
+    }
+    if ((!FIXREVERTER[4320] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* generate replacement */
     for (i = collstart; i < collend; ++i) {
         size = sprintf(str, "&#%d;", PyUnicode_READ(kind, data, i));
-        if (size < 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4321]) {
+          if ((size < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4321\n");
+          else
+            fprintf(stderr, "reached bug index 4321\n");
+        }
+        if ((!FIXREVERTER[4321] && (size < 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         str += size;
     }
     return str;
@@ -1103,11 +1212,26 @@ resize_compact(PyObject *unicode, Py_ssize_t length)
 #endif
 
     new_unicode = (PyObject *)PyObject_Realloc(unicode, new_size);
-    if (new_unicode == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4322]) {
+      if ((new_unicode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4322\n");
+      else
+        fprintf(stderr, "reached bug index 4322\n");
+    }
+    if ((!FIXREVERTER[4322] && (new_unicode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _Py_NewReferenceNoTotal(unicode);
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     unicode = new_unicode;
     _Py_NewReferenceNoTotal(unicode);
 
@@ -1153,10 +1277,25 @@ resize_inplace(PyObject *unicode, Py_ssize_t length)
     }
 
     data = (PyObject *)PyObject_Realloc(data, new_size);
-    if (data == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4323]) {
+      if ((data == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4323\n");
+      else
+        fprintf(stderr, "reached bug index 4323\n");
+    }
+    if ((!FIXREVERTER[4323] && (data == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyUnicode_DATA_ANY(unicode) = data;
     if (share_utf8) {
         _PyUnicode_UTF8(unicode) = data;
@@ -1184,8 +1323,23 @@ resize_copy(PyObject *unicode, Py_ssize_t length)
     PyObject *copy;
 
     copy = PyUnicode_New(length, PyUnicode_MAX_CHAR_VALUE(unicode));
-    if (copy == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4324]) {
+      if ((copy == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4324\n");
+      else
+        fprintf(stderr, "reached bug index 4324\n");
+    }
+    if ((!FIXREVERTER[4324] && (copy == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     copy_length = Py_MIN(length, PyUnicode_GET_LENGTH(unicode));
     _PyUnicode_FastCopyCharacters(copy, 0, unicode, 0, copy_length);
@@ -1282,9 +1436,24 @@ PyObject *
 PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
 {
     /* Optimization for empty strings */
-    if (size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4325]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4325\n");
+      else
+        fprintf(stderr, "reached bug index 4325\n");
+    }
+    if ((!FIXREVERTER[4325] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return unicode_get_empty();
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *obj;
     PyCompactUnicodeObject *unicode;
@@ -1321,11 +1490,26 @@ PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
     }
 
     /* Ensure we won't overflow the size. */
-    if (size < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4327]) {
+      if ((size < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4327\n");
+      else
+        fprintf(stderr, "reached bug index 4327\n");
+    }
+    if ((!FIXREVERTER[4327] && (size < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_SystemError,
                         "Negative size passed to PyUnicode_New");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (size > ((PY_SSIZE_T_MAX - struct_size) / char_size - 1))
         return PyErr_NoMemory();
 
@@ -1334,9 +1518,24 @@ PyUnicode_New(Py_ssize_t size, Py_UCS4 maxchar)
      * it's data buffer.
      */
     obj = (PyObject *) PyObject_Malloc(struct_size + (size + 1) * char_size);
-    if (obj == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4328]) {
+      if ((obj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4328\n");
+      else
+        fprintf(stderr, "reached bug index 4328\n");
+    }
+    if ((!FIXREVERTER[4328] && (obj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyObject_Init(obj, &PyUnicode_Type);
 
     unicode = (PyCompactUnicodeObject *)obj;
@@ -1553,10 +1752,25 @@ PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start,
         PyErr_SetString(PyExc_IndexError, "string index out of range");
         return -1;
     }
-    if (how_many < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4333]) {
+      if ((how_many < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4333\n");
+      else
+        fprintf(stderr, "reached bug index 4333\n");
+    }
+    if ((!FIXREVERTER[4333] && (how_many < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_SystemError, "how_many cannot be negative");
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     how_many = Py_MIN(PyUnicode_GET_LENGTH(from)-from_start, how_many);
     if (to_start + how_many > PyUnicode_GET_LENGTH(to)) {
         PyErr_Format(PyExc_SystemError,
@@ -1566,8 +1780,23 @@ PyUnicode_CopyCharacters(PyObject *to, Py_ssize_t to_start,
         return -1;
     }
 
-    if (how_many == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4334]) {
+      if ((how_many == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4334\n");
+      else
+        fprintf(stderr, "reached bug index 4334\n");
+    }
+    if ((!FIXREVERTER[4334] && (how_many == 0 ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (unicode_check_modifiable(to))
         return -1;
@@ -1767,27 +1996,87 @@ unicode_resize(PyObject **p_unicode, Py_ssize_t length)
     assert(0 <= length);
 
     old_length = PyUnicode_GET_LENGTH(unicode);
-    if (old_length == length)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4336]) {
+      if ((old_length == length ) && !(0))
+        fprintf(stderr, "triggered bug index 4336\n");
+      else
+        fprintf(stderr, "reached bug index 4336\n");
+    }
+    if ((!FIXREVERTER[4336] && (old_length == length ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
 
-    if (length == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4337]) {
+      if ((length == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4337\n");
+      else
+        fprintf(stderr, "reached bug index 4337\n");
+    }
+    if ((!FIXREVERTER[4337] && (length == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyObject *empty = unicode_get_empty();
         Py_SETREF(*p_unicode, empty);
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!unicode_modifiable(unicode)) {
         PyObject *copy = resize_copy(unicode, length);
-        if (copy == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4338]) {
+          if ((copy == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4338\n");
+          else
+            fprintf(stderr, "reached bug index 4338\n");
+        }
+        if ((!FIXREVERTER[4338] && (copy == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
         Py_SETREF(*p_unicode, copy);
         return 0;
     }
 
     if (PyUnicode_IS_COMPACT(unicode)) {
         PyObject *new_unicode = resize_compact(unicode, length);
-        if (new_unicode == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4339]) {
+          if ((new_unicode == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4339\n");
+          else
+            fprintf(stderr, "reached bug index 4339\n");
+        }
+        if ((!FIXREVERTER[4339] && (new_unicode == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
         *p_unicode = new_unicode;
         return 0;
     }
@@ -1878,13 +2167,43 @@ unicode_char(Py_UCS4 ch)
 
     assert(ch <= MAX_UNICODE);
 
-    if (ch < 256) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4341]) {
+      if ((ch < 256 ) && !(0))
+        fprintf(stderr, "triggered bug index 4341\n");
+      else
+        fprintf(stderr, "reached bug index 4341\n");
+    }
+    if ((!FIXREVERTER[4341] && (ch < 256 ))
+    #else
+    if (0
+    #endif
+    ) {
         return get_latin1_char(ch);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     unicode = PyUnicode_New(1, ch);
-    if (unicode == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4342]) {
+      if ((unicode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4342\n");
+      else
+        fprintf(stderr, "reached bug index 4342\n");
+    }
+    if ((!FIXREVERTER[4342] && (unicode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     assert(PyUnicode_KIND(unicode) != PyUnicode_1BYTE_KIND);
     if (PyUnicode_KIND(unicode) == PyUnicode_2BYTE_KIND) {
@@ -2023,9 +2342,24 @@ PyUnicodeWriter_WriteWideChar(PyUnicodeWriter *pub_writer,
         size = wcslen(str);
     }
 
-    if (size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4343]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4343\n");
+      else
+        fprintf(stderr, "reached bug index 4343\n");
+    }
+    if ((!FIXREVERTER[4343] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 #ifdef HAVE_NON_UNICODE_WCHAR_T_REPRESENTATION
     /* Oracle Solaris uses non-Unicode internal wchar_t form for
@@ -2065,19 +2399,49 @@ PyUnicodeWriter_WriteWideChar(PyUnicodeWriter *pub_writer,
 PyObject *
 PyUnicode_FromStringAndSize(const char *u, Py_ssize_t size)
 {
-    if (size < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4344]) {
+      if ((size < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4344\n");
+      else
+        fprintf(stderr, "reached bug index 4344\n");
+    }
+    if ((!FIXREVERTER[4344] && (size < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_SystemError,
                         "Negative size passed to PyUnicode_FromStringAndSize");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (u != NULL) {
         return PyUnicode_DecodeUTF8Stateful(u, size, NULL, NULL);
     }
-    if (size > 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4345]) {
+      if ((size > 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4345\n");
+      else
+        fprintf(stderr, "reached bug index 4345\n");
+    }
+    if ((!FIXREVERTER[4345] && (size > 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_SystemError,
             "NULL string with positive size with NULL passed to PyUnicode_FromStringAndSize");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return unicode_get_empty();
 }
 
@@ -2085,10 +2449,25 @@ PyObject *
 PyUnicode_FromString(const char *u)
 {
     size_t size = strlen(u);
-    if (size > PY_SSIZE_T_MAX) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4346]) {
+      if ((size > 9223372036854775807 ) && !(0))
+        fprintf(stderr, "triggered bug index 4346\n");
+      else
+        fprintf(stderr, "reached bug index 4346\n");
+    }
+    if ((!FIXREVERTER[4346] && (size > 9223372036854775807 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_OverflowError, "input too long");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return PyUnicode_DecodeUTF8Stateful(u, (Py_ssize_t)size, NULL, NULL);
 }
 
@@ -2181,12 +2560,27 @@ _PyUnicode_FromASCII(const char *buffer, Py_ssize_t size)
 {
     const unsigned char *s = (const unsigned char *)buffer;
     PyObject *unicode;
-    if (size == 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4348]) {
+      if ((size == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 4348\n");
+      else
+        fprintf(stderr, "reached bug index 4348\n");
+    }
+    if ((!FIXREVERTER[4348] && (size == 1 ))
+    #else
+    if (0
+    #endif
+    ) {
 #ifdef Py_DEBUG
         assert((unsigned char)s[0] < 128);
 #endif
         return get_latin1_char(s[0]);
     }
+    #ifdef FRCOV
+    }
+    #endif
     unicode = PyUnicode_New(size, 127);
     if (!unicode)
         return NULL;
@@ -2220,9 +2614,24 @@ _PyUnicode_FromUCS1(const Py_UCS1* u, Py_ssize_t size)
         _Py_RETURN_UNICODE_EMPTY();
     }
     assert(size > 0);
-    if (size == 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4349]) {
+      if ((size == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 4349\n");
+      else
+        fprintf(stderr, "reached bug index 4349\n");
+    }
+    if ((!FIXREVERTER[4349] && (size == 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         return get_latin1_char(u[0]);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     max_char = ucs1lib_find_max_char(u, u + size);
     res = PyUnicode_New(size, max_char);
@@ -2242,8 +2651,23 @@ _PyUnicode_FromUCS2(const Py_UCS2 *u, Py_ssize_t size)
     if (size == 0)
         _Py_RETURN_UNICODE_EMPTY();
     assert(size > 0);
-    if (size == 1)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4350]) {
+      if ((size == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 4350\n");
+      else
+        fprintf(stderr, "reached bug index 4350\n");
+    }
+    if ((!FIXREVERTER[4350] && (size == 1 ))
+    #else
+    if (0
+    #endif
+    )
         return unicode_char(u[0]);
+        #ifdef FRCOV
+        }
+        #endif
 
     max_char = ucs2lib_find_max_char(u, u + size);
     res = PyUnicode_New(size, max_char);
@@ -2268,8 +2692,23 @@ _PyUnicode_FromUCS4(const Py_UCS4 *u, Py_ssize_t size)
     if (size == 0)
         _Py_RETURN_UNICODE_EMPTY();
     assert(size > 0);
-    if (size == 1)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4351]) {
+      if ((size == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 4351\n");
+      else
+        fprintf(stderr, "reached bug index 4351\n");
+    }
+    if ((!FIXREVERTER[4351] && (size == 1 ))
+    #else
+    if (0
+    #endif
+    )
         return unicode_char(u[0]);
+        #ifdef FRCOV
+        }
+        #endif
 
     max_char = ucs4lib_find_max_char(u, u + size);
     res = PyUnicode_New(size, max_char);
@@ -2335,10 +2774,25 @@ PyUnicodeWriter_WriteUCS4(PyUnicodeWriter *pub_writer,
 PyObject*
 PyUnicode_FromKindAndData(int kind, const void *buffer, Py_ssize_t size)
 {
-    if (size < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4354]) {
+      if ((size < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4354\n");
+      else
+        fprintf(stderr, "reached bug index 4354\n");
+    }
+    if ((!FIXREVERTER[4354] && (size < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_ValueError, "size must be positive");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     switch (kind) {
     case PyUnicode_1BYTE_KIND:
         return _PyUnicode_FromUCS1(buffer, size);
@@ -2365,8 +2819,23 @@ _PyUnicode_FindMaxChar(PyObject *unicode, Py_ssize_t start, Py_ssize_t end)
     if (start == 0 && end == PyUnicode_GET_LENGTH(unicode))
         return PyUnicode_MAX_CHAR_VALUE(unicode);
 
-    if (start == end)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4355]) {
+      if ((start == end ) && !(0))
+        fprintf(stderr, "triggered bug index 4355\n");
+      else
+        fprintf(stderr, "reached bug index 4355\n");
+    }
+    if ((!FIXREVERTER[4355] && (start == end ))
+    #else
+    if (0
+    #endif
+    )
         return 127;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (PyUnicode_IS_ASCII(unicode))
         return 127;
@@ -2651,8 +3120,23 @@ unicode_fromformat_write_utf8(_PyUnicodeWriter *writer, const char *str,
 
     PyObject *unicode = PyUnicode_DecodeUTF8Stateful(str, length,
                                                      "replace", pconsumed);
-    if (unicode == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4362]) {
+      if ((unicode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4362\n");
+      else
+        fprintf(stderr, "reached bug index 4362\n");
+    }
+    if ((!FIXREVERTER[4362] && (unicode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     int res = unicode_fromformat_write_str(writer, unicode,
                                            width, -1, flags);
@@ -2681,8 +3165,23 @@ unicode_fromformat_write_wcstr(_PyUnicodeWriter *writer, const wchar_t *str,
     }
 
     PyObject *unicode = PyUnicode_FromWideChar(str, length);
-    if (unicode == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4364]) {
+      if ((unicode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4364\n");
+      else
+        fprintf(stderr, "reached bug index 4364\n");
+    }
+    if ((!FIXREVERTER[4364] && (unicode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     int res = unicode_fromformat_write_str(writer, unicode, width, -1, flags);
     Py_DECREF(unicode);
@@ -2827,11 +3326,26 @@ unicode_fromformat_arg(_PyUnicodeWriter *writer,
     case 'c':
     {
         int ordinal = va_arg(*vargs, int);
-        if (ordinal < 0 || ordinal > MAX_UNICODE) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4365]) {
+          if ((ordinal < 0 || ordinal > 1114111 ) && !(0))
+            fprintf(stderr, "triggered bug index 4365\n");
+          else
+            fprintf(stderr, "reached bug index 4365\n");
+        }
+        if ((!FIXREVERTER[4365] && (ordinal < 0 || ordinal > 1114111 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_SetString(PyExc_OverflowError,
                             "character argument not in range(0x110000)");
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (_PyUnicodeWriter_WriteCharInline(writer, ordinal) < 0)
             return NULL;
         break;
@@ -3145,8 +3659,23 @@ unicode_from_format(_PyUnicodeWriter *writer, const char *format, va_list vargs)
     for (const char *f = format; *f; ) {
         if (*f == '%') {
             f = unicode_fromformat_arg(writer, f, &vargs2);
-            if (f == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4366]) {
+              if ((f == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 4366\n");
+              else
+                fprintf(stderr, "reached bug index 4366\n");
+            }
+            if ((!FIXREVERTER[4366] && (f == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 goto fail;
+                #ifdef FRCOV
+                }
+                #endif
         }
         else {
             const char *p = strchr(f, '%');
@@ -3299,19 +3828,49 @@ PyUnicode_AsWideChar(PyObject *unicode,
 {
     Py_ssize_t res;
 
-    if (unicode == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4367]) {
+      if ((unicode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4367\n");
+      else
+        fprintf(stderr, "reached bug index 4367\n");
+    }
+    if ((!FIXREVERTER[4367] && (unicode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyUnicode_Check(unicode)) {
         PyErr_BadArgument();
         return -1;
     }
 
     res = unicode_get_widechar_size(unicode);
-    if (w == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4368]) {
+      if ((w == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4368\n");
+      else
+        fprintf(stderr, "reached bug index 4368\n");
+    }
+    if ((!FIXREVERTER[4368] && (w == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return res + 1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (size > res) {
         size = res + 1;
@@ -3341,10 +3900,25 @@ PyUnicode_AsWideCharString(PyObject *unicode,
     wchar_t *buffer;
     Py_ssize_t buflen;
 
-    if (unicode == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4369]) {
+      if ((unicode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4369\n");
+      else
+        fprintf(stderr, "reached bug index 4369\n");
+    }
+    if ((!FIXREVERTER[4369] && (unicode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyUnicode_Check(unicode)) {
         PyErr_BadArgument();
         return NULL;
@@ -3352,10 +3926,25 @@ PyUnicode_AsWideCharString(PyObject *unicode,
 
     buflen = unicode_get_widechar_size(unicode);
     buffer = (wchar_t *) PyMem_New(wchar_t, (buflen + 1));
-    if (buffer == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4370]) {
+      if ((buffer == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4370\n");
+      else
+        fprintf(stderr, "reached bug index 4370\n");
+    }
+    if ((!FIXREVERTER[4370] && (buffer == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     unicode_copy_as_widechar(unicode, buffer, buflen + 1);
 
 #ifdef HAVE_NON_UNICODE_WCHAR_T_REPRESENTATION
@@ -3581,9 +4170,24 @@ PyUnicode_Decode(const char *s,
         _Py_RETURN_UNICODE_EMPTY();
     }
 
-    if (encoding == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4375]) {
+      if ((encoding == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4375\n");
+      else
+        fprintf(stderr, "reached bug index 4375\n");
+    }
+    if ((!FIXREVERTER[4375] && (encoding == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyUnicode_DecodeUTF8Stateful(s, size, errors, NULL);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Shortcuts for common default encodings */
     if (_Py_normalize_encoding(encoding, buflower, sizeof(buflower))) {
@@ -3631,11 +4235,41 @@ PyUnicode_Decode(const char *s,
     if (PyBuffer_FillInfo(&info, NULL, (void *)s, size, 1, PyBUF_FULL_RO) < 0)
         goto onError;
     buffer = PyMemoryView_FromBuffer(&info);
-    if (buffer == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4376]) {
+      if ((buffer == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4376\n");
+      else
+        fprintf(stderr, "reached bug index 4376\n");
+    }
+    if ((!FIXREVERTER[4376] && (buffer == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto onError;
+        #ifdef FRCOV
+        }
+        #endif
     unicode = _PyCodec_DecodeText(buffer, encoding, errors);
-    if (unicode == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4377]) {
+      if ((unicode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4377\n");
+      else
+        fprintf(stderr, "reached bug index 4377\n");
+    }
+    if ((!FIXREVERTER[4377] && (unicode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto onError;
+        #ifdef FRCOV
+        }
+        #endif
     if (!PyUnicode_Check(unicode)) {
         PyErr_Format(PyExc_TypeError,
                      "'%.400s' decoder returned '%.400s' instead of 'str'; "
@@ -3752,9 +4386,24 @@ unicode_encode_locale(PyObject *unicode, _Py_error_handler error_handler,
 {
     Py_ssize_t wlen;
     wchar_t *wstr = PyUnicode_AsWideCharString(unicode, &wlen);
-    if (wstr == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4383]) {
+      if ((wstr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4383\n");
+      else
+        fprintf(stderr, "reached bug index 4383\n");
+    }
+    if ((!FIXREVERTER[4383] && (wstr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if ((size_t)wlen != wcslen(wstr)) {
         PyErr_SetString(PyExc_ValueError, "embedded null character");
@@ -3854,9 +4503,24 @@ PyUnicode_AsEncodedString(PyObject *unicode,
         return NULL;
     }
 
-    if (encoding == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4385]) {
+      if ((encoding == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4385\n");
+      else
+        fprintf(stderr, "reached bug index 4385\n");
+    }
+    if ((!FIXREVERTER[4385] && (encoding == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return _PyUnicode_AsUTF8String(unicode, errors);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Shortcuts for common default encodings */
     if (_Py_normalize_encoding(encoding, buflower, sizeof(buflower))) {
@@ -3901,8 +4565,23 @@ PyUnicode_AsEncodedString(PyObject *unicode,
 
     /* Encode via the codec registry */
     v = _PyCodec_EncodeText(unicode, encoding, errors);
-    if (v == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4386]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4386\n");
+      else
+        fprintf(stderr, "reached bug index 4386\n");
+    }
+    if ((!FIXREVERTER[4386] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* The normal path */
     if (PyBytes_Check(v))
@@ -4083,15 +4762,45 @@ PyUnicode_FSConverter(PyObject* arg, void* addr)
     PyObject *output = NULL;
     Py_ssize_t size;
     const char *data;
-    if (arg == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4390]) {
+      if ((arg == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4390\n");
+      else
+        fprintf(stderr, "reached bug index 4390\n");
+    }
+    if ((!FIXREVERTER[4390] && (arg == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(*(PyObject**)addr);
         *(PyObject**)addr = NULL;
         return 1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     path = PyOS_FSPath(arg);
-    if (path == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4391]) {
+      if ((path == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4391\n");
+      else
+        fprintf(stderr, "reached bug index 4391\n");
+    }
+    if ((!FIXREVERTER[4391] && (path == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (PyBytes_Check(path)) {
         output = path;
     }
@@ -4468,8 +5177,23 @@ unicode_decode_call_errorhandler_writer(
         goto onError;
 
     restuple = PyObject_CallOneArg(*errorHandler, *exceptionObject);
-    if (restuple == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4394]) {
+      if ((restuple == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4394\n");
+      else
+        fprintf(stderr, "reached bug index 4394\n");
+    }
+    if ((!FIXREVERTER[4394] && (restuple == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto onError;
+        #ifdef FRCOV
+        }
+        #endif
     if (!PyTuple_Check(restuple)) {
         PyErr_SetString(PyExc_TypeError, &argparse[3]);
         goto onError;
@@ -4490,12 +5214,42 @@ unicode_decode_call_errorhandler_writer(
        so the object won't go away. */
     Py_DECREF(inputobj);
 
-    if (newpos<0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4395]) {
+      if ((newpos < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4395\n");
+      else
+        fprintf(stderr, "reached bug index 4395\n");
+    }
+    if ((!FIXREVERTER[4395] && (newpos < 0 ))
+    #else
+    if (0
+    #endif
+    )
         newpos = insize+newpos;
-    if (newpos<0 || newpos>insize) {
+        #ifdef FRCOV
+        }
+        #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4396]) {
+      if ((newpos < 0 || newpos > insize ) && !(0))
+        fprintf(stderr, "triggered bug index 4396\n");
+      else
+        fprintf(stderr, "reached bug index 4396\n");
+    }
+    if ((!FIXREVERTER[4396] && (newpos < 0 || newpos > insize ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Format(PyExc_IndexError, "position %zd from error handler out of bounds", newpos);
         goto onError;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     replen = PyUnicode_GET_LENGTH(repunicode);
     if (replen > 1) {
@@ -5172,16 +5926,46 @@ unicode_decode_utf8(const char *s, Py_ssize_t size,
     const char *starts = s;
     const char *end = s + size;
     PyObject *u = PyUnicode_New(size, 127);
-    if (u == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4402]) {
+      if ((u == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4402\n");
+      else
+        fprintf(stderr, "reached bug index 4402\n");
+    }
+    if ((!FIXREVERTER[4402] && (u == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_ssize_t decoded = ascii_decode(s, end, PyUnicode_1BYTE_DATA(u));
-    if (decoded == size) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4403]) {
+      if ((decoded == size ) && !(0))
+        fprintf(stderr, "triggered bug index 4403\n");
+      else
+        fprintf(stderr, "reached bug index 4403\n");
+    }
+    if ((!FIXREVERTER[4403] && (decoded == size ))
+    #else
+    if (0
+    #endif
+    ) {
         if (consumed) {
             *consumed = size;
         }
         return u;
     }
+    #ifdef FRCOV
+    }
+    #endif
     s += decoded;
     size -= decoded;
 
@@ -5207,12 +5991,27 @@ unicode_decode_utf8_writer(_PyUnicodeWriter *writer,
                            _Py_error_handler error_handler, const char *errors,
                            Py_ssize_t *consumed)
 {
-    if (size == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4404]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4404\n");
+      else
+        fprintf(stderr, "reached bug index 4404\n");
+    }
+    if ((!FIXREVERTER[4404] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (consumed) {
             *consumed = 0;
         }
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // fast path: try ASCII string.
     if (_PyUnicodeWriter_Prepare(writer, size, 127) < 0) {
@@ -5227,12 +6026,27 @@ unicode_decode_utf8_writer(_PyUnicodeWriter *writer,
         decoded = ascii_decode(s, end, dest);
         writer->pos += decoded;
 
-        if (decoded == size) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4405]) {
+          if ((decoded == size ) && !(0))
+            fprintf(stderr, "triggered bug index 4405\n");
+          else
+            fprintf(stderr, "reached bug index 4405\n");
+        }
+        if ((!FIXREVERTER[4405] && (decoded == size ))
+        #else
+        if (0
+        #endif
+        ) {
             if (consumed) {
                 *consumed = size;
             }
             return 0;
         }
+        #ifdef FRCOV
+        }
+        #endif
         s += decoded;
         size -= decoded;
     }
@@ -5438,9 +6252,24 @@ _Py_EncodeUTF8Ex(const wchar_t *text, char **str, size_t *error_pos,
     else {
         bytes = PyMem_Malloc((len + 1) * max_char_size);
     }
-    if (bytes == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4407]) {
+      if ((bytes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4407\n");
+      else
+        fprintf(stderr, "reached bug index 4407\n");
+    }
+    if ((!FIXREVERTER[4407] && (bytes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     char *p = bytes;
     Py_ssize_t i;
@@ -5511,7 +6340,19 @@ _Py_EncodeUTF8Ex(const wchar_t *text, char **str, size_t *error_pos,
     else {
         bytes2 = PyMem_Realloc(bytes, final_size);
     }
-    if (bytes2 == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4408]) {
+      if ((bytes2 == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4408\n");
+      else
+        fprintf(stderr, "reached bug index 4408\n");
+    }
+    if ((!FIXREVERTER[4408] && (bytes2 == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (error_pos != NULL) {
             *error_pos = (size_t)-1;
         }
@@ -5523,6 +6364,9 @@ _Py_EncodeUTF8Ex(const wchar_t *text, char **str, size_t *error_pos,
         }
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     *str = bytes2;
     return 0;
 }
@@ -5571,10 +6415,25 @@ unicode_encode_utf8(PyObject *unicode, _Py_error_handler error_handler,
         break;
     }
 
-    if (end == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4409]) {
+      if ((end == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4409\n");
+      else
+        fprintf(stderr, "reached bug index 4409\n");
+    }
+    if ((!FIXREVERTER[4409] && (end == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyBytesWriter_Dealloc(&writer);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return _PyBytesWriter_Finish(&writer, end);
 }
 
@@ -5607,21 +6466,51 @@ unicode_fill_utf8(PyObject *unicode)
                                    _Py_ERROR_STRICT, NULL);
         break;
     }
-    if (end == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4410]) {
+      if ((end == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4410\n");
+      else
+        fprintf(stderr, "reached bug index 4410\n");
+    }
+    if ((!FIXREVERTER[4410] && (end == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyBytesWriter_Dealloc(&writer);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     const char *start = writer.use_small_buffer ? writer.small_buffer :
                     PyBytes_AS_STRING(writer.buffer);
     Py_ssize_t len = end - start;
 
     char *cache = PyMem_Malloc(len + 1);
-    if (cache == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4411]) {
+      if ((cache == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4411\n");
+      else
+        fprintf(stderr, "reached bug index 4411\n");
+    }
+    if ((!FIXREVERTER[4411] && (cache == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyBytesWriter_Dealloc(&writer);
         PyErr_NoMemory();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyUnicode_UTF8(unicode) = cache;
     _PyUnicode_UTF8_LENGTH(unicode) = len;
     memcpy(cache, start, len);
@@ -5682,7 +6571,22 @@ PyUnicode_DecodeUTF32Stateful(const char *s,
        byte order setting accordingly. In native mode, the leading BOM
        mark is skipped, in all other modes, it is copied to the output
        stream as-is (giving a ZWNBSP character). */
-    if (bo == 0 && size >= 4) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4412]) {
+      fprintf(stderr, "reached bug index 4412\n");
+    }
+    if ((FIXREVERTER[4412] && (bo == 0 )) || (!FIXREVERTER[4412] && (bo == 0 && size >= 4 ))
+    #else
+    if (bo == 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(size >= 4 ))
+        fprintf(stderr, "triggered bug index 4412\n");
+      #endif
+    
         Py_UCS4 bom = ((unsigned int)q[3] << 24) | (q[2] << 16) | (q[1] << 8) | q[0];
         if (bom == 0x0000FEFF) {
             bo = -1;
@@ -5695,6 +6599,9 @@ PyUnicode_DecodeUTF32Stateful(const char *s,
         if (byteorder)
             *byteorder = bo;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (q == e) {
         if (consumed)
@@ -5726,8 +6633,23 @@ PyUnicode_DecodeUTF32Stateful(const char *s,
             if (le) {
                 do {
                     ch = ((unsigned int)q[3] << 24) | (q[2] << 16) | (q[1] << 8) | q[0];
-                    if (ch > maxch)
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[4413]) {
+                      if ((ch > maxch ) && !(0))
+                        fprintf(stderr, "triggered bug index 4413\n");
+                      else
+                        fprintf(stderr, "reached bug index 4413\n");
+                    }
+                    if ((!FIXREVERTER[4413] && (ch > maxch ))
+                    #else
+                    if (0
+                    #endif
+                    )
                         break;
+                        #ifdef FRCOV
+                        }
+                        #endif
                     if (kind != PyUnicode_1BYTE_KIND &&
                         Py_UNICODE_IS_SURROGATE(ch))
                         break;
@@ -5738,8 +6660,23 @@ PyUnicode_DecodeUTF32Stateful(const char *s,
             else {
                 do {
                     ch = ((unsigned int)q[0] << 24) | (q[1] << 16) | (q[2] << 8) | q[3];
-                    if (ch > maxch)
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[4414]) {
+                      if ((ch > maxch ) && !(0))
+                        fprintf(stderr, "triggered bug index 4414\n");
+                      else
+                        fprintf(stderr, "reached bug index 4414\n");
+                    }
+                    if ((!FIXREVERTER[4414] && (ch > maxch ))
+                    #else
+                    if (0
+                    #endif
+                    )
                         break;
+                        #ifdef FRCOV
+                        }
+                        #endif
                     if (kind != PyUnicode_1BYTE_KIND &&
                         Py_UNICODE_IS_SURROGATE(ch))
                         break;
@@ -5764,12 +6701,27 @@ PyUnicode_DecodeUTF32Stateful(const char *s,
             endinpos = ((const char *)e) - starts;
         }
         else {
-            if (ch < 0x110000) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4415]) {
+              if ((ch < 1114112 ) && !(0))
+                fprintf(stderr, "triggered bug index 4415\n");
+              else
+                fprintf(stderr, "reached bug index 4415\n");
+            }
+            if ((!FIXREVERTER[4415] && (ch < 1114112 ))
+            #else
+            if (0
+            #endif
+            ) {
                 if (_PyUnicodeWriter_WriteCharInline(&writer, ch) < 0)
                     goto onError;
                 q += 4;
                 continue;
             }
+            #ifdef FRCOV
+            }
+            #endif
             errmsg = "code point not in range(0x110000)";
             startinpos = ((const char *)q) - starts;
             endinpos = startinpos + 4;
@@ -5832,16 +6784,46 @@ _PyUnicode_EncodeUTF32(PyObject *str,
         return PyErr_NoMemory();
     nsize = len + (byteorder == 0);
     v = PyBytes_FromStringAndSize(NULL, nsize * 4);
-    if (v == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4416]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4416\n");
+      else
+        fprintf(stderr, "reached bug index 4416\n");
+    }
+    if ((!FIXREVERTER[4416] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* output buffer is 4-bytes aligned */
     assert(_Py_IS_ALIGNED(PyBytes_AS_STRING(v), 4));
     out = (uint32_t *)PyBytes_AS_STRING(v);
     if (byteorder == 0)
         *out++ = 0xFEFF;
-    if (len == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4417]) {
+      if ((len == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4417\n");
+      else
+        fprintf(stderr, "reached bug index 4417\n");
+    }
+    if ((!FIXREVERTER[4417] && (len == 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto done;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (byteorder == -1)
         encoding = "utf-32-le";
@@ -5868,8 +6850,23 @@ _PyUnicode_EncodeUTF32(PyObject *str,
             pos += ucs4lib_utf32_encode((const Py_UCS4 *)data + pos, len - pos,
                                         &out, native_ordering);
         }
-        if (pos == len)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4419]) {
+          if ((pos == len ) && !(0))
+            fprintf(stderr, "triggered bug index 4419\n");
+          else
+            fprintf(stderr, "reached bug index 4419\n");
+        }
+        if ((!FIXREVERTER[4419] && (pos == len ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
 
         rep = unicode_encode_call_errorhandler(
                 errors, &errorHandler,
@@ -5990,7 +6987,22 @@ PyUnicode_DecodeUTF16Stateful(const char *s,
        byte order setting accordingly. In native mode, the leading BOM
        mark is skipped, in all other modes, it is copied to the output
        stream as-is (giving a ZWNBSP character). */
-    if (bo == 0 && size >= 2) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4420]) {
+      fprintf(stderr, "reached bug index 4420\n");
+    }
+    if ((FIXREVERTER[4420] && (bo == 0 )) || (!FIXREVERTER[4420] && (bo == 0 && size >= 2 ))
+    #else
+    if (bo == 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(size >= 2 ))
+        fprintf(stderr, "triggered bug index 4420\n");
+      #endif
+    
         const Py_UCS4 bom = (q[1] << 8) | q[0];
         if (bom == 0xFEFF) {
             q += 2;
@@ -6003,6 +7015,9 @@ PyUnicode_DecodeUTF16Stateful(const char *s,
         if (byteorder)
             *byteorder = bo;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (q == e) {
         if (consumed)
@@ -6161,9 +7176,24 @@ _PyUnicode_EncodeUTF16(PyObject *str,
     }
     nsize = len + pairs + (byteorder == 0);
     v = PyBytes_FromStringAndSize(NULL, nsize * 2);
-    if (v == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4421]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4421\n");
+      else
+        fprintf(stderr, "reached bug index 4421\n");
+    }
+    if ((!FIXREVERTER[4421] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* output buffer is 2-bytes aligned */
     assert(_Py_IS_ALIGNED(PyBytes_AS_STRING(v), 2));
@@ -6171,9 +7201,24 @@ _PyUnicode_EncodeUTF16(PyObject *str,
     if (byteorder == 0) {
         *out++ = 0xFEFF;
     }
-    if (len == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4422]) {
+      if ((len == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4422\n");
+      else
+        fprintf(stderr, "reached bug index 4422\n");
+    }
+    if ((!FIXREVERTER[4422] && (len == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto done;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (kind == PyUnicode_1BYTE_KIND) {
         ucs1lib_utf16_encode((const Py_UCS1 *)data, len, &out, native_ordering);
@@ -6203,8 +7248,23 @@ _PyUnicode_EncodeUTF16(PyObject *str,
             pos += ucs4lib_utf16_encode((const Py_UCS4 *)data + pos, len - pos,
                                         &out, native_ordering);
         }
-        if (pos == len)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4424]) {
+          if ((pos == len ) && !(0))
+            fprintf(stderr, "triggered bug index 4424\n");
+          else
+            fprintf(stderr, "reached bug index 4424\n");
+        }
+        if ((!FIXREVERTER[4424] && (pos == len ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
 
         rep = unicode_encode_call_errorhandler(
                 errors, &errorHandler,
@@ -6372,10 +7432,25 @@ _PyUnicode_DecodeUnicodeEscapeInternal(const char *s,
 
         Py_ssize_t startinpos = s - starts - 1;
         /* \ - Escapes */
-        if (s >= end) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4425]) {
+          if ((s >= end ) && !(0))
+            fprintf(stderr, "triggered bug index 4425\n");
+          else
+            fprintf(stderr, "reached bug index 4425\n");
+        }
+        if ((!FIXREVERTER[4425] && (s >= end ))
+        #else
+        if (0
+        #endif
+        ) {
             message = "\\ at end of string";
             goto incomplete;
         }
+        #ifdef FRCOV
+        }
+        #endif
         c = (unsigned char) *s++;
 
         assert(writer.pos < writer.size);
@@ -6435,9 +7510,24 @@ _PyUnicode_DecodeUnicodeEscapeInternal(const char *s,
             message = "truncated \\UXXXXXXXX escape";
         hexescape:
             for (ch = 0; count; ++s, --count) {
-                if (s >= end) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[4426]) {
+                  if ((s >= end ) && !(0))
+                    fprintf(stderr, "triggered bug index 4426\n");
+                  else
+                    fprintf(stderr, "reached bug index 4426\n");
+                }
+                if ((!FIXREVERTER[4426] && (s >= end ))
+                #else
+                if (0
+                #endif
+                ) {
                     goto incomplete;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 c = (unsigned char)*s;
                 ch <<= 4;
                 if (c >= '0' && c <= '9') {
@@ -6455,10 +7545,25 @@ _PyUnicode_DecodeUnicodeEscapeInternal(const char *s,
             }
 
             /* when we get here, ch is a 32-bit unicode character */
-            if (ch > MAX_UNICODE) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4427]) {
+              if ((ch > 1114111 ) && !(0))
+                fprintf(stderr, "triggered bug index 4427\n");
+              else
+                fprintf(stderr, "reached bug index 4427\n");
+            }
+            if ((!FIXREVERTER[4427] && (ch > 1114111 ))
+            #else
+            if (0
+            #endif
+            ) {
                 message = "illegal Unicode character";
                 goto error;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             WRITE_CHAR(ch);
             continue;
@@ -6466,27 +7571,72 @@ _PyUnicode_DecodeUnicodeEscapeInternal(const char *s,
             /* \N{name} */
         case 'N':
             ucnhash_capi = _PyUnicode_GetNameCAPI();
-            if (ucnhash_capi == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4428]) {
+              if ((ucnhash_capi == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 4428\n");
+              else
+                fprintf(stderr, "reached bug index 4428\n");
+            }
+            if ((!FIXREVERTER[4428] && (ucnhash_capi == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 PyErr_SetString(
                         PyExc_UnicodeError,
                         "\\N escapes not supported (can't load unicodedata module)"
                 );
                 goto onError;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             message = "malformed \\N character escape";
-            if (s >= end) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4429]) {
+              if ((s >= end ) && !(0))
+                fprintf(stderr, "triggered bug index 4429\n");
+              else
+                fprintf(stderr, "reached bug index 4429\n");
+            }
+            if ((!FIXREVERTER[4429] && (s >= end ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto incomplete;
             }
+            #ifdef FRCOV
+            }
+            #endif
             if (*s == '{') {
                 const char *start = ++s;
                 size_t namelen;
                 /* look for the closing brace */
                 while (s < end && *s != '}')
                     s++;
-                if (s >= end) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[4430]) {
+                  if ((s >= end ) && !(0))
+                    fprintf(stderr, "triggered bug index 4430\n");
+                  else
+                    fprintf(stderr, "reached bug index 4430\n");
+                }
+                if ((!FIXREVERTER[4430] && (s >= end ))
+                #else
+                if (0
+                #endif
+                ) {
                     goto incomplete;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 namelen = s - start;
                 if (namelen) {
                     /* found a name.  look it up in the unicode database */
@@ -7012,8 +8162,23 @@ unicode_encode_call_errorhandler(const char *errors,
         return NULL;
 
     restuple = PyObject_CallOneArg(*errorHandler, *exceptionObject);
-    if (restuple == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4442]) {
+      if ((restuple == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4442\n");
+      else
+        fprintf(stderr, "reached bug index 4442\n");
+    }
+    if ((!FIXREVERTER[4442] && (restuple == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     if (!PyTuple_Check(restuple)) {
         PyErr_SetString(PyExc_TypeError, &argparse[3]);
         Py_DECREF(restuple);
@@ -7066,13 +8231,43 @@ unicode_encode_ucs1(PyObject *unicode,
     data = PyUnicode_DATA(unicode);
     /* allocate enough for a simple encoding without
        replacements, if we need more, we'll resize */
-    if (size == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4443]) {
+      if ((size == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4443\n");
+      else
+        fprintf(stderr, "reached bug index 4443\n");
+    }
+    if ((!FIXREVERTER[4443] && (size == 0 ))
+    #else
+    if (0
+    #endif
+    )
         return PyBytes_FromStringAndSize(NULL, 0);
+        #ifdef FRCOV
+        }
+        #endif
 
     _PyBytesWriter_Init(&writer);
     str = _PyBytesWriter_Alloc(&writer, size);
-    if (str == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4444]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4444\n");
+      else
+        fprintf(stderr, "reached bug index 4444\n");
+    }
+    if ((!FIXREVERTER[4444] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     while (pos < size) {
         Py_UCS4 ch = PyUnicode_READ(kind, data, pos);
@@ -7118,8 +8313,23 @@ unicode_encode_ucs1(PyObject *unicode,
                 writer.min_size -= (collend - collstart);
                 str = backslashreplace(&writer, str,
                                        unicode, collstart, collend);
-                if (str == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[4445]) {
+                  if ((str == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 4445\n");
+                  else
+                    fprintf(stderr, "reached bug index 4445\n");
+                }
+                if ((!FIXREVERTER[4445] && (str == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto onError;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 pos = collend;
                 break;
 
@@ -7128,23 +8338,68 @@ unicode_encode_ucs1(PyObject *unicode,
                 writer.min_size -= (collend - collstart);
                 str = xmlcharrefreplace(&writer, str,
                                         unicode, collstart, collend);
-                if (str == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[4446]) {
+                  if ((str == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 4446\n");
+                  else
+                    fprintf(stderr, "reached bug index 4446\n");
+                }
+                if ((!FIXREVERTER[4446] && (str == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto onError;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 pos = collend;
                 break;
 
             case _Py_ERROR_SURROGATEESCAPE:
                 for (i = collstart; i < collend; ++i) {
                     ch = PyUnicode_READ(kind, data, i);
-                    if (ch < 0xdc80 || 0xdcff < ch) {
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[4447]) {
+                      if ((ch < 56448 || 56575 < ch ) && !(0))
+                        fprintf(stderr, "triggered bug index 4447\n");
+                      else
+                        fprintf(stderr, "reached bug index 4447\n");
+                    }
+                    if ((!FIXREVERTER[4447] && (ch < 56448 || 56575 < ch ))
+                    #else
+                    if (0
+                    #endif
+                    ) {
                         /* Not a UTF-8b surrogate */
                         break;
                     }
+                    #ifdef FRCOV
+                    }
+                    #endif
                     *str++ = (char)(ch - 0xdc00);
                     ++pos;
                 }
-                if (i >= collend)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[4448]) {
+                  if ((i >= collend ) && !(0))
+                    fprintf(stderr, "triggered bug index 4448\n");
+                  else
+                    fprintf(stderr, "reached bug index 4448\n");
+                }
+                if ((!FIXREVERTER[4448] && (i >= collend ))
+                #else
+                if (0
+                #endif
+                )
                     break;
+                    #ifdef FRCOV
+                    }
+                    #endif
                 collstart = pos;
                 assert(collstart != collend);
                 _Py_FALLTHROUGH;
@@ -7153,15 +8408,45 @@ unicode_encode_ucs1(PyObject *unicode,
                 rep = unicode_encode_call_errorhandler(errors, &error_handler_obj,
                                                        encoding, reason, unicode, &exc,
                                                        collstart, collend, &newpos);
-                if (rep == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[4449]) {
+                  if ((rep == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 4449\n");
+                  else
+                    fprintf(stderr, "reached bug index 4449\n");
+                }
+                if ((!FIXREVERTER[4449] && (rep == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto onError;
+                    #ifdef FRCOV
+                    }
+                    #endif
 
                 if (newpos < collstart) {
                     writer.overallocate = 1;
                     str = _PyBytesWriter_Prepare(&writer, str,
                                                  collstart - newpos);
-                    if (str == NULL)
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[4450]) {
+                      if ((str == (void *) 0 ) && !(0))
+                        fprintf(stderr, "triggered bug index 4450\n");
+                      else
+                        fprintf(stderr, "reached bug index 4450\n");
+                    }
+                    if ((!FIXREVERTER[4450] && (str == (void *) 0 ))
+                    #else
+                    if (0
+                    #endif
+                    )
                         goto onError;
+                        #ifdef FRCOV
+                        }
+                        #endif
                 }
                 else {
                     /* subtract preallocated bytes */
@@ -7193,8 +8478,23 @@ unicode_encode_ucs1(PyObject *unicode,
                                                     PyUnicode_DATA(rep),
                                                     PyUnicode_GET_LENGTH(rep));
                 }
-                if (str == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[4451]) {
+                  if ((str == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 4451\n");
+                  else
+                    fprintf(stderr, "reached bug index 4451\n");
+                }
+                if ((!FIXREVERTER[4451] && (str == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto onError;
+                    #ifdef FRCOV
+                    }
+                    #endif
 
                 pos = newpos;
                 Py_CLEAR(rep);
@@ -7264,13 +8564,43 @@ PyUnicode_DecodeASCII(const char *s,
 
     // Shortcut for simple case
     PyObject *u = PyUnicode_New(size, 127);
-    if (u == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4452]) {
+      if ((u == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4452\n");
+      else
+        fprintf(stderr, "reached bug index 4452\n");
+    }
+    if ((!FIXREVERTER[4452] && (u == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_ssize_t outpos = ascii_decode(s, e, PyUnicode_1BYTE_DATA(u));
-    if (outpos == size) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4453]) {
+      if ((outpos == size ) && !(0))
+        fprintf(stderr, "triggered bug index 4453\n");
+      else
+        fprintf(stderr, "reached bug index 4453\n");
+    }
+    if ((!FIXREVERTER[4453] && (outpos == size ))
+    #else
+    if (0
+    #endif
+    ) {
         return u;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     _PyUnicodeWriter writer;
     _PyUnicodeWriter_InitWithBuffer(&writer, u);
@@ -9341,14 +10671,44 @@ any_find_slice(PyObject* s1, PyObject* s2,
 
     kind1 = PyUnicode_KIND(s1);
     kind2 = PyUnicode_KIND(s2);
-    if (kind1 < kind2)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4497]) {
+      if ((kind1 < kind2 ) && !(0))
+        fprintf(stderr, "triggered bug index 4497\n");
+      else
+        fprintf(stderr, "reached bug index 4497\n");
+    }
+    if ((!FIXREVERTER[4497] && (kind1 < kind2 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     len1 = PyUnicode_GET_LENGTH(s1);
     len2 = PyUnicode_GET_LENGTH(s2);
     ADJUST_INDICES(start, end, len1);
-    if (end - start < len2)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4498]) {
+      if ((end - start < len2 ) && !(0))
+        fprintf(stderr, "triggered bug index 4498\n");
+      else
+        fprintf(stderr, "reached bug index 4498\n");
+    }
+    if ((!FIXREVERTER[4498] && (end - start < len2 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     buf1 = PyUnicode_DATA(s1);
     buf2 = PyUnicode_DATA(s2);
@@ -9582,8 +10942,23 @@ PyUnicode_FindChar(PyObject *str, Py_UCS4 ch,
     Py_ssize_t len, result;
     len = PyUnicode_GET_LENGTH(str);
     ADJUST_INDICES(start, end, len);
-    if (end - start < 1)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4499]) {
+      if ((end - start < 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 4499\n");
+      else
+        fprintf(stderr, "reached bug index 4499\n");
+    }
+    if ((!FIXREVERTER[4499] && (end - start < 1 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     kind = PyUnicode_KIND(str);
     result = findchar(PyUnicode_1BYTE_DATA(str) + kind*start,
                       kind, end-start, ch, direction);
@@ -9610,8 +10985,23 @@ tailmatch(PyObject *self,
 
     ADJUST_INDICES(start, end, PyUnicode_GET_LENGTH(self));
     end -= PyUnicode_GET_LENGTH(substring);
-    if (end < start)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4500]) {
+      if ((end < start ) && !(0))
+        fprintf(stderr, "triggered bug index 4500\n");
+      else
+        fprintf(stderr, "reached bug index 4500\n");
+    }
+    if ((!FIXREVERTER[4500] && (end < start ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (PyUnicode_GET_LENGTH(substring) == 0)
         return 1;
@@ -10119,10 +11509,25 @@ PyUnicode_Fill(PyObject *unicode, Py_ssize_t start, Py_ssize_t length,
     if (unicode_check_modifiable(unicode))
         return -1;
 
-    if (start < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4508]) {
+      if ((start < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4508\n");
+      else
+        fprintf(stderr, "reached bug index 4508\n");
+    }
+    if ((!FIXREVERTER[4508] && (start < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_IndexError, "string index out of range");
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (fill_char > PyUnicode_MAX_CHAR_VALUE(unicode)) {
         PyErr_SetString(PyExc_ValueError,
                          "fill character is bigger than "
@@ -10475,13 +11880,43 @@ replace(PyObject *self, PyObject *str1,
     int mayshrink;
     Py_UCS4 maxchar, maxchar_str1, maxchar_str2;
 
-    if (slen < len1)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4514]) {
+      if ((slen < len1 ) && !(0))
+        fprintf(stderr, "triggered bug index 4514\n");
+      else
+        fprintf(stderr, "reached bug index 4514\n");
+    }
+    if ((!FIXREVERTER[4514] && (slen < len1 ))
+    #else
+    if (0
+    #endif
+    )
         goto nothing;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (maxcount < 0)
         maxcount = PY_SSIZE_T_MAX;
-    else if (maxcount == 0)
+    else 
+    #ifdef FRCOV
+    {if (FIXREVERTER[4515]) {
+      if ((maxcount == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4515\n");
+      else
+        fprintf(stderr, "reached bug index 4515\n");
+    }
+    if ((!FIXREVERTER[4515] && (maxcount == 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto nothing;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (str1 == str2)
         goto nothing;
@@ -10499,8 +11934,23 @@ replace(PyObject *self, PyObject *str1,
 
     if (len1 == len2) {
         /* same length */
-        if (len1 == 0)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4517]) {
+          if ((len1 == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4517\n");
+          else
+            fprintf(stderr, "reached bug index 4517\n");
+        }
+        if ((!FIXREVERTER[4517] && (len1 == 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto nothing;
+            #ifdef FRCOV
+            }
+            #endif
         if (len1 == 1) {
             /* replace characters */
             Py_UCS4 u1, u2;
@@ -10508,8 +11958,23 @@ replace(PyObject *self, PyObject *str1,
 
             u1 = PyUnicode_READ(kind1, buf1, 0);
             pos = findchar(sbuf, skind, slen, u1, 1);
-            if (pos < 0)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4518]) {
+              if ((pos < 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 4518\n");
+              else
+                fprintf(stderr, "reached bug index 4518\n");
+            }
+            if ((!FIXREVERTER[4518] && (pos < 0 ))
+            #else
+            if (0
+            #endif
+            )
                 goto nothing;
+                #ifdef FRCOV
+                }
+                #endif
             u2 = PyUnicode_READ(kind2, buf2, 0);
             u = PyUnicode_New(slen, maxchar);
             if (!u)
@@ -10530,8 +11995,23 @@ replace(PyObject *self, PyObject *str1,
                 release1 = 1;
             }
             i = anylib_find(rkind, self, sbuf, slen, str1, buf1, len1, 0);
-            if (i < 0)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4519]) {
+              if ((i < 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 4519\n");
+              else
+                fprintf(stderr, "reached bug index 4519\n");
+            }
+            if ((!FIXREVERTER[4519] && (i < 0 ))
+            #else
+            if (0
+            #endif
+            )
                 goto nothing;
+                #ifdef FRCOV
+                }
+                #endif
             if (rkind > kind2) {
                 /* widen replacement */
                 buf2 = unicode_askind(kind2, buf2, len2, rkind);
@@ -10593,8 +12073,23 @@ replace(PyObject *self, PyObject *str1,
             release1 = 1;
         }
         n = anylib_count(rkind, self, sbuf, slen, str1, buf1, len1, maxcount);
-        if (n == 0)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4520]) {
+          if ((n == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4520\n");
+          else
+            fprintf(stderr, "reached bug index 4520\n");
+        }
+        if ((!FIXREVERTER[4520] && (n == 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto nothing;
+            #ifdef FRCOV
+            }
+            #endif
         if (kind2 < rkind) {
             /* widen replacement */
             buf2 = unicode_askind(kind2, buf2, len2, rkind);
@@ -10625,15 +12120,45 @@ replace(PyObject *self, PyObject *str1,
                 goto error;
         }
         new_size = slen + n * (len2 - len1);
-        if (new_size == 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4521]) {
+          if ((new_size == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4521\n");
+          else
+            fprintf(stderr, "reached bug index 4521\n");
+        }
+        if ((!FIXREVERTER[4521] && (new_size == 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             u = unicode_get_empty();
             goto done;
         }
-        if (new_size > (PY_SSIZE_T_MAX / rkind)) {
+        #ifdef FRCOV
+        }
+        #endif
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4522]) {
+          if ((new_size > 9223372036854775807 / rkind ) && !(0))
+            fprintf(stderr, "triggered bug index 4522\n");
+          else
+            fprintf(stderr, "reached bug index 4522\n");
+        }
+        if ((!FIXREVERTER[4522] && (new_size > 9223372036854775807 / rkind ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_SetString(PyExc_OverflowError,
                             "replace string is too long");
             goto error;
         }
+        #ifdef FRCOV
+        }
+        #endif
         u = PyUnicode_New(new_size, maxchar);
         if (!u)
             goto error;
@@ -10693,8 +12218,23 @@ replace(PyObject *self, PyObject *str1,
 
     if (mayshrink) {
         unicode_adjust_maxchar(&u);
-        if (u == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4523]) {
+          if ((u == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4523\n");
+          else
+            fprintf(stderr, "reached bug index 4523\n");
+        }
+        if ((!FIXREVERTER[4523] && (u == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto error;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
   done:
@@ -11249,15 +12789,45 @@ PyUnicode_Contains(PyObject *str, PyObject *substr)
         return 0;
     len1 = PyUnicode_GET_LENGTH(str);
     len2 = PyUnicode_GET_LENGTH(substr);
-    if (len1 < len2)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4533]) {
+      if ((len1 < len2 ) && !(0))
+        fprintf(stderr, "triggered bug index 4533\n");
+      else
+        fprintf(stderr, "reached bug index 4533\n");
+    }
+    if ((!FIXREVERTER[4533] && (len1 < len2 ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
     buf1 = PyUnicode_DATA(str);
     buf2 = PyUnicode_DATA(substr);
-    if (len2 == 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4534]) {
+      if ((len2 == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 4534\n");
+      else
+        fprintf(stderr, "reached bug index 4534\n");
+    }
+    if ((!FIXREVERTER[4534] && (len2 == 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_UCS4 ch = PyUnicode_READ(kind2, buf2, 0);
         result = findchar((const char *)buf1, kind1, len1, ch, 1) != -1;
         return result;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (kind2 != kind1) {
         buf2 = unicode_askind(kind2, buf2, len2, kind1);
         if (!buf2)
@@ -11315,11 +12885,26 @@ PyUnicode_Concat(PyObject *left, PyObject *right)
 
     left_len = PyUnicode_GET_LENGTH(left);
     right_len = PyUnicode_GET_LENGTH(right);
-    if (left_len > PY_SSIZE_T_MAX - right_len) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4535]) {
+      if ((left_len > 9223372036854775807 - right_len ) && !(0))
+        fprintf(stderr, "triggered bug index 4535\n");
+      else
+        fprintf(stderr, "reached bug index 4535\n");
+    }
+    if ((!FIXREVERTER[4535] && (left_len > 9223372036854775807 - right_len ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_OverflowError,
                         "strings are too large to concat");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     new_len = left_len + right_len;
 
     maxchar = PyUnicode_MAX_CHAR_VALUE(left);
@@ -11328,8 +12913,23 @@ PyUnicode_Concat(PyObject *left, PyObject *right)
 
     /* Concat the two Unicode strings */
     result = PyUnicode_New(new_len, maxchar);
-    if (result == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4536]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4536\n");
+      else
+        fprintf(stderr, "reached bug index 4536\n");
+    }
+    if ((!FIXREVERTER[4536] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     _PyUnicode_FastCopyCharacters(result, 0, left, 0, left_len);
     _PyUnicode_FastCopyCharacters(result, left_len, right, 0, right_len);
     assert(_PyUnicode_CheckConsistency(result, 1));
@@ -11343,11 +12943,26 @@ PyUnicode_Append(PyObject **p_left, PyObject *right)
     Py_UCS4 maxchar, maxchar2;
     Py_ssize_t left_len, right_len, new_len;
 
-    if (p_left == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4537]) {
+      if ((p_left == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4537\n");
+      else
+        fprintf(stderr, "reached bug index 4537\n");
+    }
+    if ((!FIXREVERTER[4537] && (p_left == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (!PyErr_Occurred())
             PyErr_BadInternalCall();
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     left = *p_left;
     if (right == NULL || left == NULL
         || !PyUnicode_Check(left) || !PyUnicode_Check(right)) {
@@ -11369,11 +12984,26 @@ PyUnicode_Append(PyObject **p_left, PyObject *right)
 
     left_len = PyUnicode_GET_LENGTH(left);
     right_len = PyUnicode_GET_LENGTH(right);
-    if (left_len > PY_SSIZE_T_MAX - right_len) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4538]) {
+      if ((left_len > 9223372036854775807 - right_len ) && !(0))
+        fprintf(stderr, "triggered bug index 4538\n");
+      else
+        fprintf(stderr, "reached bug index 4538\n");
+    }
+    if ((!FIXREVERTER[4538] && (left_len > 9223372036854775807 - right_len ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_OverflowError,
                         "strings are too large to concat");
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     new_len = left_len + right_len;
 
     if (unicode_modifiable(left)
@@ -11399,8 +13029,23 @@ PyUnicode_Append(PyObject **p_left, PyObject *right)
 
         /* Concat the two Unicode strings */
         res = PyUnicode_New(new_len, maxchar);
-        if (res == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4539]) {
+          if ((res == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4539\n");
+          else
+            fprintf(stderr, "reached bug index 4539\n");
+        }
+        if ((!FIXREVERTER[4539] && (res == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto error;
+            #ifdef FRCOV
+            }
+            #endif
         _PyUnicode_FastCopyCharacters(res, 0, left, 0, left_len);
         _PyUnicode_FastCopyCharacters(res, left_len, right, 0, right_len);
         Py_DECREF(left);
@@ -12309,10 +13954,25 @@ PyUnicode_Substring(PyObject *self, Py_ssize_t start, Py_ssize_t end)
     if (start == 0 && end == length)
         return unicode_result_unchanged(self);
 
-    if (start < 0 || end < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4566]) {
+      if ((start < 0 || end < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4566\n");
+      else
+        fprintf(stderr, "reached bug index 4566\n");
+    }
+    if ((!FIXREVERTER[4566] && (start < 0 || end < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_IndexError, "string index out of range");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (start >= length || end < start)
         _Py_RETURN_UNICODE_EMPTY();
 
@@ -13454,10 +15114,25 @@ _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer,
     assert((maxchar > writer->maxchar && length >= 0)
            || length > 0);
 
-    if (length > PY_SSIZE_T_MAX - writer->pos) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4584]) {
+      if ((length > 9223372036854775807 - writer -> pos ) && !(0))
+        fprintf(stderr, "triggered bug index 4584\n");
+      else
+        fprintf(stderr, "reached bug index 4584\n");
+    }
+    if ((!FIXREVERTER[4584] && (length > 9223372036854775807 - writer -> pos ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     newlen = writer->pos + length;
 
     maxchar = Py_MAX(maxchar, writer->min_char);
@@ -13469,12 +15144,42 @@ _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer,
             /* overallocate to limit the number of realloc() */
             newlen += newlen / OVERALLOCATE_FACTOR;
         }
-        if (newlen < writer->min_length)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4585]) {
+          if ((newlen < writer -> min_length ) && !(0))
+            fprintf(stderr, "triggered bug index 4585\n");
+          else
+            fprintf(stderr, "reached bug index 4585\n");
+        }
+        if ((!FIXREVERTER[4585] && (newlen < writer -> min_length ))
+        #else
+        if (0
+        #endif
+        )
             newlen = writer->min_length;
+            #ifdef FRCOV
+            }
+            #endif
 
         writer->buffer = PyUnicode_New(newlen, maxchar);
-        if (writer->buffer == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4586]) {
+          if ((writer -> buffer == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4586\n");
+          else
+            fprintf(stderr, "reached bug index 4586\n");
+        }
+        if ((!FIXREVERTER[4586] && (writer -> buffer == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
     }
     else if (newlen > writer->size) {
         if (writer->overallocate
@@ -13482,15 +15187,45 @@ _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer,
             /* overallocate to limit the number of realloc() */
             newlen += newlen / OVERALLOCATE_FACTOR;
         }
-        if (newlen < writer->min_length)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4587]) {
+          if ((newlen < writer -> min_length ) && !(0))
+            fprintf(stderr, "triggered bug index 4587\n");
+          else
+            fprintf(stderr, "reached bug index 4587\n");
+        }
+        if ((!FIXREVERTER[4587] && (newlen < writer -> min_length ))
+        #else
+        if (0
+        #endif
+        )
             newlen = writer->min_length;
+            #ifdef FRCOV
+            }
+            #endif
 
         if (maxchar > writer->maxchar || writer->readonly) {
             /* resize + widen */
             maxchar = Py_MAX(maxchar, writer->maxchar);
             newbuffer = PyUnicode_New(newlen, maxchar);
-            if (newbuffer == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4588]) {
+              if ((newbuffer == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 4588\n");
+              else
+                fprintf(stderr, "reached bug index 4588\n");
+            }
+            if ((!FIXREVERTER[4588] && (newbuffer == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return -1;
+                #ifdef FRCOV
+                }
+                #endif
             _PyUnicode_FastCopyCharacters(newbuffer, 0,
                                           writer->buffer, 0, writer->pos);
             Py_DECREF(writer->buffer);
@@ -13498,16 +15233,46 @@ _PyUnicodeWriter_PrepareInternal(_PyUnicodeWriter *writer,
         }
         else {
             newbuffer = resize_compact(writer->buffer, newlen);
-            if (newbuffer == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4589]) {
+              if ((newbuffer == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 4589\n");
+              else
+                fprintf(stderr, "reached bug index 4589\n");
+            }
+            if ((!FIXREVERTER[4589] && (newbuffer == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return -1;
+                #ifdef FRCOV
+                }
+                #endif
         }
         writer->buffer = newbuffer;
     }
     else if (maxchar > writer->maxchar) {
         assert(!writer->readonly);
         newbuffer = PyUnicode_New(writer->size, maxchar);
-        if (newbuffer == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4590]) {
+          if ((newbuffer == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4590\n");
+          else
+            fprintf(stderr, "reached bug index 4590\n");
+        }
+        if ((!FIXREVERTER[4590] && (newbuffer == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
         _PyUnicode_FastCopyCharacters(newbuffer, 0,
                                       writer->buffer, 0, writer->pos);
         Py_SETREF(writer->buffer, newbuffer);
@@ -13577,8 +15342,23 @@ _PyUnicodeWriter_WriteStr(_PyUnicodeWriter *writer, PyObject *str)
     Py_ssize_t len;
 
     len = PyUnicode_GET_LENGTH(str);
-    if (len == 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4592]) {
+      if ((len == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4592\n");
+      else
+        fprintf(stderr, "reached bug index 4592\n");
+    }
+    if ((!FIXREVERTER[4592] && (len == 0 ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
     maxchar = PyUnicode_MAX_CHAR_VALUE(str);
     if (maxchar > writer->maxchar || len > writer->size - writer->pos) {
         if (writer->buffer == NULL && !writer->overallocate) {
@@ -13694,8 +15474,23 @@ _PyUnicodeWriter_WriteASCIIString(_PyUnicodeWriter *writer,
         PyObject *str;
 
         str = _PyUnicode_FromASCII(ascii, len);
-        if (str == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4597]) {
+          if ((str == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4597\n");
+          else
+            fprintf(stderr, "reached bug index 4597\n");
+        }
+        if ((!FIXREVERTER[4597] && (str == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
 
         writer->readonly = 1;
         writer->buffer = str;
@@ -13821,10 +15616,25 @@ _PyUnicodeWriter_Finish(_PyUnicodeWriter *writer)
     if (PyUnicode_GET_LENGTH(str) != writer->pos) {
         PyObject *str2;
         str2 = resize_compact(str, writer->pos);
-        if (str2 == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4598]) {
+          if ((str2 == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4598\n");
+          else
+            fprintf(stderr, "reached bug index 4598\n");
+        }
+        if ((!FIXREVERTER[4598] && (str2 == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(str);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         str = str2;
     }
 
@@ -15594,9 +17404,24 @@ PyObject *
 PyUnicode_InternFromString(const char *cp)
 {
     PyObject *s = PyUnicode_FromString(cp);
-    if (s == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4631]) {
+      if ((s == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4631\n");
+      else
+        fprintf(stderr, "reached bug index 4631\n");
+    }
+    if ((!FIXREVERTER[4631] && (s == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyInterpreterState *interp = _PyInterpreterState_GET();
     _PyUnicode_InternMortal(interp, &s);
     return s;
@@ -15607,9 +17432,24 @@ void
 _PyUnicode_ClearInterned(PyInterpreterState *interp)
 {
     PyObject *interned = get_interned_dict(interp);
-    if (interned == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4632]) {
+      if ((interned == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4632\n");
+      else
+        fprintf(stderr, "reached bug index 4632\n");
+    }
+    if ((!FIXREVERTER[4632] && (interned == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(PyDict_CheckExact(interned));
 
 #ifdef INTERNED_STATS
diff --git a/Parser/action_helpers.c b/Parser/action_helpers.c
index 44bf87da828..2b81abd75c5 100644
--- a/Parser/action_helpers.c
+++ b/Parser/action_helpers.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include <Python.h>
 
 #include "pegen.h"
@@ -242,9 +246,24 @@ static asdl_expr_seq *
 _set_seq_context(Parser *p, asdl_expr_seq *seq, expr_context_ty ctx)
 {
     Py_ssize_t len = asdl_seq_LEN(seq);
-    if (len == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5692]) {
+      if ((len == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5692\n");
+      else
+        fprintf(stderr, "reached bug index 5692\n");
+    }
+    if ((!FIXREVERTER[5692] && (len == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     asdl_expr_seq *new_seq = _Py_asdl_expr_seq_new(len, p->arena);
     if (!new_seq) {
@@ -609,23 +628,59 @@ static int
 _make_kwargs(Parser *p, StarEtc *star_etc,
              asdl_arg_seq **kwonlyargs,
              asdl_expr_seq **kwdefaults) {
-    if (star_etc != NULL && star_etc->kwonlyargs != NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5693]) {
+      fprintf(stderr, "reached bug index 5693\n");
+    }
+    if ((FIXREVERTER[5693] && (star_etc != (void *) 0 )) || (!FIXREVERTER[5693] && (star_etc != (void *) 0 && star_etc -> kwonlyargs != (void *) 0 ))
+    #else
+    if (star_etc != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(star_etc -> kwonlyargs != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5693\n");
+      #endif
+    
         *kwonlyargs = _get_names(p, star_etc->kwonlyargs);
     }
     else {
         *kwonlyargs = _Py_asdl_arg_seq_new(0, p->arena);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (*kwonlyargs == NULL) {
         return -1;
     }
 
-    if (star_etc != NULL && star_etc->kwonlyargs != NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5694]) {
+      fprintf(stderr, "reached bug index 5694\n");
+    }
+    if ((FIXREVERTER[5694] && (star_etc != (void *) 0 )) || (!FIXREVERTER[5694] && (star_etc != (void *) 0 && star_etc -> kwonlyargs != (void *) 0 ))
+    #else
+    if (star_etc != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(star_etc -> kwonlyargs != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5694\n");
+      #endif
+    
         *kwdefaults = _get_defaults(p, star_etc->kwonlyargs);
     }
     else {
         *kwdefaults = _Py_asdl_expr_seq_new(0, p->arena);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (*kwdefaults == NULL) {
         return -1;
@@ -656,9 +711,27 @@ _PyPegen_make_arguments(Parser *p, asdl_arg_seq *slash_without_default,
     }
 
     arg_ty vararg = NULL;
-    if (star_etc != NULL && star_etc->vararg != NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5695]) {
+      fprintf(stderr, "reached bug index 5695\n");
+    }
+    if ((FIXREVERTER[5695] && (star_etc != (void *) 0 )) || (!FIXREVERTER[5695] && (star_etc != (void *) 0 && star_etc -> vararg != (void *) 0 ))
+    #else
+    if (star_etc != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(star_etc -> vararg != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5695\n");
+      #endif
+    
         vararg = star_etc->vararg;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     asdl_arg_seq *kwonlyargs;
     asdl_expr_seq *kwdefaults;
@@ -667,9 +740,27 @@ _PyPegen_make_arguments(Parser *p, asdl_arg_seq *slash_without_default,
     }
 
     arg_ty kwarg = NULL;
-    if (star_etc != NULL && star_etc->kwarg != NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5696]) {
+      fprintf(stderr, "reached bug index 5696\n");
+    }
+    if ((FIXREVERTER[5696] && (star_etc != (void *) 0 )) || (!FIXREVERTER[5696] && (star_etc != (void *) 0 && star_etc -> kwarg != (void *) 0 ))
+    #else
+    if (star_etc != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(star_etc -> kwarg != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 5696\n");
+      #endif
+    
         kwarg = star_etc->kwarg;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     return _PyAST_arguments(posonlyargs, posargs, vararg, kwonlyargs,
                             kwdefaults, kwarg, posdefaults, p->arena);
@@ -792,9 +883,24 @@ asdl_expr_seq *
 _PyPegen_seq_extract_starred_exprs(Parser *p, asdl_seq *kwargs)
 {
     int new_len = _seq_number_of_starred_exprs(kwargs);
-    if (new_len == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5697]) {
+      if ((new_len == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5697\n");
+      else
+        fprintf(stderr, "reached bug index 5697\n");
+    }
+    if ((!FIXREVERTER[5697] && (new_len == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     asdl_expr_seq *new_seq = _Py_asdl_expr_seq_new(new_len, p->arena);
     if (!new_seq) {
         return NULL;
@@ -816,9 +922,24 @@ _PyPegen_seq_delete_starred_exprs(Parser *p, asdl_seq *kwargs)
 {
     Py_ssize_t len = asdl_seq_LEN(kwargs);
     Py_ssize_t new_len = len - _seq_number_of_starred_exprs(kwargs);
-    if (new_len == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5698]) {
+      if ((new_len == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5698\n");
+      else
+        fprintf(stderr, "reached bug index 5698\n");
+    }
+    if ((!FIXREVERTER[5698] && (new_len == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     asdl_keyword_seq *new_seq = _Py_asdl_keyword_seq_new(new_len, p->arena);
     if (!new_seq) {
         return NULL;
@@ -861,19 +982,64 @@ _PyPegen_make_module(Parser *p, asdl_stmt_seq *a) {
     if (num > 0) {
         // Turn the raw (comment, lineno) pairs into TypeIgnore objects in the arena
         type_ignores = _Py_asdl_type_ignore_seq_new(num, p->arena);
-        if (type_ignores == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5699]) {
+          if ((type_ignores == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5699\n");
+          else
+            fprintf(stderr, "reached bug index 5699\n");
+        }
+        if ((!FIXREVERTER[5699] && (type_ignores == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         for (Py_ssize_t i = 0; i < num; i++) {
             PyObject *tag = _PyPegen_new_type_comment(p, p->type_ignore_comments.items[i].comment);
-            if (tag == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5700]) {
+              if ((tag == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5700\n");
+              else
+                fprintf(stderr, "reached bug index 5700\n");
+            }
+            if ((!FIXREVERTER[5700] && (tag == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             type_ignore_ty ti = _PyAST_TypeIgnore(p->type_ignore_comments.items[i].lineno,
                                                   tag, p->arena);
-            if (ti == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5701]) {
+              if ((ti == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5701\n");
+              else
+                fprintf(stderr, "reached bug index 5701\n");
+            }
+            if ((!FIXREVERTER[5701] && (ti == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             asdl_seq_SET(type_ignores, i, ti);
         }
     }
@@ -884,9 +1050,24 @@ PyObject *
 _PyPegen_new_type_comment(Parser *p, const char *s)
 {
     PyObject *res = PyUnicode_DecodeUTF8(s, strlen(s), NULL);
-    if (res == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5702]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5702\n");
+      else
+        fprintf(stderr, "reached bug index 5702\n");
+    }
+    if ((!FIXREVERTER[5702] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_PyArena_AddPyObject(p->arena, res) < 0) {
         Py_DECREF(res);
         return NULL;
@@ -897,17 +1078,62 @@ _PyPegen_new_type_comment(Parser *p, const char *s)
 arg_ty
 _PyPegen_add_type_comment_to_arg(Parser *p, arg_ty a, Token *tc)
 {
-    if (tc == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5703]) {
+      if ((tc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5703\n");
+      else
+        fprintf(stderr, "reached bug index 5703\n");
+    }
+    if ((!FIXREVERTER[5703] && (tc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return a;
     }
+    #ifdef FRCOV
+    }
+    #endif
     const char *bytes = PyBytes_AsString(tc->bytes);
-    if (bytes == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5704]) {
+      if ((bytes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5704\n");
+      else
+        fprintf(stderr, "reached bug index 5704\n");
+    }
+    if ((!FIXREVERTER[5704] && (bytes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *tco = _PyPegen_new_type_comment(p, bytes);
-    if (tco == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5705]) {
+      if ((tco == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5705\n");
+      else
+        fprintf(stderr, "reached bug index 5705\n");
+    }
+    if ((!FIXREVERTER[5705] && (tco == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return _PyAST_arg(a->arg, a->annotation, tco,
                       a->lineno, a->col_offset, a->end_lineno, a->end_col_offset,
                       p->arena);
@@ -949,9 +1175,24 @@ static ResultTokenWithMetadata *
 result_token_with_metadata(Parser *p, void *result, PyObject *metadata)
 {
     ResultTokenWithMetadata *res = _PyArena_Malloc(p->arena, sizeof(ResultTokenWithMetadata));
-    if (res == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5706]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5706\n");
+      else
+        fprintf(stderr, "reached bug index 5706\n");
+    }
+    if ((!FIXREVERTER[5706] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     res->metadata = metadata;
     res->result = result;
     return res;
@@ -960,12 +1201,27 @@ result_token_with_metadata(Parser *p, void *result, PyObject *metadata)
 ResultTokenWithMetadata *
 _PyPegen_check_fstring_conversion(Parser *p, Token* conv_token, expr_ty conv)
 {
-    if (conv_token->lineno != conv->lineno || conv_token->end_col_offset != conv->col_offset) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5707]) {
+      if ((conv_token -> lineno != conv -> lineno || conv_token -> end_col_offset != conv -> col_offset ) && !(0))
+        fprintf(stderr, "triggered bug index 5707\n");
+      else
+        fprintf(stderr, "reached bug index 5707\n");
+    }
+    if ((!FIXREVERTER[5707] && (conv_token -> lineno != conv -> lineno || conv_token -> end_col_offset != conv -> col_offset ))
+    #else
+    if (0
+    #endif
+    ) {
         return RAISE_SYNTAX_ERROR_KNOWN_RANGE(
             conv_token, conv,
             "f-string: conversion type must come right after the exclamanation mark"
         );
     }
+    #ifdef FRCOV
+    }
+    #endif
     return result_token_with_metadata(p, conv, conv_token->metadata);
 }
 
@@ -991,9 +1247,24 @@ _PyPegen_setup_full_format_spec(Parser *p, Token *colon, asdl_expr_seq *spec, in
     if (non_empty_count != n_items) {
         asdl_expr_seq *resized_spec =
             _Py_asdl_expr_seq_new(non_empty_count, p->arena);
-        if (resized_spec == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5708]) {
+          if ((resized_spec == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5708\n");
+          else
+            fprintf(stderr, "reached bug index 5708\n");
+        }
+        if ((!FIXREVERTER[5708] && (resized_spec == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         Py_ssize_t j = 0;
         for (Py_ssize_t i = 0; i < n_items; i++) {
             expr_ty item = asdl_seq_GET(spec, i);
@@ -1104,11 +1375,26 @@ expr_ty _PyPegen_collect_call_seqs(Parser *p, asdl_expr_seq *a, asdl_seq *b,
     Py_ssize_t args_len = asdl_seq_LEN(a);
     Py_ssize_t total_len = args_len;
 
-    if (b == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5709]) {
+      if ((b == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5709\n");
+      else
+        fprintf(stderr, "reached bug index 5709\n");
+    }
+    if ((!FIXREVERTER[5709] && (b == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return _PyAST_Call(_PyPegen_dummy_name(p), a, NULL, lineno, col_offset,
                         end_lineno, end_col_offset, arena);
 
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     asdl_expr_seq *starreds = _PyPegen_seq_extract_starred_exprs(p, b);
     asdl_keyword_seq *keywords = _PyPegen_seq_delete_starred_exprs(p, b);
@@ -1136,9 +1422,24 @@ expr_ty _PyPegen_collect_call_seqs(Parser *p, asdl_expr_seq *a, asdl_seq *b,
 expr_ty
 _PyPegen_get_invalid_target(expr_ty e, TARGETS_TYPE targets_type)
 {
-    if (e == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5710]) {
+      if ((e == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5710\n");
+      else
+        fprintf(stderr, "reached bug index 5710\n");
+    }
+    if ((!FIXREVERTER[5710] && (e == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 #define VISIT_CONTAINER(CONTAINER, TYPE) do { \
         Py_ssize_t len = asdl_seq_LEN((CONTAINER)->v.TYPE.elts);\
@@ -1220,9 +1521,24 @@ _PyPegen_nonparen_genexp_in_call(Parser *p, expr_ty args, asdl_comprehension_seq
        argument (x in the above example) as the location of the
        error */
     Py_ssize_t len = asdl_seq_LEN(args->v.Call.args);
-    if (len <= 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5711]) {
+      if ((len <= 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 5711\n");
+      else
+        fprintf(stderr, "reached bug index 5711\n");
+    }
+    if ((!FIXREVERTER[5711] && (len <= 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     comprehension_ty last_comprehension = PyPegen_last_item(comprehensions, comprehension_ty);
 
@@ -1240,9 +1556,24 @@ _PyPegen_decode_fstring_part(Parser* p, int is_raw, expr_ty constant, Token* tok
     assert(PyUnicode_CheckExact(constant->v.Constant.value));
 
     const char* bstr = PyUnicode_AsUTF8(constant->v.Constant.value);
-    if (bstr == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5712]) {
+      if ((bstr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5712\n");
+      else
+        fprintf(stderr, "reached bug index 5712\n");
+    }
+    if ((!FIXREVERTER[5712] && (bstr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     size_t len;
     if (strcmp(bstr, "{{") == 0 || strcmp(bstr, "}}") == 0) {
@@ -1253,10 +1584,25 @@ _PyPegen_decode_fstring_part(Parser* p, int is_raw, expr_ty constant, Token* tok
 
     is_raw = is_raw || strchr(bstr, '\\') == NULL;
     PyObject *str = _PyPegen_decode_string(p, is_raw, bstr, len, token);
-    if (str == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5713]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5713\n");
+      else
+        fprintf(stderr, "reached bug index 5713\n");
+    }
+    if ((!FIXREVERTER[5713] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _Pypegen_raise_decode_error(p);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_PyArena_AddPyObject(p->arena, str) < 0) {
         Py_DECREF(str);
         return NULL;
@@ -1312,24 +1658,69 @@ _PyPegen_joined_str(Parser *p, Token* a, asdl_expr_seq* raw_expressions, Token*b
     Py_ssize_t n_items = asdl_seq_LEN(expr);
 
     const char* quote_str = PyBytes_AsString(a->bytes);
-    if (quote_str == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5714]) {
+      if ((quote_str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5714\n");
+      else
+        fprintf(stderr, "reached bug index 5714\n");
+    }
+    if ((!FIXREVERTER[5714] && (quote_str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int is_raw = strpbrk(quote_str, "rR") != NULL;
 
     asdl_expr_seq *seq = _Py_asdl_expr_seq_new(n_items, p->arena);
-    if (seq == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5715]) {
+      if ((seq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5715\n");
+      else
+        fprintf(stderr, "reached bug index 5715\n");
+    }
+    if ((!FIXREVERTER[5715] && (seq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Py_ssize_t index = 0;
     for (Py_ssize_t i = 0; i < n_items; i++) {
         expr_ty item = asdl_seq_GET(expr, i);
         if (item->kind == Constant_kind) {
             item = _PyPegen_decode_fstring_part(p, is_raw, item, b);
-            if (item == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5716]) {
+              if ((item == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5716\n");
+              else
+                fprintf(stderr, "reached bug index 5716\n");
+            }
+            if ((!FIXREVERTER[5716] && (item == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             /* Tokenizer emits string parts even when the underlying string
             might become an empty value (e.g. FSTRING_MIDDLE with the value \\n)
@@ -1345,9 +1736,24 @@ _PyPegen_joined_str(Parser *p, Token* a, asdl_expr_seq* raw_expressions, Token*b
     asdl_expr_seq *resized_exprs;
     if (index != n_items) {
         resized_exprs = _Py_asdl_expr_seq_new(index, p->arena);
-        if (resized_exprs == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5717]) {
+          if ((resized_exprs == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5717\n");
+          else
+            fprintf(stderr, "reached bug index 5717\n");
+        }
+        if ((!FIXREVERTER[5717] && (resized_exprs == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         for (Py_ssize_t i = 0; i < index; i++) {
             asdl_seq_SET(resized_exprs, i, asdl_seq_GET(seq, i));
         }
@@ -1368,9 +1774,24 @@ expr_ty _PyPegen_decoded_constant_from_token(Parser* p, Token* tok) {
         return NULL;
     }
     PyObject* str = _PyPegen_decode_string(p, 0, bstr, bsize, tok);
-    if (str == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5718]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5718\n");
+      else
+        fprintf(stderr, "reached bug index 5718\n");
+    }
+    if ((!FIXREVERTER[5718] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_PyArena_AddPyObject(p->arena, str) < 0) {
         Py_DECREF(str);
         return NULL;
@@ -1382,13 +1803,43 @@ expr_ty _PyPegen_decoded_constant_from_token(Parser* p, Token* tok) {
 
 expr_ty _PyPegen_constant_from_token(Parser* p, Token* tok) {
     char* bstr = PyBytes_AsString(tok->bytes);
-    if (bstr == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5719]) {
+      if ((bstr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5719\n");
+      else
+        fprintf(stderr, "reached bug index 5719\n");
+    }
+    if ((!FIXREVERTER[5719] && (bstr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject* str = PyUnicode_FromString(bstr);
-    if (str == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5720]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5720\n");
+      else
+        fprintf(stderr, "reached bug index 5720\n");
+    }
+    if ((!FIXREVERTER[5720] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_PyArena_AddPyObject(p->arena, str) < 0) {
         Py_DECREF(str);
         return NULL;
@@ -1400,14 +1851,44 @@ expr_ty _PyPegen_constant_from_token(Parser* p, Token* tok) {
 
 expr_ty _PyPegen_constant_from_string(Parser* p, Token* tok) {
     char* the_str = PyBytes_AsString(tok->bytes);
-    if (the_str == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5721]) {
+      if ((the_str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5721\n");
+      else
+        fprintf(stderr, "reached bug index 5721\n");
+    }
+    if ((!FIXREVERTER[5721] && (the_str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *s = _PyPegen_parse_string(p, tok);
-    if (s == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5722]) {
+      if ((s == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5722\n");
+      else
+        fprintf(stderr, "reached bug index 5722\n");
+    }
+    if ((!FIXREVERTER[5722] && (s == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _Pypegen_raise_decode_error(p);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_PyArena_AddPyObject(p->arena, s) < 0) {
         Py_DECREF(s);
         return NULL;
@@ -1415,9 +1896,24 @@ expr_ty _PyPegen_constant_from_string(Parser* p, Token* tok) {
     PyObject *kind = NULL;
     if (the_str && the_str[0] == 'u') {
         kind = _PyPegen_new_identifier(p, "u");
-        if (kind == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5723]) {
+          if ((kind == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5723\n");
+          else
+            fprintf(stderr, "reached bug index 5723\n");
+        }
+        if ((!FIXREVERTER[5723] && (kind == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     return _PyAST_Constant(s, kind, tok->lineno, tok->col_offset, tok->end_lineno, tok->end_col_offset, p->arena);
 }
@@ -1547,9 +2043,24 @@ _PyPegen_concatenate_strings(Parser *p, asdl_expr_seq *strings,
     }
 
     asdl_expr_seq* flattened = _Py_asdl_expr_seq_new(n_flattened_elements, p->arena);
-    if (flattened == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5724]) {
+      if ((flattened == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5724\n");
+      else
+        fprintf(stderr, "reached bug index 5724\n");
+    }
+    if ((!FIXREVERTER[5724] && (flattened == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* build flattened list */
     Py_ssize_t current_pos = 0;
@@ -1561,9 +2072,24 @@ _PyPegen_concatenate_strings(Parser *p, asdl_expr_seq *strings,
         } else {
             for (j = 0; j < asdl_seq_LEN(elem->v.JoinedStr.values); j++) {
                 expr_ty subvalue = asdl_seq_GET(elem->v.JoinedStr.values, j);
-                if (subvalue == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5725]) {
+                  if ((subvalue == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5725\n");
+                  else
+                    fprintf(stderr, "reached bug index 5725\n");
+                }
+                if ((!FIXREVERTER[5725] && (subvalue == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return NULL;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 asdl_seq_SET(flattened, current_pos++, subvalue);
             }
         }
@@ -1590,9 +2116,24 @@ _PyPegen_concatenate_strings(Parser *p, asdl_expr_seq *strings,
     }
 
     asdl_expr_seq* values = _Py_asdl_expr_seq_new(n_elements, p->arena);
-    if (values == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5726]) {
+      if ((values == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5726\n");
+      else
+        fprintf(stderr, "reached bug index 5726\n");
+    }
+    if ((!FIXREVERTER[5726] && (values == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* build folded list */
     _PyUnicodeWriter writer;
@@ -1633,10 +2174,25 @@ _PyPegen_concatenate_strings(Parser *p, asdl_expr_seq *strings,
                 i = j - 1;
 
                 PyObject *concat_str = _PyUnicodeWriter_Finish(&writer);
-                if (concat_str == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5727]) {
+                  if ((concat_str == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5727\n");
+                  else
+                    fprintf(stderr, "reached bug index 5727\n");
+                }
+                if ((!FIXREVERTER[5727] && (concat_str == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     _PyUnicodeWriter_Dealloc(&writer);
                     return NULL;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 if (_PyArena_AddPyObject(p->arena, concat_str) < 0) {
                     Py_DECREF(concat_str);
                     return NULL;
@@ -1645,9 +2201,24 @@ _PyPegen_concatenate_strings(Parser *p, asdl_expr_seq *strings,
                                        first_elem->col_offset,
                                        last_elem->end_lineno,
                                        last_elem->end_col_offset, p->arena);
-                if (elem == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5728]) {
+                  if ((elem == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5728\n");
+                  else
+                    fprintf(stderr, "reached bug index 5728\n");
+                }
+                if ((!FIXREVERTER[5728] && (elem == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return NULL;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
 
             /* Drop all empty contanst strings */
diff --git a/Parser/lexer/lexer.c b/Parser/lexer/lexer.c
index 82b0e4ee352..29efbef25a5 100644
--- a/Parser/lexer/lexer.c
+++ b/Parser/lexer/lexer.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_token.h"
 #include "pycore_unicodeobject.h"
@@ -66,9 +70,24 @@ tok_nextc(struct tok_state *tok)
             tok->col_offset++;
             return Py_CHARMASK(*tok->cur++); /* Fast path */
         }
-        if (tok->done != E_OK) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1602]) {
+          if ((tok -> done != 10 ) && !(0))
+            fprintf(stderr, "triggered bug index 1602\n");
+          else
+            fprintf(stderr, "reached bug index 1602\n");
+        }
+        if ((!FIXREVERTER[1602] && (tok -> done != 10 ))
+        #else
+        if (0
+        #endif
+        ) {
             return EOF;
         }
+        #ifdef FRCOV
+        }
+        #endif
         rc = tok->underflow(tok);
 #if defined(Py_DEBUG)
         if (tok->debug) {
@@ -189,10 +208,25 @@ _PyLexer_update_fstring_expr(struct tok_state *tok, char cur)
                 tok_mode->last_expr_buffer,
                 tok_mode->last_expr_size + size
             );
-            if (new_buffer == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[1603]) {
+              if ((new_buffer == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 1603\n");
+              else
+                fprintf(stderr, "reached bug index 1603\n");
+            }
+            if ((!FIXREVERTER[1603] && (new_buffer == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 PyMem_Free(tok_mode->last_expr_buffer);
                 goto error;
             }
+            #ifdef FRCOV
+            }
+            #endif
             tok_mode->last_expr_buffer = new_buffer;
             strncpy(tok_mode->last_expr_buffer + tok_mode->last_expr_size, tok->cur, size);
             tok_mode->last_expr_size += size;
@@ -202,9 +236,24 @@ _PyLexer_update_fstring_expr(struct tok_state *tok, char cur)
                 PyMem_Free(tok_mode->last_expr_buffer);
             }
             tok_mode->last_expr_buffer = PyMem_Malloc(size);
-            if (tok_mode->last_expr_buffer == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[1604]) {
+              if ((tok_mode -> last_expr_buffer == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 1604\n");
+              else
+                fprintf(stderr, "reached bug index 1604\n");
+            }
+            if ((!FIXREVERTER[1604] && (tok_mode -> last_expr_buffer == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto error;
             }
+            #ifdef FRCOV
+            }
+            #endif
             tok_mode->last_expr_size = size;
             tok_mode->last_expr_end = -1;
             strncpy(tok_mode->last_expr_buffer, tok->cur, size);
@@ -319,7 +368,19 @@ verify_identifier(struct tok_state *tok)
     if (tok->decoding_erred)
         return 0;
     s = PyUnicode_DecodeUTF8(tok->start, tok->cur - tok->start, NULL);
-    if (s == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1605]) {
+      if ((s == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1605\n");
+      else
+        fprintf(stderr, "reached bug index 1605\n");
+    }
+    if ((!FIXREVERTER[1605] && (s == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (PyErr_ExceptionMatches(PyExc_UnicodeDecodeError)) {
             tok->done = E_DECODE;
         }
@@ -328,12 +389,30 @@ verify_identifier(struct tok_state *tok)
         }
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_ssize_t invalid = _PyUnicode_ScanIdentifier(s);
-    if (invalid < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1606]) {
+      if ((invalid < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1606\n");
+      else
+        fprintf(stderr, "reached bug index 1606\n");
+    }
+    if ((!FIXREVERTER[1606] && (invalid < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(s);
         tok->done = E_ERROR;
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(PyUnicode_GET_LENGTH(s) > 0);
     if (invalid < PyUnicode_GET_LENGTH(s)) {
         Py_UCS4 ch = PyUnicode_READ_CHAR(s, invalid);
@@ -343,10 +422,25 @@ verify_identifier(struct tok_state *tok)
             if (s != NULL) {
                 Py_SETREF(s, PyUnicode_AsUTF8String(s));
             }
-            if (s == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[1607]) {
+              if ((s == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 1607\n");
+              else
+                fprintf(stderr, "reached bug index 1607\n");
+            }
+            if ((!FIXREVERTER[1607] && (s == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 tok->done = E_ERROR;
                 return 0;
             }
+            #ifdef FRCOV
+            }
+            #endif
             tok->cur = (char *)tok->start + PyBytes_GET_SIZE(s);
         }
         Py_DECREF(s);
@@ -484,11 +578,26 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
             }
             else if (col > tok->indstack[tok->indent]) {
                 /* Indent -- always one */
-                if (tok->indent+1 >= MAXINDENT) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[1609]) {
+                  if ((tok -> indent + 1 >= 100 ) && !(0))
+                    fprintf(stderr, "triggered bug index 1609\n");
+                  else
+                    fprintf(stderr, "reached bug index 1609\n");
+                }
+                if ((!FIXREVERTER[1609] && (tok -> indent + 1 >= 100 ))
+                #else
+                if (0
+                #endif
+                ) {
                     tok->done = E_TOODEEP;
                     tok->cur = tok->inp;
                     return MAKE_TOKEN(ERRORTOKEN);
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 if (altcol <= tok->altindstack[tok->indent]) {
                     return MAKE_TOKEN(_PyTokenizer_indenterror(tok));
                 }
@@ -631,9 +740,24 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
         }
     }
 
-    if (tok->done == E_INTERACT_STOP) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1610]) {
+      if ((tok -> done == 28 ) && !(0))
+        fprintf(stderr, "triggered bug index 1610\n");
+      else
+        fprintf(stderr, "reached bug index 1610\n");
+    }
+    if ((!FIXREVERTER[1610] && (tok -> done == 28 ))
+    #else
+    if (0
+    #endif
+    ) {
         return MAKE_TOKEN(ENDMARKER);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Check for EOF and errors now */
     if (c == EOF) {
@@ -848,9 +972,24 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
                 if (Py_ISDIGIT(c)) {
                     nonzero = 1;
                     c = tok_decimal_tail(tok);
-                    if (c == 0) {
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[1611]) {
+                      if ((c == 0 ) && !(0))
+                        fprintf(stderr, "triggered bug index 1611\n");
+                      else
+                        fprintf(stderr, "reached bug index 1611\n");
+                    }
+                    if ((!FIXREVERTER[1611] && (c == 0 ))
+                    #else
+                    if (0
+                    #endif
+                    ) {
                         return MAKE_TOKEN(ERRORTOKEN);
                     }
+                    #ifdef FRCOV
+                    }
+                    #endif
                 }
                 if (c == '.') {
                     c = tok_nextc(tok);
@@ -880,9 +1019,24 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
         else {
             /* Decimal */
             c = tok_decimal_tail(tok);
-            if (c == 0) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[1612]) {
+              if ((c == 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 1612\n");
+              else
+                fprintf(stderr, "reached bug index 1612\n");
+            }
+            if ((!FIXREVERTER[1612] && (c == 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return MAKE_TOKEN(ERRORTOKEN);
             }
+            #ifdef FRCOV
+            }
+            #endif
             {
                 /* Accept floating point numbers. */
                 if (c == '.') {
@@ -891,9 +1045,24 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
                     /* Fraction */
                     if (Py_ISDIGIT(c)) {
                         c = tok_decimal_tail(tok);
-                        if (c == 0) {
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[1613]) {
+                          if ((c == 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 1613\n");
+                          else
+                            fprintf(stderr, "reached bug index 1613\n");
+                        }
+                        if ((!FIXREVERTER[1613] && (c == 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) {
                             return MAKE_TOKEN(ERRORTOKEN);
                         }
+                        #ifdef FRCOV
+                        }
+                        #endif
                     }
                 }
                 if (c == 'e' || c == 'E') {
@@ -919,9 +1088,24 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
                         return MAKE_TOKEN(NUMBER);
                     }
                     c = tok_decimal_tail(tok);
-                    if (c == 0) {
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[1614]) {
+                      if ((c == 0 ) && !(0))
+                        fprintf(stderr, "triggered bug index 1614\n");
+                      else
+                        fprintf(stderr, "reached bug index 1614\n");
+                    }
+                    if ((!FIXREVERTER[1614] && (c == 0 ))
+                    #else
+                    if (0
+                    #endif
+                    ) {
                         return MAKE_TOKEN(ERRORTOKEN);
                     }
+                    #ifdef FRCOV
+                    }
+                    #endif
                 }
                 if (c == 'j' || c == 'J') {
                     /* Imaginary part */
@@ -974,9 +1158,24 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
 
         p_start = tok->start;
         p_end = tok->cur;
-        if (tok->tok_mode_stack_index + 1 >= MAXFSTRINGLEVEL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1615]) {
+          if ((tok -> tok_mode_stack_index + 1 >= 150 ) && !(0))
+            fprintf(stderr, "triggered bug index 1615\n");
+          else
+            fprintf(stderr, "reached bug index 1615\n");
+        }
+        if ((!FIXREVERTER[1615] && (tok -> tok_mode_stack_index + 1 >= 150 ))
+        #else
+        if (0
+        #endif
+        ) {
             return MAKE_TOKEN(_PyTokenizer_syntaxerror(tok, "too many nested f-strings"));
         }
+        #ifdef FRCOV
+        }
+        #endif
         tokenizer_mode *the_current_tok = TOK_NEXT_MODE(tok);
         the_current_tok->kind = TOK_FSTRING_MODE;
         the_current_tok->f_string_quote = quote;
@@ -1042,12 +1241,42 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
         /* Get rest of string */
         while (end_quote_size != quote_size) {
             c = tok_nextc(tok);
-            if (tok->done == E_ERROR) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[1616]) {
+              if ((tok -> done == 17 ) && !(0))
+                fprintf(stderr, "triggered bug index 1616\n");
+              else
+                fprintf(stderr, "reached bug index 1616\n");
+            }
+            if ((!FIXREVERTER[1616] && (tok -> done == 17 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return MAKE_TOKEN(ERRORTOKEN);
             }
-            if (tok->done == E_DECODE) {
+            #ifdef FRCOV
+            }
+            #endif
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[1617]) {
+              if ((tok -> done == 22 ) && !(0))
+                fprintf(stderr, "triggered bug index 1617\n");
+              else
+                fprintf(stderr, "reached bug index 1617\n");
+            }
+            if ((!FIXREVERTER[1617] && (tok -> done == 22 ))
+            #else
+            if (0
+            #endif
+            ) {
                 break;
             }
+            #ifdef FRCOV
+            }
+            #endif
             if (c == EOF || (quote_size == 1 && c == '\n')) {
                 assert(tok->multi_line_start != NULL);
                 // shift the tok_state's location into
@@ -1177,9 +1406,24 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
     case '(':
     case '[':
     case '{':
-        if (tok->level >= MAXLEVEL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1618]) {
+          if ((tok -> level >= 200 ) && !(0))
+            fprintf(stderr, "triggered bug index 1618\n");
+          else
+            fprintf(stderr, "reached bug index 1618\n");
+        }
+        if ((!FIXREVERTER[1618] && (tok -> level >= 200 ))
+        #else
+        if (0
+        #endif
+        ) {
             return MAKE_TOKEN(_PyTokenizer_syntaxerror(tok, "too many nested parentheses"));
         }
+        #ifdef FRCOV
+        }
+        #endif
         tok->parenstack[tok->level] = c;
         tok->parenlinenostack[tok->level] = tok->lineno;
         tok->parencolstack[tok->level] = (int)(tok->start - tok->line_start);
@@ -1211,9 +1455,24 @@ tok_get_normal_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct t
                 if (INSIDE_FSTRING(tok) && opening == '{') {
                     assert(current_tok->curly_bracket_depth >= 0);
                     int previous_bracket = current_tok->curly_bracket_depth - 1;
-                    if (previous_bracket == current_tok->curly_bracket_expr_start_depth) {
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[1619]) {
+                      if ((previous_bracket == current_tok -> curly_bracket_expr_start_depth ) && !(0))
+                        fprintf(stderr, "triggered bug index 1619\n");
+                      else
+                        fprintf(stderr, "reached bug index 1619\n");
+                    }
+                    if ((!FIXREVERTER[1619] && (previous_bracket == current_tok -> curly_bracket_expr_start_depth ))
+                    #else
+                    if (0
+                    #endif
+                    ) {
                         return MAKE_TOKEN(_PyTokenizer_syntaxerror(tok, "f-string: unmatched '%c'", c));
                     }
+                    #ifdef FRCOV
+                    }
+                    #endif
                 }
                 if (tok->parenlinenostack[tok->level] != tok->lineno) {
                     return MAKE_TOKEN(_PyTokenizer_syntaxerror(tok,
@@ -1278,9 +1537,24 @@ tok_get_fstring_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct
         tok_backup(tok, start_char);
         if (peek1 != '{') {
             current_tok->curly_bracket_expr_start_depth++;
-            if (current_tok->curly_bracket_expr_start_depth >= MAX_EXPR_NESTING) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[1620]) {
+              if ((current_tok -> curly_bracket_expr_start_depth >= 3 ) && !(0))
+                fprintf(stderr, "triggered bug index 1620\n");
+              else
+                fprintf(stderr, "reached bug index 1620\n");
+            }
+            if ((!FIXREVERTER[1620] && (current_tok -> curly_bracket_expr_start_depth >= 3 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return MAKE_TOKEN(_PyTokenizer_syntaxerror(tok, "f-string: expressions nested too deeply"));
             }
+            #ifdef FRCOV
+            }
+            #endif
             TOK_GET_MODE(tok)->kind = TOK_REGULAR_MODE;
             return tok_get_normal_mode(tok, current_tok, token);
         }
@@ -1317,9 +1591,24 @@ tok_get_fstring_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct
     tok->multi_line_start = tok->line_start;
     while (end_quote_size != current_tok->f_string_quote_size) {
         int c = tok_nextc(tok);
-        if (tok->done == E_ERROR) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1621]) {
+          if ((tok -> done == 17 ) && !(0))
+            fprintf(stderr, "triggered bug index 1621\n");
+          else
+            fprintf(stderr, "reached bug index 1621\n");
+        }
+        if ((!FIXREVERTER[1621] && (tok -> done == 17 ))
+        #else
+        if (0
+        #endif
+        ) {
             return MAKE_TOKEN(ERRORTOKEN);
         }
+        #ifdef FRCOV
+        }
+        #endif
         int in_format_spec = (
                 current_tok->last_expr_end != -1
                 &&
@@ -1383,9 +1672,24 @@ tok_get_fstring_mode(struct tok_state *tok, tokenizer_mode* current_tok, struct
                 tok_backup(tok, peek);
                 tok_backup(tok, c);
                 current_tok->curly_bracket_expr_start_depth++;
-                if (current_tok->curly_bracket_expr_start_depth >= MAX_EXPR_NESTING) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[1622]) {
+                  if ((current_tok -> curly_bracket_expr_start_depth >= 3 ) && !(0))
+                    fprintf(stderr, "triggered bug index 1622\n");
+                  else
+                    fprintf(stderr, "reached bug index 1622\n");
+                }
+                if ((!FIXREVERTER[1622] && (current_tok -> curly_bracket_expr_start_depth >= 3 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return MAKE_TOKEN(_PyTokenizer_syntaxerror(tok, "f-string: expressions nested too deeply"));
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 TOK_GET_MODE(tok)->kind = TOK_REGULAR_MODE;
                 p_start = tok->start;
                 p_end = tok->cur;
diff --git a/Parser/lexer/state.c b/Parser/lexer/state.c
index 653ddafd411..00a28ce89dd 100644
--- a/Parser/lexer/state.c
+++ b/Parser/lexer/state.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_pystate.h"
 #include "pycore_token.h"
@@ -14,8 +18,23 @@ _PyTokenizer_tok_new(void)
 {
     struct tok_state *tok = (struct tok_state *)PyMem_Malloc(
                                             sizeof(struct tok_state));
-    if (tok == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3061]) {
+      if ((tok == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3061\n");
+      else
+        fprintf(stderr, "reached bug index 3061\n");
+    }
+    if ((!FIXREVERTER[3061] && (tok == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     tok->buf = tok->cur = tok->inp = NULL;
     tok->fp_interactive = 0;
     tok->interactive_src_start = NULL;
@@ -141,9 +160,27 @@ _PyLexer_token_setup(struct tok_state *tok, struct token *token, int type, const
     token->start = start;
     token->end = end;
 
-    if (start != NULL && end != NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3062]) {
+      fprintf(stderr, "reached bug index 3062\n");
+    }
+    if ((FIXREVERTER[3062] && (start != (void *) 0 )) || (!FIXREVERTER[3062] && (start != (void *) 0 && end != (void *) 0 ))
+    #else
+    if (start != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(end != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 3062\n");
+      #endif
+    
         token->col_offset = tok->starting_col_offset;
         token->end_col_offset = tok->col_offset;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return type;
 }
diff --git a/Parser/parser.c b/Parser/parser.c
index cbbe9a9be87..d7369252e36 100644
--- a/Parser/parser.c
+++ b/Parser/parser.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 // @generated by pegen from python.gram
 #include "pegen.h"
 
@@ -1543,10 +1547,25 @@ statement_newline_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ statement_newline[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NEWLINE"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5372]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5372\n");
+              else
+                fprintf(stderr, "reached bug index 5372\n");
+            }
+            if ((!FIXREVERTER[5372] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -1765,10 +1784,25 @@ simple_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expressions"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5373]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5373\n");
+              else
+                fprintf(stderr, "reached bug index 5373\n");
+            }
+            if ((!FIXREVERTER[5373] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -1861,10 +1895,25 @@ simple_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'pass'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5374]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5374\n");
+              else
+                fprintf(stderr, "reached bug index 5374\n");
+            }
+            if ((!FIXREVERTER[5374] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -1957,10 +2006,25 @@ simple_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'break'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5375]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5375\n");
+              else
+                fprintf(stderr, "reached bug index 5375\n");
+            }
+            if ((!FIXREVERTER[5375] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -1990,10 +2054,25 @@ simple_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ simple_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'continue'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5376]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5376\n");
+              else
+                fprintf(stderr, "reached bug index 5376\n");
+            }
+            if ((!FIXREVERTER[5376] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -2301,10 +2380,25 @@ assignment_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME ':' expression ['=' annotated_rhs]"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5377]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5377\n");
+              else
+                fprintf(stderr, "reached bug index 5377\n");
+            }
+            if ((!FIXREVERTER[5377] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -2343,10 +2437,25 @@ assignment_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' annotated_rhs]"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5378]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5378\n");
+              else
+                fprintf(stderr, "reached bug index 5378\n");
+            }
+            if ((!FIXREVERTER[5378] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -2384,10 +2493,25 @@ assignment_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "((star_targets '='))+ (yield_expr | star_expressions) !'=' TYPE_COMMENT?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5379]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5379\n");
+              else
+                fprintf(stderr, "reached bug index 5379\n");
+            }
+            if ((!FIXREVERTER[5379] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -2426,10 +2550,25 @@ assignment_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ assignment[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "single_target augassign ~ (yield_expr | star_expressions)"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5380]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5380\n");
+              else
+                fprintf(stderr, "reached bug index 5380\n");
+            }
+            if ((!FIXREVERTER[5380] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -2914,10 +3053,25 @@ return_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ return_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'return' star_expressions?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5381]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5381\n");
+              else
+                fprintf(stderr, "reached bug index 5381\n");
+            }
+            if ((!FIXREVERTER[5381] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -2981,10 +3135,25 @@ raise_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ raise_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'raise' expression ['from' expression]"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5382]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5382\n");
+              else
+                fprintf(stderr, "reached bug index 5382\n");
+            }
+            if ((!FIXREVERTER[5382] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3014,10 +3183,25 @@ raise_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ raise_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'raise'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5383]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5383\n");
+              else
+                fprintf(stderr, "reached bug index 5383\n");
+            }
+            if ((!FIXREVERTER[5383] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3078,10 +3262,25 @@ global_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ global_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'global' ','.NAME+"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5384]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5384\n");
+              else
+                fprintf(stderr, "reached bug index 5384\n");
+            }
+            if ((!FIXREVERTER[5384] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3142,10 +3341,25 @@ nonlocal_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ nonlocal_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'nonlocal' ','.NAME+"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5385]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5385\n");
+              else
+                fprintf(stderr, "reached bug index 5385\n");
+            }
+            if ((!FIXREVERTER[5385] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3208,10 +3422,25 @@ del_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ del_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'del' del_targets &(';' | NEWLINE)"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5386]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5386\n");
+              else
+                fprintf(stderr, "reached bug index 5386\n");
+            }
+            if ((!FIXREVERTER[5386] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3288,10 +3517,25 @@ yield_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ yield_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "yield_expr"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5387]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5387\n");
+              else
+                fprintf(stderr, "reached bug index 5387\n");
+            }
+            if ((!FIXREVERTER[5387] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3355,10 +3599,25 @@ assert_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ assert_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'assert' expression [',' expression]"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5388]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5388\n");
+              else
+                fprintf(stderr, "reached bug index 5388\n");
+            }
+            if ((!FIXREVERTER[5388] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3495,10 +3754,25 @@ import_name_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ import_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'import' dotted_as_names"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5389]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5389\n");
+              else
+                fprintf(stderr, "reached bug index 5389\n");
+            }
+            if ((!FIXREVERTER[5389] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3570,10 +3844,25 @@ import_from_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ import_from[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5390]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5390\n");
+              else
+                fprintf(stderr, "reached bug index 5390\n");
+            }
+            if ((!FIXREVERTER[5390] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3612,10 +3901,25 @@ import_from_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ import_from[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'from' (('.' | '...'))+ 'import' import_from_targets"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5391]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5391\n");
+              else
+                fprintf(stderr, "reached bug index 5391\n");
+            }
+            if ((!FIXREVERTER[5391] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3732,10 +4036,25 @@ import_from_targets_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ import_from_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5392]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5392\n");
+              else
+                fprintf(stderr, "reached bug index 5392\n");
+            }
+            if ((!FIXREVERTER[5392] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3858,10 +4177,25 @@ import_from_as_name_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ import_from_as_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME ['as' NAME]"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5393]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5393\n");
+              else
+                fprintf(stderr, "reached bug index 5393\n");
+            }
+            if ((!FIXREVERTER[5393] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -3965,10 +4299,25 @@ dotted_as_name_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ dotted_as_name[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "dotted_name ['as' NAME]"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5394]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5394\n");
+              else
+                fprintf(stderr, "reached bug index 5394\n");
+            }
+            if ((!FIXREVERTER[5394] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -4019,8 +4368,23 @@ dotted_name_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5395]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5395\n");
+          else
+            fprintf(stderr, "reached bug index 5395\n");
+        }
+        if ((!FIXREVERTER[5395] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -4369,10 +4733,25 @@ class_def_raw_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ class_def_raw[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'class' NAME type_params? ['(' arguments? ')'] ':' block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5396]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5396\n");
+              else
+                fprintf(stderr, "reached bug index 5396\n");
+            }
+            if ((!FIXREVERTER[5396] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -4544,10 +4923,25 @@ function_def_raw_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ function_def_raw[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'def' NAME type_params? '(' params? ')' ['->' expression] ':' func_type_comment? block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5397]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5397\n");
+              else
+                fprintf(stderr, "reached bug index 5397\n");
+            }
+            if ((!FIXREVERTER[5397] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -4607,10 +5001,25 @@ function_def_raw_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ function_def_raw[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'async' 'def' NAME type_params? '(' params? ')' ['->' expression] ':' func_type_comment? block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5398]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5398\n");
+              else
+                fprintf(stderr, "reached bug index 5398\n");
+            }
+            if ((!FIXREVERTER[5398] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -5619,10 +6028,25 @@ param_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ param[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME annotation?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5399]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5399\n");
+              else
+                fprintf(stderr, "reached bug index 5399\n");
+            }
+            if ((!FIXREVERTER[5399] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -5683,10 +6107,25 @@ param_star_annotation_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ param_star_annotation[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME star_annotation"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5400]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5400\n");
+              else
+                fprintf(stderr, "reached bug index 5400\n");
+            }
+            if ((!FIXREVERTER[5400] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -5935,10 +6374,25 @@ if_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ if_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block elif_stmt"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5401]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5401\n");
+              else
+                fprintf(stderr, "reached bug index 5401\n");
+            }
+            if ((!FIXREVERTER[5401] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -5980,10 +6434,25 @@ if_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ if_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'if' named_expression ':' block else_block?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5402]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5402\n");
+              else
+                fprintf(stderr, "reached bug index 5402\n");
+            }
+            if ((!FIXREVERTER[5402] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6075,10 +6544,25 @@ elif_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ elif_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block elif_stmt"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5403]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5403\n");
+              else
+                fprintf(stderr, "reached bug index 5403\n");
+            }
+            if ((!FIXREVERTER[5403] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6120,10 +6604,25 @@ elif_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ elif_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'elif' named_expression ':' block else_block?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5404]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5404\n");
+              else
+                fprintf(stderr, "reached bug index 5404\n");
+            }
+            if ((!FIXREVERTER[5404] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6280,10 +6779,25 @@ while_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ while_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'while' named_expression ':' block else_block?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5405]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5405\n");
+              else
+                fprintf(stderr, "reached bug index 5405\n");
+            }
+            if ((!FIXREVERTER[5405] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6388,10 +6902,25 @@ for_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5406]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5406\n");
+              else
+                fprintf(stderr, "reached bug index 5406\n");
+            }
+            if ((!FIXREVERTER[5406] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6452,10 +6981,25 @@ for_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ for_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5407]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5407\n");
+              else
+                fprintf(stderr, "reached bug index 5407\n");
+            }
+            if ((!FIXREVERTER[5407] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6583,10 +7127,25 @@ with_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'with' '(' ','.with_item+ ','? ')' ':' TYPE_COMMENT? block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5408]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5408\n");
+              else
+                fprintf(stderr, "reached bug index 5408\n");
+            }
+            if ((!FIXREVERTER[5408] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6628,10 +7187,25 @@ with_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5409]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5409\n");
+              else
+                fprintf(stderr, "reached bug index 5409\n");
+            }
+            if ((!FIXREVERTER[5409] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6683,10 +7257,25 @@ with_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'async' 'with' '(' ','.with_item+ ','? ')' ':' block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5410]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5410\n");
+              else
+                fprintf(stderr, "reached bug index 5410\n");
+            }
+            if ((!FIXREVERTER[5410] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6731,10 +7320,25 @@ with_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ with_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5411]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5411\n");
+              else
+                fprintf(stderr, "reached bug index 5411\n");
+            }
+            if ((!FIXREVERTER[5411] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6940,10 +7544,25 @@ try_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ try_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'try' &&':' block finally_block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5412]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5412\n");
+              else
+                fprintf(stderr, "reached bug index 5412\n");
+            }
+            if ((!FIXREVERTER[5412] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -6988,10 +7607,25 @@ try_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ try_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'try' &&':' block except_block+ else_block? finally_block?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5413]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5413\n");
+              else
+                fprintf(stderr, "reached bug index 5413\n");
+            }
+            if ((!FIXREVERTER[5413] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7036,10 +7670,25 @@ try_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ try_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'try' &&':' block except_star_block+ else_block? finally_block?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5414]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5414\n");
+              else
+                fprintf(stderr, "reached bug index 5414\n");
+            }
+            if ((!FIXREVERTER[5414] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7132,10 +7781,25 @@ except_block_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ except_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'except' expression ['as' NAME] ':' block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5415]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5415\n");
+              else
+                fprintf(stderr, "reached bug index 5415\n");
+            }
+            if ((!FIXREVERTER[5415] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7171,10 +7835,25 @@ except_block_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ except_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'except' ':' block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5416]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5416\n");
+              else
+                fprintf(stderr, "reached bug index 5416\n");
+            }
+            if ((!FIXREVERTER[5416] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7288,10 +7967,25 @@ except_star_block_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ except_star_block[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'except' '*' expression ['as' NAME] ':' block"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5417]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5417\n");
+              else
+                fprintf(stderr, "reached bug index 5417\n");
+            }
+            if ((!FIXREVERTER[5417] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7456,10 +8150,25 @@ match_stmt_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ match_stmt[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5418]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5418\n");
+              else
+                fprintf(stderr, "reached bug index 5418\n");
+            }
+            if ((!FIXREVERTER[5418] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7542,10 +8251,25 @@ subject_expr_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ subject_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_named_expression ',' star_named_expressions?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5419]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5419\n");
+              else
+                fprintf(stderr, "reached bug index 5419\n");
+            }
+            if ((!FIXREVERTER[5419] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7742,10 +8466,25 @@ patterns_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ patterns[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "open_sequence_pattern"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5420]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5420\n");
+              else
+                fprintf(stderr, "reached bug index 5420\n");
+            }
+            if ((!FIXREVERTER[5420] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7885,10 +8624,25 @@ as_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ as_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "or_pattern 'as' pattern_capture_target"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5421]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5421\n");
+              else
+                fprintf(stderr, "reached bug index 5421\n");
+            }
+            if ((!FIXREVERTER[5421] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -7965,10 +8719,25 @@ or_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ or_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'|'.closed_pattern+"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5422]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5422\n");
+              else
+                fprintf(stderr, "reached bug index 5422\n");
+            }
+            if ((!FIXREVERTER[5422] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8218,10 +8987,25 @@ literal_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "signed_number !('+' | '-')"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5423]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5423\n");
+              else
+                fprintf(stderr, "reached bug index 5423\n");
+            }
+            if ((!FIXREVERTER[5423] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8251,10 +9035,25 @@ literal_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "complex_number"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5424]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5424\n");
+              else
+                fprintf(stderr, "reached bug index 5424\n");
+            }
+            if ((!FIXREVERTER[5424] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8284,10 +9083,25 @@ literal_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "strings"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5425]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5425\n");
+              else
+                fprintf(stderr, "reached bug index 5425\n");
+            }
+            if ((!FIXREVERTER[5425] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8317,10 +9131,25 @@ literal_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5426]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5426\n");
+              else
+                fprintf(stderr, "reached bug index 5426\n");
+            }
+            if ((!FIXREVERTER[5426] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8350,10 +9179,25 @@ literal_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5427]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5427\n");
+              else
+                fprintf(stderr, "reached bug index 5427\n");
+            }
+            if ((!FIXREVERTER[5427] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8383,10 +9227,25 @@ literal_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5428]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5428\n");
+              else
+                fprintf(stderr, "reached bug index 5428\n");
+            }
+            if ((!FIXREVERTER[5428] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8509,10 +9368,25 @@ literal_expr_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5429]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5429\n");
+              else
+                fprintf(stderr, "reached bug index 5429\n");
+            }
+            if ((!FIXREVERTER[5429] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8542,10 +9416,25 @@ literal_expr_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5430]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5430\n");
+              else
+                fprintf(stderr, "reached bug index 5430\n");
+            }
+            if ((!FIXREVERTER[5430] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8575,10 +9464,25 @@ literal_expr_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ literal_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5431]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5431\n");
+              else
+                fprintf(stderr, "reached bug index 5431\n");
+            }
+            if ((!FIXREVERTER[5431] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8644,10 +9548,25 @@ complex_number_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ complex_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "signed_real_number '+' imaginary_number"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5432]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5432\n");
+              else
+                fprintf(stderr, "reached bug index 5432\n");
+            }
+            if ((!FIXREVERTER[5432] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8683,10 +9602,25 @@ complex_number_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ complex_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "signed_real_number '-' imaginary_number"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5433]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5433\n");
+              else
+                fprintf(stderr, "reached bug index 5433\n");
+            }
+            if ((!FIXREVERTER[5433] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8766,10 +9700,25 @@ signed_number_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ signed_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'-' NUMBER"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5434]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5434\n");
+              else
+                fprintf(stderr, "reached bug index 5434\n");
+            }
+            if ((!FIXREVERTER[5434] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8849,10 +9798,25 @@ signed_real_number_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ signed_real_number[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'-' real_number"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5435]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5435\n");
+              else
+                fprintf(stderr, "reached bug index 5435\n");
+            }
+            if ((!FIXREVERTER[5435] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -8996,10 +9960,25 @@ capture_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ capture_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "pattern_capture_target"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5436]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5436\n");
+              else
+                fprintf(stderr, "reached bug index 5436\n");
+            }
+            if ((!FIXREVERTER[5436] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9104,10 +10083,25 @@ wildcard_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ wildcard_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "\"_\""));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5437]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5437\n");
+              else
+                fprintf(stderr, "reached bug index 5437\n");
+            }
+            if ((!FIXREVERTER[5437] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9167,10 +10161,25 @@ value_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ value_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "attr !('.' | '(' | '=')"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5438]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5438\n");
+              else
+                fprintf(stderr, "reached bug index 5438\n");
+            }
+            if ((!FIXREVERTER[5438] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9221,8 +10230,23 @@ attr_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5439]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5439\n");
+          else
+            fprintf(stderr, "reached bug index 5439\n");
+        }
+        if ((!FIXREVERTER[5439] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -9270,10 +10294,25 @@ attr_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ attr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "name_or_attr '.' NAME"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5440]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5440\n");
+              else
+                fprintf(stderr, "reached bug index 5440\n");
+            }
+            if ((!FIXREVERTER[5440] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9444,10 +10483,25 @@ sequence_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ sequence_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' maybe_sequence_pattern? ']'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5441]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5441\n");
+              else
+                fprintf(stderr, "reached bug index 5441\n");
+            }
+            if ((!FIXREVERTER[5441] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9483,10 +10537,25 @@ sequence_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ sequence_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' open_sequence_pattern? ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5442]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5442\n");
+              else
+                fprintf(stderr, "reached bug index 5442\n");
+            }
+            if ((!FIXREVERTER[5442] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9704,10 +10773,25 @@ star_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' pattern_capture_target"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5443]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5443\n");
+              else
+                fprintf(stderr, "reached bug index 5443\n");
+            }
+            if ((!FIXREVERTER[5443] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9740,10 +10824,25 @@ star_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' wildcard_pattern"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5444]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5444\n");
+              else
+                fprintf(stderr, "reached bug index 5444\n");
+            }
+            if ((!FIXREVERTER[5444] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9809,10 +10908,25 @@ mapping_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ mapping_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5445]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5445\n");
+              else
+                fprintf(stderr, "reached bug index 5445\n");
+            }
+            if ((!FIXREVERTER[5445] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9852,10 +10966,25 @@ mapping_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ mapping_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' double_star_pattern ','? '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5446]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5446\n");
+              else
+                fprintf(stderr, "reached bug index 5446\n");
+            }
+            if ((!FIXREVERTER[5446] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9901,10 +11030,25 @@ mapping_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ mapping_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' items_pattern ',' double_star_pattern ','? '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5447]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5447\n");
+              else
+                fprintf(stderr, "reached bug index 5447\n");
+            }
+            if ((!FIXREVERTER[5447] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -9944,10 +11088,25 @@ mapping_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ mapping_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' items_pattern ','? '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5448]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5448\n");
+              else
+                fprintf(stderr, "reached bug index 5448\n");
+            }
+            if ((!FIXREVERTER[5448] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -10149,10 +11308,25 @@ class_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ class_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "name_or_attr '(' ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5449]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5449\n");
+              else
+                fprintf(stderr, "reached bug index 5449\n");
+            }
+            if ((!FIXREVERTER[5449] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -10195,10 +11369,25 @@ class_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ class_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "name_or_attr '(' positional_patterns ','? ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5450]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5450\n");
+              else
+                fprintf(stderr, "reached bug index 5450\n");
+            }
+            if ((!FIXREVERTER[5450] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -10241,10 +11430,25 @@ class_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ class_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "name_or_attr '(' keyword_patterns ','? ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5451]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5451\n");
+              else
+                fprintf(stderr, "reached bug index 5451\n");
+            }
+            if ((!FIXREVERTER[5451] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -10293,10 +11497,25 @@ class_pattern_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ class_pattern[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5452]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5452\n");
+              else
+                fprintf(stderr, "reached bug index 5452\n");
+            }
+            if ((!FIXREVERTER[5452] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -10515,10 +11734,25 @@ type_alias_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ type_alias[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "\"type\" NAME type_params? '=' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5453]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5453\n");
+              else
+                fprintf(stderr, "reached bug index 5453\n");
+            }
+            if ((!FIXREVERTER[5453] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -10705,10 +11939,25 @@ type_param_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ type_param[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME type_param_bound? type_param_default?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5454]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5454\n");
+              else
+                fprintf(stderr, "reached bug index 5454\n");
+            }
+            if ((!FIXREVERTER[5454] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -10763,10 +12012,25 @@ type_param_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ type_param[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' NAME type_param_starred_default?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5455]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5455\n");
+              else
+                fprintf(stderr, "reached bug index 5455\n");
+            }
+            if ((!FIXREVERTER[5455] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -10802,10 +12066,25 @@ type_param_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ type_param[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**' NAME type_param_default?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5456]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5456\n");
+              else
+                fprintf(stderr, "reached bug index 5456\n");
+            }
+            if ((!FIXREVERTER[5456] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11009,10 +12288,25 @@ expressions_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression ((',' expression))+ ','?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5457]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5457\n");
+              else
+                fprintf(stderr, "reached bug index 5457\n");
+            }
+            if ((!FIXREVERTER[5457] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11045,10 +12339,25 @@ expressions_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression ','"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5458]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5458\n");
+              else
+                fprintf(stderr, "reached bug index 5458\n");
+            }
+            if ((!FIXREVERTER[5458] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11184,10 +12493,25 @@ expression_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "disjunction 'if' disjunction 'else' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5459]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5459\n");
+              else
+                fprintf(stderr, "reached bug index 5459\n");
+            }
+            if ((!FIXREVERTER[5459] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11290,10 +12614,25 @@ yield_expr_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ yield_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'yield' 'from' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5460]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5460\n");
+              else
+                fprintf(stderr, "reached bug index 5460\n");
+            }
+            if ((!FIXREVERTER[5460] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11326,10 +12665,25 @@ yield_expr_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ yield_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'yield' star_expressions?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5461]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5461\n");
+              else
+                fprintf(stderr, "reached bug index 5461\n");
+            }
+            if ((!FIXREVERTER[5461] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11397,10 +12751,25 @@ star_expressions_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expression ((',' star_expression))+ ','?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5462]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5462\n");
+              else
+                fprintf(stderr, "reached bug index 5462\n");
+            }
+            if ((!FIXREVERTER[5462] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11433,10 +12802,25 @@ star_expressions_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_expressions[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_expression ','"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5463]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5463\n");
+              else
+                fprintf(stderr, "reached bug index 5463\n");
+            }
+            if ((!FIXREVERTER[5463] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11520,10 +12904,25 @@ star_expression_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' bitwise_or"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5464]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5464\n");
+              else
+                fprintf(stderr, "reached bug index 5464\n");
+            }
+            if ((!FIXREVERTER[5464] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11651,10 +13050,25 @@ star_named_expression_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_named_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' bitwise_or"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5465]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5465\n");
+              else
+                fprintf(stderr, "reached bug index 5465\n");
+            }
+            if ((!FIXREVERTER[5465] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11740,10 +13154,25 @@ assignment_expression_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ assignment_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME ':=' ~ expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5466]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5466\n");
+              else
+                fprintf(stderr, "reached bug index 5466\n");
+            }
+            if ((!FIXREVERTER[5466] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11890,10 +13319,25 @@ disjunction_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ disjunction[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "conjunction (('or' conjunction))+"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5467]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5467\n");
+              else
+                fprintf(stderr, "reached bug index 5467\n");
+            }
+            if ((!FIXREVERTER[5467] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -11978,10 +13422,25 @@ conjunction_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ conjunction[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "inversion (('and' inversion))+"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5468]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5468\n");
+              else
+                fprintf(stderr, "reached bug index 5468\n");
+            }
+            if ((!FIXREVERTER[5468] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -12066,10 +13525,25 @@ inversion_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ inversion[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'not' inversion"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5469]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5469\n");
+              else
+                fprintf(stderr, "reached bug index 5469\n");
+            }
+            if ((!FIXREVERTER[5469] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -12150,10 +13624,25 @@ comparison_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ comparison[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_or compare_op_bitwise_or_pair+"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5470]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5470\n");
+              else
+                fprintf(stderr, "reached bug index 5470\n");
+            }
+            if ((!FIXREVERTER[5470] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -12908,8 +14397,23 @@ bitwise_or_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5471]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5471\n");
+          else
+            fprintf(stderr, "reached bug index 5471\n");
+        }
+        if ((!FIXREVERTER[5471] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -12957,10 +14461,25 @@ bitwise_or_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ bitwise_or[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_or '|' bitwise_xor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5472]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5472\n");
+              else
+                fprintf(stderr, "reached bug index 5472\n");
+            }
+            if ((!FIXREVERTER[5472] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13030,8 +14549,23 @@ bitwise_xor_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5473]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5473\n");
+          else
+            fprintf(stderr, "reached bug index 5473\n");
+        }
+        if ((!FIXREVERTER[5473] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -13079,10 +14613,25 @@ bitwise_xor_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ bitwise_xor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_xor '^' bitwise_and"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5474]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5474\n");
+              else
+                fprintf(stderr, "reached bug index 5474\n");
+            }
+            if ((!FIXREVERTER[5474] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13152,8 +14701,23 @@ bitwise_and_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5475]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5475\n");
+          else
+            fprintf(stderr, "reached bug index 5475\n");
+        }
+        if ((!FIXREVERTER[5475] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -13201,10 +14765,25 @@ bitwise_and_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ bitwise_and[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "bitwise_and '&' shift_expr"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5476]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5476\n");
+              else
+                fprintf(stderr, "reached bug index 5476\n");
+            }
+            if ((!FIXREVERTER[5476] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13274,8 +14853,23 @@ shift_expr_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5477]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5477\n");
+          else
+            fprintf(stderr, "reached bug index 5477\n");
+        }
+        if ((!FIXREVERTER[5477] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -13323,10 +14917,25 @@ shift_expr_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ shift_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "shift_expr '<<' sum"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5478]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5478\n");
+              else
+                fprintf(stderr, "reached bug index 5478\n");
+            }
+            if ((!FIXREVERTER[5478] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13362,10 +14971,25 @@ shift_expr_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ shift_expr[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "shift_expr '>>' sum"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5479]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5479\n");
+              else
+                fprintf(stderr, "reached bug index 5479\n");
+            }
+            if ((!FIXREVERTER[5479] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13454,8 +15078,23 @@ sum_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5480]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5480\n");
+          else
+            fprintf(stderr, "reached bug index 5480\n");
+        }
+        if ((!FIXREVERTER[5480] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -13503,10 +15142,25 @@ sum_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ sum[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sum '+' term"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5481]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5481\n");
+              else
+                fprintf(stderr, "reached bug index 5481\n");
+            }
+            if ((!FIXREVERTER[5481] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13542,10 +15196,25 @@ sum_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ sum[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "sum '-' term"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5482]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5482\n");
+              else
+                fprintf(stderr, "reached bug index 5482\n");
+            }
+            if ((!FIXREVERTER[5482] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13622,8 +15291,23 @@ term_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5483]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5483\n");
+          else
+            fprintf(stderr, "reached bug index 5483\n");
+        }
+        if ((!FIXREVERTER[5483] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -13671,10 +15355,25 @@ term_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '*' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5484]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5484\n");
+              else
+                fprintf(stderr, "reached bug index 5484\n");
+            }
+            if ((!FIXREVERTER[5484] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13710,10 +15409,25 @@ term_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '/' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5485]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5485\n");
+              else
+                fprintf(stderr, "reached bug index 5485\n");
+            }
+            if ((!FIXREVERTER[5485] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13749,10 +15463,25 @@ term_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '//' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5486]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5486\n");
+              else
+                fprintf(stderr, "reached bug index 5486\n");
+            }
+            if ((!FIXREVERTER[5486] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13788,10 +15517,25 @@ term_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '%' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5487]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5487\n");
+              else
+                fprintf(stderr, "reached bug index 5487\n");
+            }
+            if ((!FIXREVERTER[5487] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13827,10 +15571,25 @@ term_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ term[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "term '@' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5488]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5488\n");
+              else
+                fprintf(stderr, "reached bug index 5488\n");
+            }
+            if ((!FIXREVERTER[5488] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13933,10 +15692,25 @@ factor_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ factor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'+' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5489]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5489\n");
+              else
+                fprintf(stderr, "reached bug index 5489\n");
+            }
+            if ((!FIXREVERTER[5489] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -13969,10 +15743,25 @@ factor_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ factor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'-' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5490]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5490\n");
+              else
+                fprintf(stderr, "reached bug index 5490\n");
+            }
+            if ((!FIXREVERTER[5490] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14005,10 +15794,25 @@ factor_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ factor[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'~' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5491]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5491\n");
+              else
+                fprintf(stderr, "reached bug index 5491\n");
+            }
+            if ((!FIXREVERTER[5491] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14092,10 +15896,25 @@ power_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ power[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "await_primary '**' factor"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5492]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5492\n");
+              else
+                fprintf(stderr, "reached bug index 5492\n");
+            }
+            if ((!FIXREVERTER[5492] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14179,10 +15998,25 @@ await_primary_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ await_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'await' primary"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5493]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5493\n");
+              else
+                fprintf(stderr, "reached bug index 5493\n");
+            }
+            if ((!FIXREVERTER[5493] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14258,8 +16092,23 @@ primary_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5494]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5494\n");
+          else
+            fprintf(stderr, "reached bug index 5494\n");
+        }
+        if ((!FIXREVERTER[5494] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -14307,10 +16156,25 @@ primary_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary '.' NAME"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5495]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5495\n");
+              else
+                fprintf(stderr, "reached bug index 5495\n");
+            }
+            if ((!FIXREVERTER[5495] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14343,10 +16207,25 @@ primary_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary genexp"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5496]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5496\n");
+              else
+                fprintf(stderr, "reached bug index 5496\n");
+            }
+            if ((!FIXREVERTER[5496] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14385,10 +16264,25 @@ primary_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary '(' arguments? ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5497]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5497\n");
+              else
+                fprintf(stderr, "reached bug index 5497\n");
+            }
+            if ((!FIXREVERTER[5497] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14427,10 +16321,25 @@ primary_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "primary '[' slices ']'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5498]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5498\n");
+              else
+                fprintf(stderr, "reached bug index 5498\n");
+            }
+            if ((!FIXREVERTER[5498] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14537,10 +16446,25 @@ slices_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ slices[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.(slice | starred_expression)+ ','?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5499]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5499\n");
+              else
+                fprintf(stderr, "reached bug index 5499\n");
+            }
+            if ((!FIXREVERTER[5499] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14607,10 +16531,25 @@ slice_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ slice[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "expression? ':' expression? [':' expression?]"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5500]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5500\n");
+              else
+                fprintf(stderr, "reached bug index 5500\n");
+            }
+            if ((!FIXREVERTER[5500] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14721,10 +16660,25 @@ atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'True'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5501]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5501\n");
+              else
+                fprintf(stderr, "reached bug index 5501\n");
+            }
+            if ((!FIXREVERTER[5501] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14754,10 +16708,25 @@ atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'False'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5502]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5502\n");
+              else
+                fprintf(stderr, "reached bug index 5502\n");
+            }
+            if ((!FIXREVERTER[5502] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14787,10 +16756,25 @@ atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'None'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5503]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5503\n");
+              else
+                fprintf(stderr, "reached bug index 5503\n");
+            }
+            if ((!FIXREVERTER[5503] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -14923,10 +16907,25 @@ atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'...'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5504]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5504\n");
+              else
+                fprintf(stderr, "reached bug index 5504\n");
+            }
+            if ((!FIXREVERTER[5504] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -15061,10 +17060,25 @@ lambdef_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ lambdef[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'lambda' lambda_params? ':' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5505]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5505\n");
+              else
+                fprintf(stderr, "reached bug index 5505\n");
+            }
+            if ((!FIXREVERTER[5505] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -15938,10 +17952,25 @@ lambda_param_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ lambda_param[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5506]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5506\n");
+              else
+                fprintf(stderr, "reached bug index 5506\n");
+            }
+            if ((!FIXREVERTER[5506] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -16078,10 +18107,25 @@ fstring_replacement_field_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ fstring_replacement_field[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' annotated_rhs '='? fstring_conversion? fstring_full_format_spec? '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5507]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5507\n");
+              else
+                fprintf(stderr, "reached bug index 5507\n");
+            }
+            if ((!FIXREVERTER[5507] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -16207,10 +18251,25 @@ fstring_full_format_spec_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ fstring_full_format_spec[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "':' fstring_format_spec*"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5508]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5508\n");
+              else
+                fprintf(stderr, "reached bug index 5508\n");
+            }
+            if ((!FIXREVERTER[5508] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -16426,10 +18485,25 @@ strings_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ strings[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "((fstring | string))+"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5509]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5509\n");
+              else
+                fprintf(stderr, "reached bug index 5509\n");
+            }
+            if ((!FIXREVERTER[5509] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -16494,10 +18568,25 @@ list_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ list[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' star_named_expressions? ']'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5510]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5510\n");
+              else
+                fprintf(stderr, "reached bug index 5510\n");
+            }
+            if ((!FIXREVERTER[5510] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -16561,10 +18650,25 @@ tuple_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ tuple[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' [star_named_expression ',' star_named_expressions?] ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5511]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5511\n");
+              else
+                fprintf(stderr, "reached bug index 5511\n");
+            }
+            if ((!FIXREVERTER[5511] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -16628,10 +18732,25 @@ set_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ set[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' star_named_expressions '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5512]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5512\n");
+              else
+                fprintf(stderr, "reached bug index 5512\n");
+            }
+            if ((!FIXREVERTER[5512] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -16695,10 +18814,25 @@ dict_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ dict[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' double_starred_kvpairs? '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5513]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5513\n");
+              else
+                fprintf(stderr, "reached bug index 5513\n");
+            }
+            if ((!FIXREVERTER[5513] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17144,10 +19278,25 @@ listcomp_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ listcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' named_expression for_if_clauses ']'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5514]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5514\n");
+              else
+                fprintf(stderr, "reached bug index 5514\n");
+            }
+            if ((!FIXREVERTER[5514] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17233,10 +19382,25 @@ setcomp_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ setcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' named_expression for_if_clauses '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5515]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5515\n");
+              else
+                fprintf(stderr, "reached bug index 5515\n");
+            }
+            if ((!FIXREVERTER[5515] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17324,10 +19488,25 @@ genexp_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ genexp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' (assignment_expression | expression !':=') for_if_clauses ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5516]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5516\n");
+              else
+                fprintf(stderr, "reached bug index 5516\n");
+            }
+            if ((!FIXREVERTER[5516] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17413,10 +19592,25 @@ dictcomp_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ dictcomp[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'{' kvpair for_if_clauses '}'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5517]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5517\n");
+              else
+                fprintf(stderr, "reached bug index 5517\n");
+            }
+            if ((!FIXREVERTER[5517] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17571,10 +19765,25 @@ args_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ args[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "','.(starred_expression | (assignment_expression | expression !':=') !'=')+ [',' kwargs]"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5518]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5518\n");
+              else
+                fprintf(stderr, "reached bug index 5518\n");
+            }
+            if ((!FIXREVERTER[5518] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17604,10 +19813,25 @@ args_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ args[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "kwargs"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5519]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5519\n");
+              else
+                fprintf(stderr, "reached bug index 5519\n");
+            }
+            if ((!FIXREVERTER[5519] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17780,10 +20004,25 @@ starred_expression_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ starred_expression[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5520]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5520\n");
+              else
+                fprintf(stderr, "reached bug index 5520\n");
+            }
+            if ((!FIXREVERTER[5520] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17885,10 +20124,25 @@ kwarg_or_starred_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ kwarg_or_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME '=' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5521]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5521\n");
+              else
+                fprintf(stderr, "reached bug index 5521\n");
+            }
+            if ((!FIXREVERTER[5521] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -17995,10 +20249,25 @@ kwarg_or_double_starred_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ kwarg_or_double_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "NAME '=' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5522]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5522\n");
+              else
+                fprintf(stderr, "reached bug index 5522\n");
+            }
+            if ((!FIXREVERTER[5522] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18031,10 +20300,25 @@ kwarg_or_double_starred_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ kwarg_or_double_starred[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'**' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5523]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5523\n");
+              else
+                fprintf(stderr, "reached bug index 5523\n");
+            }
+            if ((!FIXREVERTER[5523] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18125,10 +20409,25 @@ star_targets_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_targets[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "star_target ((',' star_target))* ','?"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5524]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5524\n");
+              else
+                fprintf(stderr, "reached bug index 5524\n");
+            }
+            if ((!FIXREVERTER[5524] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18317,10 +20616,25 @@ star_target_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'*' (!'*' star_target)"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5525]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5525\n");
+              else
+                fprintf(stderr, "reached bug index 5525\n");
+            }
+            if ((!FIXREVERTER[5525] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18413,10 +20727,25 @@ target_with_star_atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ target_with_star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5526]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5526\n");
+              else
+                fprintf(stderr, "reached bug index 5526\n");
+            }
+            if ((!FIXREVERTER[5526] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18457,10 +20786,25 @@ target_with_star_atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ target_with_star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5527]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5527\n");
+              else
+                fprintf(stderr, "reached bug index 5527\n");
+            }
+            if ((!FIXREVERTER[5527] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18602,10 +20946,25 @@ star_atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' star_targets_tuple_seq? ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5528]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5528\n");
+              else
+                fprintf(stderr, "reached bug index 5528\n");
+            }
+            if ((!FIXREVERTER[5528] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18641,10 +21000,25 @@ star_atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ star_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' star_targets_list_seq? ']'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5529]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5529\n");
+              else
+                fprintf(stderr, "reached bug index 5529\n");
+            }
+            if ((!FIXREVERTER[5529] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18804,10 +21178,25 @@ single_subscript_attribute_target_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ single_subscript_attribute_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5530]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5530\n");
+              else
+                fprintf(stderr, "reached bug index 5530\n");
+            }
+            if ((!FIXREVERTER[5530] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18848,10 +21237,25 @@ single_subscript_attribute_target_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ single_subscript_attribute_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5531]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5531\n");
+              else
+                fprintf(stderr, "reached bug index 5531\n");
+            }
+            if ((!FIXREVERTER[5531] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -18907,8 +21311,23 @@ t_primary_rule(Parser *p)
             p->level--;
             return NULL;
         }
-        if (_raw == NULL || p->mark <= _resmark)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5532]) {
+          if ((_raw == (void *) 0 || p -> mark <= _resmark ) && !(0))
+            fprintf(stderr, "triggered bug index 5532\n");
+          else
+            fprintf(stderr, "reached bug index 5532\n");
+        }
+        if ((!FIXREVERTER[5532] && (_raw == (void *) 0 || p -> mark <= _resmark ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
         _resmark = p->mark;
         _res = _raw;
     }
@@ -18958,10 +21377,25 @@ t_primary_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME &t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5533]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5533\n");
+              else
+                fprintf(stderr, "reached bug index 5533\n");
+            }
+            if ((!FIXREVERTER[5533] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -19002,10 +21436,25 @@ t_primary_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' &t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5534]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5534\n");
+              else
+                fprintf(stderr, "reached bug index 5534\n");
+            }
+            if ((!FIXREVERTER[5534] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -19040,10 +21489,25 @@ t_primary_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary genexp &t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5535]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5535\n");
+              else
+                fprintf(stderr, "reached bug index 5535\n");
+            }
+            if ((!FIXREVERTER[5535] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -19084,10 +21548,25 @@ t_primary_raw(Parser *p)
         {
             D(fprintf(stderr, "%*c+ t_primary[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '(' arguments? ')' &t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5536]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5536\n");
+              else
+                fprintf(stderr, "reached bug index 5536\n");
+            }
+            if ((!FIXREVERTER[5536] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -19309,10 +21788,25 @@ del_target_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ del_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '.' NAME !t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5537]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5537\n");
+              else
+                fprintf(stderr, "reached bug index 5537\n");
+            }
+            if ((!FIXREVERTER[5537] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -19353,10 +21847,25 @@ del_target_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ del_target[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "t_primary '[' slices ']' !t_lookahead"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5538]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5538\n");
+              else
+                fprintf(stderr, "reached bug index 5538\n");
+            }
+            if ((!FIXREVERTER[5538] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -19494,10 +22003,25 @@ del_t_atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ del_t_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'(' del_targets? ')'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5539]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5539\n");
+              else
+                fprintf(stderr, "reached bug index 5539\n");
+            }
+            if ((!FIXREVERTER[5539] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -19533,10 +22057,25 @@ del_t_atom_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ del_t_atom[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "'[' del_targets? ']'"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5540]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5540\n");
+              else
+                fprintf(stderr, "reached bug index 5540\n");
+            }
+            if ((!FIXREVERTER[5540] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
@@ -20342,11 +22881,26 @@ expression_without_invalid_rule(Parser *p)
         {
             D(fprintf(stderr, "%*c+ expression_without_invalid[%d-%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, "disjunction 'if' disjunction 'else' expression"));
             Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
-            if (_token == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5541]) {
+              if ((_token == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5541\n");
+              else
+                fprintf(stderr, "reached bug index 5541\n");
+            }
+            if ((!FIXREVERTER[5541] && (_token == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 p->call_invalid_rules = _prev_call_invalid;
                 p->level--;
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int _end_lineno = _token->end_lineno;
             UNUSED(_end_lineno); // Only used by EXTRA macro
             int _end_col_offset = _token->end_col_offset;
diff --git a/Parser/pegen.c b/Parser/pegen.c
index 6efb5477c7b..c6705ce0974 100644
--- a/Parser/pegen.c
+++ b/Parser/pegen.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include <Python.h>
 #include "pycore_ast.h"           // _PyAST_Validate(),
 #include "pycore_pystate.h"       // _PyThreadState_GET()
@@ -78,9 +82,24 @@ _PyPegen_insert_memo(Parser *p, int mark, int type, void *node)
 {
     // Insert in front
     Memo *m = _PyArena_Malloc(p->arena, sizeof(Memo));
-    if (m == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[245]) {
+      if ((m == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 245\n");
+      else
+        fprintf(stderr, "reached bug index 245\n");
+    }
+    if ((!FIXREVERTER[245] && (m == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     m->type = type;
     m->node = node;
     m->mark = p->mark;
@@ -94,12 +113,27 @@ int
 _PyPegen_update_memo(Parser *p, int mark, int type, void *node)
 {
     for (Memo *m = p->tokens[mark]->memo; m != NULL; m = m->next) {
-        if (m->type == type) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[246]) {
+          if ((m -> type == type ) && !(0))
+            fprintf(stderr, "triggered bug index 246\n");
+          else
+            fprintf(stderr, "reached bug index 246\n");
+        }
+        if ((!FIXREVERTER[246] && (m -> type == type ))
+        #else
+        if (0
+        #endif
+        ) {
             // Update existing node.
             m->node = node;
             m->mark = p->mark;
             return 0;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     // Insert new node.
     return _PyPegen_insert_memo(p, mark, type, node);
@@ -180,9 +214,24 @@ initialize_token(Parser *p, Token *parser_token, struct token *new_token, int to
 
     parser_token->type = (token_type == NAME) ? _get_keyword_or_name_type(p, new_token) : token_type;
     parser_token->bytes = PyBytes_FromStringAndSize(new_token->start, new_token->end - new_token->start);
-    if (parser_token->bytes == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[247]) {
+      if ((parser_token -> bytes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 247\n");
+      else
+        fprintf(stderr, "reached bug index 247\n");
+    }
+    if ((!FIXREVERTER[247] && (parser_token -> bytes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_PyArena_AddPyObject(p->arena, parser_token->bytes) < 0) {
         Py_DECREF(parser_token->bytes);
         return -1;
@@ -219,10 +268,25 @@ static int
 _resize_tokens_array(Parser *p) {
     int newsize = p->size * 2;
     Token **new_tokens = PyMem_Realloc(p->tokens, newsize * sizeof(Token *));
-    if (new_tokens == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[248]) {
+      if ((new_tokens == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 248\n");
+      else
+        fprintf(stderr, "reached bug index 248\n");
+    }
+    if ((!FIXREVERTER[248] && (new_tokens == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     p->tokens = new_tokens;
 
     for (int i = p->size; i < newsize; i++) {
@@ -248,10 +312,25 @@ _PyPegen_fill_token(Parser *p)
     while (type == TYPE_IGNORE) {
         Py_ssize_t len = new_token.end_col_offset - new_token.col_offset;
         char *tag = PyMem_Malloc(len + 1);
-        if (tag == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[249]) {
+          if ((tag == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 249\n");
+          else
+            fprintf(stderr, "reached bug index 249\n");
+        }
+        if ((!FIXREVERTER[249] && (tag == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             goto error;
         }
+        #ifdef FRCOV
+        }
+        #endif
         strncpy(tag, new_token.start, len);
         tag[len] = '\0';
         // Ownership of tag passes to the growable array
@@ -340,7 +419,19 @@ _PyPegen_is_memoized(Parser *p, int type, void *pres)
     Token *t = p->tokens[p->mark];
 
     for (Memo *m = t->memo; m != NULL; m = m->next) {
-        if (m->type == type) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[250]) {
+          if ((m -> type == type ) && !(0))
+            fprintf(stderr, "triggered bug index 250\n");
+          else
+            fprintf(stderr, "reached bug index 250\n");
+        }
+        if ((!FIXREVERTER[250] && (m -> type == type ))
+        #else
+        if (0
+        #endif
+        ) {
 #if defined(PY_DEBUG)
             if (0 <= type && type < NSTATISTICS) {
                 long count = m->mark - p->mark;
@@ -355,6 +446,9 @@ _PyPegen_is_memoized(Parser *p, int type, void *pres)
             *(void **)(pres) = m->node;
             return 1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     return 0;
 }
@@ -405,9 +499,24 @@ _PyPegen_expect_token(Parser *p, int type)
         }
     }
     Token *t = p->tokens[p->mark];
-    if (t->type != type) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[251]) {
+      if ((t -> type != type ) && !(0))
+        fprintf(stderr, "triggered bug index 251\n");
+      else
+        fprintf(stderr, "reached bug index 251\n");
+    }
+    if ((!FIXREVERTER[251] && (t -> type != type ))
+    #else
+    if (0
+    #endif
+    ) {
        return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     p->mark += 1;
     return t;
 }
@@ -428,9 +537,24 @@ _PyPegen_expect_forced_result(Parser *p, void* result, const char* expected) {
 Token *
 _PyPegen_expect_forced_token(Parser *p, int type, const char* expected) {
 
-    if (p->error_indicator == 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[254]) {
+      if ((p -> error_indicator == 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 254\n");
+      else
+        fprintf(stderr, "reached bug index 254\n");
+    }
+    if ((!FIXREVERTER[254] && (p -> error_indicator == 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (p->mark == p->fill) {
         if (_PyPegen_fill_token(p) < 0) {
@@ -439,10 +563,25 @@ _PyPegen_expect_forced_token(Parser *p, int type, const char* expected) {
         }
     }
     Token *t = p->tokens[p->mark];
-    if (t->type != type) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[255]) {
+      if ((t -> type != type ) && !(0))
+        fprintf(stderr, "triggered bug index 255\n");
+      else
+        fprintf(stderr, "reached bug index 255\n");
+    }
+    if ((!FIXREVERTER[255] && (t -> type != type ))
+    #else
+    if (0
+    #endif
+    ) {
         RAISE_SYNTAX_ERROR_KNOWN_LOCATION(t, "expected '%s'", expected);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     p->mark += 1;
     return t;
 }
@@ -457,9 +596,24 @@ _PyPegen_expect_soft_keyword(Parser *p, const char *keyword)
         }
     }
     Token *t = p->tokens[p->mark];
-    if (t->type != NAME) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[256]) {
+      if ((t -> type != 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 256\n");
+      else
+        fprintf(stderr, "reached bug index 256\n");
+    }
+    if ((!FIXREVERTER[256] && (t -> type != 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     const char *s = PyBytes_AsString(t->bytes);
     if (!s) {
         p->error_indicator = 1;
@@ -504,11 +658,26 @@ _PyPegen_new_identifier(Parser *p, const char *n)
             goto error;
         }
         PyObject *form = PyUnicode_InternFromString("NFKC");
-        if (form == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[257]) {
+          if ((form == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 257\n");
+          else
+            fprintf(stderr, "reached bug index 257\n");
+        }
+        if ((!FIXREVERTER[257] && (form == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
         {
             Py_DECREF(id);
             goto error;
         }
+        #ifdef FRCOV
+        }
+        #endif
         PyObject *args[2] = {form, id};
         PyObject *id2 = PyObject_Vectorcall(p->normalize, args, 2, NULL);
         Py_DECREF(id);
@@ -545,19 +714,49 @@ _PyPegen_new_identifier(Parser *p, const char *n)
 static expr_ty
 _PyPegen_name_from_token(Parser *p, Token* t)
 {
-    if (t == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[258]) {
+      if ((t == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 258\n");
+      else
+        fprintf(stderr, "reached bug index 258\n");
+    }
+    if ((!FIXREVERTER[258] && (t == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     const char *s = PyBytes_AsString(t->bytes);
     if (!s) {
         p->error_indicator = 1;
         return NULL;
     }
     PyObject *id = _PyPegen_new_identifier(p, s);
-    if (id == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[259]) {
+      if ((id == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 259\n");
+      else
+        fprintf(stderr, "reached bug index 259\n");
+    }
+    if ((!FIXREVERTER[259] && (id == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         p->error_indicator = 1;
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return _PyAST_Name(id, Load, t->lineno, t->col_offset, t->end_lineno,
                        t->end_col_offset, p->arena);
 }
@@ -649,9 +848,24 @@ parsenumber(const char *s)
     }
     /* Create a duplicate without underscores. */
     dup = PyMem_Malloc(strlen(s) + 1);
-    if (dup == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[261]) {
+      if ((dup == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 261\n");
+      else
+        fprintf(stderr, "reached bug index 261\n");
+    }
+    if ((!FIXREVERTER[261] && (dup == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     end = dup;
     for (; *s; s++) {
         if (*s != '_') {
@@ -668,15 +882,45 @@ expr_ty
 _PyPegen_number_token(Parser *p)
 {
     Token *t = _PyPegen_expect_token(p, NUMBER);
-    if (t == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[262]) {
+      if ((t == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 262\n");
+      else
+        fprintf(stderr, "reached bug index 262\n");
+    }
+    if ((!FIXREVERTER[262] && (t == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     const char *num_raw = PyBytes_AsString(t->bytes);
-    if (num_raw == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[263]) {
+      if ((num_raw == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 263\n");
+      else
+        fprintf(stderr, "reached bug index 263\n");
+    }
+    if ((!FIXREVERTER[263] && (num_raw == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         p->error_indicator = 1;
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (p->feature_version < 6 && strchr(num_raw, '_') != NULL) {
         p->error_indicator = 1;
@@ -781,9 +1025,24 @@ _PyPegen_Parser_New(struct tok_state *tok, int start_rule, int flags,
                     int feature_version, int *errcode, PyArena *arena)
 {
     Parser *p = PyMem_Malloc(sizeof(Parser));
-    if (p == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[264]) {
+      if ((p == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 264\n");
+      else
+        fprintf(stderr, "reached bug index 264\n");
+    }
+    if ((!FIXREVERTER[264] && (p == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return (Parser *) PyErr_NoMemory();
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(tok != NULL);
     tok->type_comments = (flags & PyPARSE_TYPE_COMMENTS) > 0;
     p->tok = tok;
@@ -968,12 +1227,27 @@ _PyPegen_run_parser_from_string(const char *str, int start_rule, PyObject *filen
     } else {
         tok = _PyTokenizer_FromString(str, exec_input, 0);
     }
-    if (tok == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[267]) {
+      if ((tok == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 267\n");
+      else
+        fprintf(stderr, "reached bug index 267\n");
+    }
+    if ((!FIXREVERTER[267] && (tok == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (PyErr_Occurred()) {
             _PyPegen_raise_tokenizer_init_error(filename_ob);
         }
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     // This transfers the ownership to the tokenizer
     tok->filename = Py_NewRef(filename_ob);
 
@@ -985,9 +1259,24 @@ _PyPegen_run_parser_from_string(const char *str, int start_rule, PyObject *filen
         flags->cf_feature_version : PY_MINOR_VERSION;
     Parser *p = _PyPegen_Parser_New(tok, start_rule, parser_flags, feature_version,
                                     NULL, arena);
-    if (p == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[268]) {
+      if ((p == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 268\n");
+      else
+        fprintf(stderr, "reached bug index 268\n");
+    }
+    if ((!FIXREVERTER[268] && (p == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     result = _PyPegen_run_parser(p);
     _PyPegen_Parser_Free(p);
diff --git a/Parser/string_parser.c b/Parser/string_parser.c
index 93ad92b8235..f8dc7e49347 100644
--- a/Parser/string_parser.c
+++ b/Parser/string_parser.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include <stdbool.h>
 
 #include <Python.h>
@@ -31,9 +35,24 @@ warn_invalid_escape_sequence(Parser *p, const char *first_invalid_escape, Token
         ? PyUnicode_FromFormat("invalid octal escape sequence '\\%.3s'",
                                first_invalid_escape)
         : PyUnicode_FromFormat("invalid escape sequence '\\%c'", c);
-    if (msg == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4193]) {
+      if ((msg == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4193\n");
+      else
+        fprintf(stderr, "reached bug index 4193\n");
+    }
+    if ((!FIXREVERTER[4193] && (msg == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *category;
     if (p->feature_version >= 12) {
         category = PyExc_SyntaxWarning;
@@ -90,19 +109,64 @@ decode_unicode_with_escapes(Parser *parser, const char *s, size_t len, Token *t)
     const char *end;
 
     /* check for integer overflow */
-    if (len > SIZE_MAX / 6) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4194]) {
+      if ((len > -1 / 6 ) && !(0))
+        fprintf(stderr, "triggered bug index 4194\n");
+      else
+        fprintf(stderr, "reached bug index 4194\n");
+    }
+    if ((!FIXREVERTER[4194] && (len > -1 / 6 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     /* "" (2 bytes) may become "\U000000E4" (10 bytes), or 1:5
        "\" (3 bytes) may become "\u005c\U000000E4" (16 bytes), or ~1:6 */
     u = PyBytes_FromStringAndSize((char *)NULL, len * 6);
-    if (u == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4195]) {
+      if ((u == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4195\n");
+      else
+        fprintf(stderr, "reached bug index 4195\n");
+    }
+    if ((!FIXREVERTER[4195] && (u == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     p = buf = PyBytes_AsString(u);
-    if (p == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4196]) {
+      if ((p == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4196\n");
+      else
+        fprintf(stderr, "reached bug index 4196\n");
+    }
+    if ((!FIXREVERTER[4196] && (p == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     end = s + len;
     while (s < end) {
         if (*s == '\\') {
@@ -110,9 +174,24 @@ decode_unicode_with_escapes(Parser *parser, const char *s, size_t len, Token *t)
             if (s >= end || *s & 0x80) {
                 strcpy(p, "u005c");
                 p += 5;
-                if (s >= end) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[4197]) {
+                  if ((s >= end ) && !(0))
+                    fprintf(stderr, "triggered bug index 4197\n");
+                  else
+                    fprintf(stderr, "reached bug index 4197\n");
+                }
+                if ((!FIXREVERTER[4197] && (s >= end ))
+                #else
+                if (0
+                #endif
+                ) {
                     break;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
         }
         if (*s & 0x80) {
@@ -122,10 +201,25 @@ decode_unicode_with_escapes(Parser *parser, const char *s, size_t len, Token *t)
             Py_ssize_t w_len;
             Py_ssize_t i;
             w = decode_utf8(&s, end);
-            if (w == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4198]) {
+              if ((w == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 4198\n");
+              else
+                fprintf(stderr, "reached bug index 4198\n");
+            }
+            if ((!FIXREVERTER[4198] && (w == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Py_DECREF(u);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             kind = PyUnicode_KIND(w);
             data = PyUnicode_DATA(w);
             w_len = PyUnicode_GET_LENGTH(w);
@@ -150,7 +244,22 @@ decode_unicode_with_escapes(Parser *parser, const char *s, size_t len, Token *t)
 
     // HACK: later we can simply pass the line no, since we don't preserve the tokens
     // when we are decoding the string but we preserve the line numbers.
-    if (v != NULL && first_invalid_escape != NULL && t != NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4199]) {
+      fprintf(stderr, "reached bug index 4199\n");
+    }
+    if ((FIXREVERTER[4199] && (v != (void *) 0 && first_invalid_escape != (void *) 0 )) || (!FIXREVERTER[4199] && (v != (void *) 0 && first_invalid_escape != (void *) 0 && t != (void *) 0 ))
+    #else
+    if (v != (void *) 0 && first_invalid_escape != (void *) 0 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(t != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 4199\n");
+      #endif
+    
         if (warn_invalid_escape_sequence(parser, first_invalid_escape, t) < 0) {
             /* We have not decref u before because first_invalid_escape points
                inside u. */
@@ -159,6 +268,9 @@ decode_unicode_with_escapes(Parser *parser, const char *s, size_t len, Token *t)
             return NULL;
         }
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_XDECREF(u);
     return v;
 }
@@ -168,9 +280,24 @@ decode_bytes_with_escapes(Parser *p, const char *s, Py_ssize_t len, Token *t)
 {
     const char *first_invalid_escape;
     PyObject *result = _PyBytes_DecodeEscape(s, len, NULL, &first_invalid_escape);
-    if (result == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4200]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4200\n");
+      else
+        fprintf(stderr, "reached bug index 4200\n");
+    }
+    if ((!FIXREVERTER[4200] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (first_invalid_escape != NULL) {
         if (warn_invalid_escape_sequence(p, first_invalid_escape, t) < 0) {
@@ -197,9 +324,24 @@ PyObject *
 _PyPegen_parse_string(Parser *p, Token *t)
 {
     const char *s = PyBytes_AsString(t->bytes);
-    if (s == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4201]) {
+      if ((s == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4201\n");
+      else
+        fprintf(stderr, "reached bug index 4201\n");
+    }
+    if ((!FIXREVERTER[4201] && (s == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     size_t len;
     int quote = Py_CHARMASK(*s);
@@ -237,10 +379,25 @@ _PyPegen_parse_string(Parser *p, Token *t)
     // so the code '--len' below is safe.
     assert(len >= 1);
 
-    if (len > INT_MAX) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4202]) {
+      if ((len > 2147483647 ) && !(0))
+        fprintf(stderr, "triggered bug index 4202\n");
+      else
+        fprintf(stderr, "reached bug index 4202\n");
+    }
+    if ((!FIXREVERTER[4202] && (len > 2147483647 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_OverflowError, "string to parse is too long");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (s[--len] != quote) {
         /* Last quote char must match the first. */
         PyErr_BadInternalCall();
diff --git a/Parser/tokenizer/file_tokenizer.c b/Parser/tokenizer/file_tokenizer.c
index 2750527da48..00ba35aead0 100644
--- a/Parser/tokenizer/file_tokenizer.c
+++ b/Parser/tokenizer/file_tokenizer.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_call.h"
 #include "pycore_import.h"
@@ -351,8 +355,23 @@ _PyTokenizer_FromFile(FILE *fp, const char* enc,
                       const char *ps1, const char *ps2)
 {
     struct tok_state *tok = _PyTokenizer_tok_new();
-    if (tok == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[354]) {
+      if ((tok == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 354\n");
+      else
+        fprintf(stderr, "reached bug index 354\n");
+    }
+    if ((!FIXREVERTER[354] && (tok == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     if ((tok->buf = (char *)PyMem_Malloc(BUFSIZ)) == NULL) {
         _PyTokenizer_Free(tok);
         return NULL;
@@ -430,34 +449,96 @@ _PyTokenizer_FindEncodingFilename(int fd, PyObject *filename)
     char *encoding = NULL;
 
     fp = fdopen_borrow(fd);
-    if (fp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[356]) {
+      if ((fp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 356\n");
+      else
+        fprintf(stderr, "reached bug index 356\n");
+    }
+    if ((!FIXREVERTER[356] && (fp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     tok = _PyTokenizer_FromFile(fp, NULL, NULL, NULL);
-    if (tok == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[357]) {
+      if ((tok == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 357\n");
+      else
+        fprintf(stderr, "reached bug index 357\n");
+    }
+    if ((!FIXREVERTER[357] && (tok == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         fclose(fp);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (filename != NULL) {
         tok->filename = Py_NewRef(filename);
     }
     else {
         tok->filename = PyUnicode_FromString("<string>");
-        if (tok->filename == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[358]) {
+          if ((tok -> filename == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 358\n");
+          else
+            fprintf(stderr, "reached bug index 358\n");
+        }
+        if ((!FIXREVERTER[358] && (tok -> filename == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             fclose(fp);
             _PyTokenizer_Free(tok);
             return encoding;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     struct token token;
     // We don't want to report warnings here because it could cause infinite recursion
     // if fetching the encoding shows a warning.
     tok->report_warnings = 0;
-    while (tok->lineno < 2 && tok->done == E_OK) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[359])
+      fprintf(stderr, "reached bug index 359\n");
+    while ((FIXREVERTER[359] && (tok -> lineno < 2 )) || (!FIXREVERTER[359] && (tok -> lineno < 2 && tok -> done == 10 ))
+    #else
+    while (tok -> lineno < 2 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(tok -> done == 10 ))
+        fprintf(stderr, "triggered bug index 359\n");
+      #endif
+    
         _PyToken_Init(&token);
         _PyTokenizer_Get(tok, &token);
         _PyToken_Free(&token);
     }
+    #ifdef FRCOV
+    }
+    #endif
     fclose(fp);
     if (tok->encoding) {
         encoding = (char *)PyMem_Malloc(strlen(tok->encoding) + 1);
diff --git a/Parser/tokenizer/helpers.c b/Parser/tokenizer/helpers.c
index 9c9d05bbef0..bd856742481 100644
--- a/Parser/tokenizer/helpers.c
+++ b/Parser/tokenizer/helpers.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "errcode.h"
 #include "pycore_token.h"
@@ -15,9 +19,24 @@ _syntaxerror_range(struct tok_state *tok, const char *format,
     // In release builds, we don't want to overwrite a previous error, but in debug builds we
     // want to fail if we are not doing it so we can fix it.
     assert(tok->done != E_ERROR);
-    if (tok->done == E_ERROR) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7732]) {
+      if ((tok -> done == 17 ) && !(0))
+        fprintf(stderr, "triggered bug index 7732\n");
+      else
+        fprintf(stderr, "reached bug index 7732\n");
+    }
+    if ((!FIXREVERTER[7732] && (tok -> done == 17 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERRORTOKEN;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *errmsg, *errtext, *args;
     errmsg = PyUnicode_FromFormatV(format, vargs);
     if (!errmsg) {
@@ -117,9 +136,24 @@ _PyTokenizer_warn_invalid_escape_sequence(struct tok_state *tok, int first_inval
         (char) first_invalid_escape_char
     );
 
-    if (msg == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7733]) {
+      if ((msg == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7733\n");
+      else
+        fprintf(stderr, "reached bug index 7733\n");
+    }
+    if ((!FIXREVERTER[7733] && (msg == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (PyErr_WarnExplicitObject(PyExc_SyntaxWarning, msg, tok->filename,
                                  tok->lineno, NULL, NULL) < 0) {
@@ -194,8 +228,23 @@ PyObject *
 _PyTokenizer_translate_into_utf8(const char* str, const char* enc) {
     PyObject *utf8;
     PyObject* buf = PyUnicode_Decode(str, strlen(str), enc, NULL);
-    if (buf == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7734]) {
+      if ((buf == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7734\n");
+      else
+        fprintf(stderr, "reached bug index 7734\n");
+    }
+    if ((!FIXREVERTER[7734] && (buf == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     utf8 = PyUnicode_AsUTF8String(buf);
     Py_DECREF(buf);
     return utf8;
@@ -209,10 +258,25 @@ _PyTokenizer_translate_newlines(const char *s, int exec_input, int preserve_crlf
     char *buf, *current;
     char c = '\0';
     buf = PyMem_Malloc(needed_length);
-    if (buf == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7735]) {
+      if ((buf == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7735\n");
+      else
+        fprintf(stderr, "reached bug index 7735\n");
+    }
+    if ((!FIXREVERTER[7735] && (buf == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         tok->done = E_NOMEM;
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (current = buf; *s; s++, current++) {
         c = *s;
         if (skip_next_lf) {
diff --git a/Parser/tokenizer/string_tokenizer.c b/Parser/tokenizer/string_tokenizer.c
index 0c26d5df8d4..b852ad7d21c 100644
--- a/Parser/tokenizer/string_tokenizer.c
+++ b/Parser/tokenizer/string_tokenizer.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "errcode.h"
 
@@ -59,8 +63,23 @@ decode_str(const char *input, int single, struct tok_state *tok, int preserve_cr
     const char *newl[2] = {NULL, NULL};
     int lineno = 0;
     tok->input = str = _PyTokenizer_translate_newlines(input, single, preserve_crlf, tok);
-    if (str == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4863]) {
+      if ((str == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4863\n");
+      else
+        fprintf(stderr, "reached bug index 4863\n");
+    }
+    if ((!FIXREVERTER[4863] && (str == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     tok->enc = NULL;
     tok->str = str;
     if (!_PyTokenizer_check_bom(buf_getc, buf_ungetc, buf_setreadl, tok))
@@ -69,8 +88,23 @@ decode_str(const char *input, int single, struct tok_state *tok, int preserve_cr
     assert(str);
     if (tok->enc != NULL) {
         utf8 = _PyTokenizer_translate_into_utf8(str, tok->enc);
-        if (utf8 == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4864]) {
+          if ((utf8 == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4864\n");
+          else
+            fprintf(stderr, "reached bug index 4864\n");
+        }
+        if ((!FIXREVERTER[4864] && (utf8 == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return _PyTokenizer_error_ret(tok);
+            #ifdef FRCOV
+            }
+            #endif
         str = PyBytes_AsString(utf8);
     }
     for (s = str;; s++) {
@@ -79,7 +113,22 @@ decode_str(const char *input, int single, struct tok_state *tok, int preserve_cr
             assert(lineno < 2);
             newl[lineno] = s;
             lineno++;
-            if (lineno == 2) break;
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4865]) {
+              if ((lineno == 2 ) && !(0))
+                fprintf(stderr, "triggered bug index 4865\n");
+              else
+                fprintf(stderr, "reached bug index 4865\n");
+            }
+            if ((!FIXREVERTER[4865] && (lineno == 2 ))
+            #else
+            if (0
+            #endif
+            ) break;
+            #ifdef FRCOV
+            }
+            #endif
         }
     }
     tok->enc = NULL;
@@ -98,8 +147,23 @@ decode_str(const char *input, int single, struct tok_state *tok, int preserve_cr
     if (tok->enc != NULL) {
         assert(utf8 == NULL);
         utf8 = _PyTokenizer_translate_into_utf8(str, tok->enc);
-        if (utf8 == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4866]) {
+          if ((utf8 == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4866\n");
+          else
+            fprintf(stderr, "reached bug index 4866\n");
+        }
+        if ((!FIXREVERTER[4866] && (utf8 == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return _PyTokenizer_error_ret(tok);
+            #ifdef FRCOV
+            }
+            #endif
         str = PyBytes_AS_STRING(utf8);
     }
     assert(tok->decoding_buffer == NULL);
@@ -114,13 +178,43 @@ _PyTokenizer_FromString(const char *str, int exec_input, int preserve_crlf)
     struct tok_state *tok = _PyTokenizer_tok_new();
     char *decoded;
 
-    if (tok == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4867]) {
+      if ((tok == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4867\n");
+      else
+        fprintf(stderr, "reached bug index 4867\n");
+    }
+    if ((!FIXREVERTER[4867] && (tok == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     decoded = decode_str(str, exec_input, tok, preserve_crlf);
-    if (decoded == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4868]) {
+      if ((decoded == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4868\n");
+      else
+        fprintf(stderr, "reached bug index 4868\n");
+    }
+    if ((!FIXREVERTER[4868] && (decoded == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyTokenizer_Free(tok);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     tok->buf = tok->cur = tok->inp = decoded;
     tok->end = decoded;
diff --git a/Parser/tokenizer/utf8_tokenizer.c b/Parser/tokenizer/utf8_tokenizer.c
index 1a925f44540..0ba839408c3 100644
--- a/Parser/tokenizer/utf8_tokenizer.c
+++ b/Parser/tokenizer/utf8_tokenizer.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "errcode.h"
 
@@ -32,13 +36,43 @@ _PyTokenizer_FromUTF8(const char *str, int exec_input, int preserve_crlf)
 {
     struct tok_state *tok = _PyTokenizer_tok_new();
     char *translated;
-    if (tok == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4691]) {
+      if ((tok == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4691\n");
+      else
+        fprintf(stderr, "reached bug index 4691\n");
+    }
+    if ((!FIXREVERTER[4691] && (tok == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     tok->input = translated = _PyTokenizer_translate_newlines(str, exec_input, preserve_crlf, tok);
-    if (translated == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4692]) {
+      if ((translated == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4692\n");
+      else
+        fprintf(stderr, "reached bug index 4692\n");
+    }
+    if ((!FIXREVERTER[4692] && (translated == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyTokenizer_Free(tok);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     tok->decoding_state = STATE_NORMAL;
     tok->enc = NULL;
     tok->str = translated;
diff --git a/Python/Python-ast.c b/Python/Python-ast.c
index 01ffea18693..6573a8eee0c 100644
--- a/Python/Python-ast.c
+++ b/Python/Python-ast.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 // File automatically generated by Parser/asdl_c.py.
 
 #include "Python.h"
@@ -17617,9 +17621,24 @@ PyInit__ast(void)
 PyObject* PyAST_mod2obj(mod_ty t)
 {
     struct ast_state *state = get_ast_state();
-    if (state == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7095]) {
+      if ((state == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7095\n");
+      else
+        fprintf(stderr, "reached bug index 7095\n");
+    }
+    if ((!FIXREVERTER[7095] && (state == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     int starting_recursion_depth;
     /* Be careful here to prevent overflow. */
diff --git a/Python/_warnings.c b/Python/_warnings.c
index 17404d33c1c..49045b74898 100644
--- a/Python/_warnings.c
+++ b/Python/_warnings.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_critical_section.h"  // Py_BEGIN_CRITICAL_SECTION_MUT()
 #include "pycore_interp.h"        // PyInterpreterState.warnings
@@ -26,12 +30,27 @@ typedef struct _warnings_runtime_state WarningsState;
 static inline int
 check_interp(PyInterpreterState *interp)
 {
-    if (interp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6652]) {
+      if ((interp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6652\n");
+      else
+        fprintf(stderr, "reached bug index 6652\n");
+    }
+    if ((!FIXREVERTER[6652] && (interp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_RuntimeError,
                         "warnings_get_state: could not identify "
                         "current interpreter");
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return 1;
 }
 
@@ -46,10 +65,25 @@ static inline PyThreadState *
 get_current_tstate(void)
 {
     PyThreadState *tstate = _PyThreadState_GET();
-    if (tstate == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6653]) {
+      if ((tstate == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6653\n");
+      else
+        fprintf(stderr, "reached bug index 6653\n");
+    }
+    if ((!FIXREVERTER[6653] && (tstate == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         (void)check_interp(NULL);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return check_interp(tstate->interp) ? tstate : NULL;
 }
 
@@ -182,8 +216,23 @@ check_matched(PyInterpreterState *interp, PyObject *obj, PyObject *arg)
 
     /* Otherwise assume a regex filter and call its match() method */
     result = PyObject_CallMethodOneArg(obj, &_Py_ID(match), arg);
-    if (result == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6659]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6659\n");
+      else
+        fprintf(stderr, "reached bug index 6659\n");
+    }
+    if ((!FIXREVERTER[6659] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     rc = PyObject_IsTrue(result);
     Py_DECREF(result);
@@ -205,7 +254,19 @@ get_warnings_attr(PyInterpreterState *interp, PyObject *attr, int try_import)
     /* don't try to import after the start of the Python finallization */
     if (try_import && !_Py_IsInterpreterFinalizing(interp)) {
         warnings_module = PyImport_Import(&_Py_ID(warnings));
-        if (warnings_module == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6660]) {
+          if ((warnings_module == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6660\n");
+          else
+            fprintf(stderr, "reached bug index 6660\n");
+        }
+        if ((!FIXREVERTER[6660] && (warnings_module == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             /* Fallback to the C implementation if we cannot get
                the Python implementation */
             if (PyErr_ExceptionMatches(PyExc_ImportError)) {
@@ -213,6 +274,9 @@ get_warnings_attr(PyInterpreterState *interp, PyObject *attr, int try_import)
             }
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     else {
         /* if we're so late into Python finalization that the module dict is
@@ -223,8 +287,23 @@ get_warnings_attr(PyInterpreterState *interp, PyObject *attr, int try_import)
             return NULL;
         }
         warnings_module = PyImport_GetModule(&_Py_ID(warnings));
-        if (warnings_module == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6661]) {
+          if ((warnings_module == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6661\n");
+          else
+            fprintf(stderr, "reached bug index 6661\n");
+        }
+        if ((!FIXREVERTER[6661] && (warnings_module == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
     (void)PyObject_GetOptionalAttr(warnings_module, attr, &obj);
@@ -242,12 +321,27 @@ get_once_registry(PyInterpreterState *interp)
     _Py_CRITICAL_SECTION_ASSERT_MUTEX_LOCKED(&st->mutex);
 
     PyObject *registry = GET_WARNINGS_ATTR(interp, onceregistry, 0);
-    if (registry == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6662]) {
+      if ((registry == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6662\n");
+      else
+        fprintf(stderr, "reached bug index 6662\n");
+    }
+    if ((!FIXREVERTER[6662] && (registry == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (PyErr_Occurred())
             return NULL;
         assert(st->once_registry);
         return st->once_registry;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyDict_Check(registry)) {
         PyErr_Format(PyExc_TypeError,
                      MODULE_NAME ".onceregistry must be a dict, "
@@ -270,13 +364,28 @@ get_default_action(PyInterpreterState *interp)
     _Py_CRITICAL_SECTION_ASSERT_MUTEX_LOCKED(&st->mutex);
 
     PyObject *default_action = GET_WARNINGS_ATTR(interp, defaultaction, 0);
-    if (default_action == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6663]) {
+      if ((default_action == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6663\n");
+      else
+        fprintf(stderr, "reached bug index 6663\n");
+    }
+    if ((!FIXREVERTER[6663] && (default_action == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (PyErr_Occurred()) {
             return NULL;
         }
         assert(st->default_action);
         return st->default_action;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyUnicode_Check(default_action)) {
         PyErr_Format(PyExc_TypeError,
                      MODULE_NAME ".defaultaction must be a string, "
@@ -394,8 +503,23 @@ already_warned(PyInterpreterState *interp, PyObject *registry, PyObject *key,
 {
     PyObject *already_warned;
 
-    if (key == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6664]) {
+      if ((key == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6664\n");
+      else
+        fprintf(stderr, "reached bug index 6664\n");
+    }
+    if ((!FIXREVERTER[6664] && (key == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     WarningsState *st = warnings_get_state(interp);
     assert(st != NULL);
@@ -414,8 +538,23 @@ already_warned(PyInterpreterState *interp, PyObject *registry, PyObject *key,
     if (should_update_version) {
         PyDict_Clear(registry);
         version_obj = PyLong_FromLong(st->filters_version);
-        if (version_obj == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6665]) {
+          if ((version_obj == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6665\n");
+          else
+            fprintf(stderr, "reached bug index 6665\n");
+        }
+        if ((!FIXREVERTER[6665] && (version_obj == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return -1;
+            #ifdef FRCOV
+            }
+            #endif
         if (PyDict_SetItem(registry, &_Py_ID(version), version_obj) < 0) {
             Py_DECREF(version_obj);
             return -1;
@@ -450,11 +589,41 @@ normalize_module(PyObject *filename)
     Py_ssize_t len;
 
     len = PyUnicode_GetLength(filename);
-    if (len < 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6667]) {
+      if ((len < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6667\n");
+      else
+        fprintf(stderr, "reached bug index 6667\n");
+    }
+    if ((!FIXREVERTER[6667] && (len < 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
-
-    if (len == 0)
+        #ifdef FRCOV
+        }
+        #endif
+
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6668]) {
+      if ((len == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6668\n");
+      else
+        fprintf(stderr, "reached bug index 6668\n");
+    }
+    if ((!FIXREVERTER[6668] && (len == 0 ))
+    #else
+    if (0
+    #endif
+    )
         return PyUnicode_FromString("<unknown>");
+        #ifdef FRCOV
+        }
+        #endif
 
     kind = PyUnicode_KIND(filename);
     data = PyUnicode_DATA(filename);
@@ -501,15 +670,45 @@ show_warning(PyThreadState *tstate, PyObject *filename, int lineno,
     PyOS_snprintf(lineno_str, sizeof(lineno_str), ":%d: ", lineno);
 
     name = PyObject_GetAttr(category, &_Py_ID(__name__));
-    if (name == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6669]) {
+      if ((name == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6669\n");
+      else
+        fprintf(stderr, "reached bug index 6669\n");
+    }
+    if ((!FIXREVERTER[6669] && (name == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     f_stderr = _PySys_GetAttr(tstate, &_Py_ID(stderr));
-    if (f_stderr == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6670]) {
+      if ((f_stderr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6670\n");
+      else
+        fprintf(stderr, "reached bug index 6670\n");
+    }
+    if ((!FIXREVERTER[6670] && (f_stderr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         fprintf(stderr, "lost sys.stderr\n");
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Print "filename:lineno: category: text\n" */
     if (PyFile_WriteObject(filename, f_stderr, Py_PRINT_RAW) < 0)
@@ -544,8 +743,23 @@ show_warning(PyThreadState *tstate, PyObject *filename, int lineno,
         }
 
         truncated = PyUnicode_Substring(sourceline, i, len);
-        if (truncated == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6671]) {
+          if ((truncated == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6671\n");
+          else
+            fprintf(stderr, "reached bug index 6671\n");
+        }
+        if ((!FIXREVERTER[6671] && (truncated == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto error;
+            #ifdef FRCOV
+            }
+            #endif
 
         PyFile_WriteObject(sourceline, f_stderr, Py_PRINT_RAW);
         Py_DECREF(truncated);
@@ -572,12 +786,27 @@ call_show_warning(PyThreadState *tstate, PyObject *category,
     /* The Python implementation is able to log the traceback where the source
        was allocated, whereas the C implementation doesn't. */
     show_fn = GET_WARNINGS_ATTR(interp, _showwarnmsg, 1);
-    if (show_fn == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6672]) {
+      if ((show_fn == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6672\n");
+      else
+        fprintf(stderr, "reached bug index 6672\n");
+    }
+    if ((!FIXREVERTER[6672] && (show_fn == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (PyErr_Occurred())
             return -1;
         show_warning(tstate, filename, lineno, text, category, sourceline);
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!PyCallable_Check(show_fn)) {
         PyErr_SetString(PyExc_TypeError,
@@ -586,27 +815,72 @@ call_show_warning(PyThreadState *tstate, PyObject *category,
     }
 
     warnmsg_cls = GET_WARNINGS_ATTR(interp, WarningMessage, 0);
-    if (warnmsg_cls == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6673]) {
+      if ((warnmsg_cls == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6673\n");
+      else
+        fprintf(stderr, "reached bug index 6673\n");
+    }
+    if ((!FIXREVERTER[6673] && (warnmsg_cls == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (!PyErr_Occurred()) {
             PyErr_SetString(PyExc_RuntimeError,
                     "unable to get warnings.WarningMessage");
         }
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     msg = PyObject_CallFunctionObjArgs(warnmsg_cls, message, category,
             filename, lineno_obj, Py_None, Py_None, source,
             NULL);
     Py_DECREF(warnmsg_cls);
-    if (msg == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6674]) {
+      if ((msg == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6674\n");
+      else
+        fprintf(stderr, "reached bug index 6674\n");
+    }
+    if ((!FIXREVERTER[6674] && (msg == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto error;
+        #ifdef FRCOV
+        }
+        #endif
 
     res = PyObject_CallOneArg(show_fn, msg);
     Py_DECREF(show_fn);
     Py_DECREF(msg);
 
-    if (res == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6675]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6675\n");
+      else
+        fprintf(stderr, "reached bug index 6675\n");
+    }
+    if ((!FIXREVERTER[6675] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     Py_DECREF(res);
     return 0;
@@ -643,8 +917,23 @@ warn_explicit(PyThreadState *tstate, PyObject *category, PyObject *message,
     /* Normalize module. */
     if (module == NULL) {
         module = normalize_module(filename);
-        if (module == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6676]) {
+          if ((module == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6676\n");
+          else
+            fprintf(stderr, "reached bug index 6676\n");
+        }
+        if ((!FIXREVERTER[6676] && (module == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
     }
     else
         Py_INCREF(module);
@@ -657,20 +946,65 @@ warn_explicit(PyThreadState *tstate, PyObject *category, PyObject *message,
     }
     if (rc == 1) {
         text = PyObject_Str(message);
-        if (text == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6677]) {
+          if ((text == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6677\n");
+          else
+            fprintf(stderr, "reached bug index 6677\n");
+        }
+        if ((!FIXREVERTER[6677] && (text == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto cleanup;
+            #ifdef FRCOV
+            }
+            #endif
         category = (PyObject*)Py_TYPE(message);
     }
     else {
         text = message;
         message = PyObject_CallOneArg(category, message);
-        if (message == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6678]) {
+          if ((message == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6678\n");
+          else
+            fprintf(stderr, "reached bug index 6678\n");
+        }
+        if ((!FIXREVERTER[6678] && (message == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto cleanup;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
     lineno_obj = PyLong_FromLong(lineno);
-    if (lineno_obj == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6679]) {
+      if ((lineno_obj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6679\n");
+      else
+        fprintf(stderr, "reached bug index 6679\n");
+    }
+    if ((!FIXREVERTER[6679] && (lineno_obj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto cleanup;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (source == Py_None) {
         source = NULL;
@@ -678,8 +1012,23 @@ warn_explicit(PyThreadState *tstate, PyObject *category, PyObject *message,
 
     /* Create key. */
     key = PyTuple_Pack(3, text, category, lineno_obj);
-    if (key == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6680]) {
+      if ((key == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6680\n");
+      else
+        fprintf(stderr, "reached bug index 6680\n");
+    }
+    if ((!FIXREVERTER[6680] && (key == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto cleanup;
+        #ifdef FRCOV
+        }
+        #endif
 
     if ((registry != NULL) && (registry != Py_None)) {
         rc = already_warned(interp, registry, key, 0);
@@ -691,8 +1040,23 @@ warn_explicit(PyThreadState *tstate, PyObject *category, PyObject *message,
     }
 
     action = get_filter(interp, category, text, lineno, module, &item);
-    if (action == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6682]) {
+      if ((action == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6682\n");
+      else
+        fprintf(stderr, "reached bug index 6682\n");
+    }
+    if ((!FIXREVERTER[6682] && (action == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto cleanup;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (_PyUnicode_EqualToASCIIString(action, "error")) {
         PyErr_SetObject(category, message);
@@ -716,8 +1080,23 @@ warn_explicit(PyThreadState *tstate, PyObject *category, PyObject *message,
         if (_PyUnicode_EqualToASCIIString(action, "once")) {
             if (registry == NULL || registry == Py_None) {
                 registry = get_once_registry(interp);
-                if (registry == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[6683]) {
+                  if ((registry == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 6683\n");
+                  else
+                    fprintf(stderr, "reached bug index 6683\n");
+                }
+                if ((!FIXREVERTER[6683] && (registry == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     goto cleanup;
+                    #ifdef FRCOV
+                    }
+                    #endif
             }
             /* WarningsState.once_registry[(text, category)] = 1 */
             rc = update_registry(interp, registry, text, category, 0);
@@ -818,14 +1197,44 @@ is_filename_to_skip(PyObject *filename, PyTupleObject *skip_file_prefixes)
 static bool
 is_internal_frame(PyFrameObject *frame)
 {
-    if (frame == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6688]) {
+      if ((frame == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6688\n");
+      else
+        fprintf(stderr, "reached bug index 6688\n");
+    }
+    if ((!FIXREVERTER[6688] && (frame == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *filename = get_frame_filename(frame);
-    if (filename == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6689]) {
+      if ((filename == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6689\n");
+      else
+        fprintf(stderr, "reached bug index 6689\n");
+    }
+    if ((!FIXREVERTER[6689] && (filename == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return false;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     return is_internal_filename(filename);
 }
@@ -857,9 +1266,24 @@ setup_context(Py_ssize_t stack_level,
 
     /* Setup globals, filename and lineno. */
     PyThreadState *tstate = get_current_tstate();
-    if (tstate == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6690]) {
+      if ((tstate == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6690\n");
+      else
+        fprintf(stderr, "reached bug index 6690\n");
+    }
+    if ((!FIXREVERTER[6690] && (tstate == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (skip_file_prefixes) {
         /* Type check our data structure up front. Later code that uses it
          * isn't structured to report errors. */
@@ -985,9 +1409,24 @@ do_warn(PyObject *message, PyObject *category, Py_ssize_t stack_level,
     int lineno;
 
     PyThreadState *tstate = get_current_tstate();
-    if (tstate == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6694]) {
+      if ((tstate == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6694\n");
+      else
+        fprintf(stderr, "reached bug index 6694\n");
+    }
+    if ((!FIXREVERTER[6694] && (tstate == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (!setup_context(stack_level, skip_file_prefixes,
                        &filename, &lineno, &module, &registry))
@@ -1196,12 +1635,42 @@ warn_unicode(PyObject *category, PyObject *message,
 {
     PyObject *res;
 
-    if (category == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6700]) {
+      if ((category == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6700\n");
+      else
+        fprintf(stderr, "reached bug index 6700\n");
+    }
+    if ((!FIXREVERTER[6700] && (category == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         category = PyExc_RuntimeWarning;
+        #ifdef FRCOV
+        }
+        #endif
 
     res = do_warn(message, category, stack_level, source, NULL);
-    if (res == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6701]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6701\n");
+      else
+        fprintf(stderr, "reached bug index 6701\n");
+    }
+    if ((!FIXREVERTER[6701] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     Py_DECREF(res);
 
     return 0;
@@ -1216,8 +1685,23 @@ _PyErr_WarnFormatV(PyObject *source,
     int res;
 
     message = PyUnicode_FromFormatV(format, vargs);
-    if (message == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6702]) {
+      if ((message == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6702\n");
+      else
+        fprintf(stderr, "reached bug index 6702\n");
+    }
+    if ((!FIXREVERTER[6702] && (message == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     res = warn_unicode(category, message, stack_level, source);
     Py_DECREF(message);
@@ -1270,8 +1754,23 @@ PyErr_WarnEx(PyObject *category, const char *text, Py_ssize_t stack_level)
 {
     int ret;
     PyObject *message = PyUnicode_FromString(text);
-    if (message == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6703]) {
+      if ((message == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6703\n");
+      else
+        fprintf(stderr, "reached bug index 6703\n");
+    }
+    if ((!FIXREVERTER[6703] && (message == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     ret = warn_unicode(category, message, stack_level, NULL);
     Py_DECREF(message);
     return ret;
@@ -1295,12 +1794,42 @@ PyErr_WarnExplicitObject(PyObject *category, PyObject *message,
                          PyObject *module, PyObject *registry)
 {
     PyObject *res;
-    if (category == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6704]) {
+      if ((category == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6704\n");
+      else
+        fprintf(stderr, "reached bug index 6704\n");
+    }
+    if ((!FIXREVERTER[6704] && (category == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         category = PyExc_RuntimeWarning;
+        #ifdef FRCOV
+        }
+        #endif
     PyThreadState *tstate = get_current_tstate();
-    if (tstate == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6705]) {
+      if ((tstate == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6705\n");
+      else
+        fprintf(stderr, "reached bug index 6705\n");
+    }
+    if ((!FIXREVERTER[6705] && (tstate == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 #ifdef Py_GIL_DISABLED
     WarningsState *st = warnings_get_state(tstate->interp);
@@ -1311,8 +1840,23 @@ PyErr_WarnExplicitObject(PyObject *category, PyObject *message,
     res = warn_explicit(tstate, category, message, filename, lineno,
                         module, registry, NULL, NULL);
     Py_END_CRITICAL_SECTION();
-    if (res == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6706]) {
+      if ((res == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6706\n");
+      else
+        fprintf(stderr, "reached bug index 6706\n");
+    }
+    if ((!FIXREVERTER[6706] && (res == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     Py_DECREF(res);
     return 0;
 }
@@ -1361,12 +1905,42 @@ PyErr_WarnExplicitFormat(PyObject *category,
     int ret = -1;
     va_list vargs;
 
-    if (filename == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6710]) {
+      if ((filename == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6710\n");
+      else
+        fprintf(stderr, "reached bug index 6710\n");
+    }
+    if ((!FIXREVERTER[6710] && (filename == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto exit;
+        #ifdef FRCOV
+        }
+        #endif
     if (module_str != NULL) {
         module = PyUnicode_FromString(module_str);
-        if (module == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[6711]) {
+          if ((module == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 6711\n");
+          else
+            fprintf(stderr, "reached bug index 6711\n");
+        }
+        if ((!FIXREVERTER[6711] && (module == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto exit;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
     va_start(vargs, format);
diff --git a/Python/assemble.c b/Python/assemble.c
index f7b88b519f5..1793dcce32d 100644
--- a/Python/assemble.c
+++ b/Python/assemble.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include <stdbool.h>
 
 #include "Python.h"
@@ -68,17 +72,62 @@ assemble_init(struct assembler *a, int firstlineno)
     a->a_location_off = 0;
     a->a_except_table = NULL;
     a->a_bytecode = PyBytes_FromStringAndSize(NULL, DEFAULT_CODE_SIZE);
-    if (a->a_bytecode == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1824]) {
+      if ((a -> a_bytecode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1824\n");
+      else
+        fprintf(stderr, "reached bug index 1824\n");
+    }
+    if ((!FIXREVERTER[1824] && (a -> a_bytecode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     a->a_linetable = PyBytes_FromStringAndSize(NULL, DEFAULT_CNOTAB_SIZE);
-    if (a->a_linetable == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1825]) {
+      if ((a -> a_linetable == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1825\n");
+      else
+        fprintf(stderr, "reached bug index 1825\n");
+    }
+    if ((!FIXREVERTER[1825] && (a -> a_linetable == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     a->a_except_table = PyBytes_FromStringAndSize(NULL, DEFAULT_LNOTAB_SIZE);
-    if (a->a_except_table == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1826]) {
+      if ((a -> a_except_table == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1826\n");
+      else
+        fprintf(stderr, "reached bug index 1826\n");
+    }
+    if ((!FIXREVERTER[1826] && (a -> a_except_table == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return SUCCESS;
 error:
     Py_XDECREF(a->a_bytecode);
@@ -291,10 +340,25 @@ write_location_info_entry(struct assembler* a, location loc, int isize)
         assert(len > THEORETICAL_MAX_ENTRY_SIZE);
         RETURN_IF_ERROR(_PyBytes_Resize(&a->a_linetable, len*2));
     }
-    if (loc.lineno < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1827]) {
+      if ((loc . lineno < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1827\n");
+      else
+        fprintf(stderr, "reached bug index 1827\n");
+    }
+    if ((!FIXREVERTER[1827] && (loc . lineno < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         write_location_info_none(a, isize);
         return SUCCESS;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int line_delta = loc.lineno - a->a_lineno;
     int column = loc.col_offset;
     int end_column = loc.end_col_offset;
@@ -326,9 +390,24 @@ write_location_info_entry(struct assembler* a, location loc, int isize)
 static int
 assemble_emit_location(struct assembler* a, location loc, int isize)
 {
-    if (isize == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1828]) {
+      if ((isize == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1828\n");
+      else
+        fprintf(stderr, "reached bug index 1828\n");
+    }
+    if ((!FIXREVERTER[1828] && (isize == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return SUCCESS;
     }
+    #ifdef FRCOV
+    }
+    #endif
     while (isize > 8) {
         RETURN_IF_ERROR(write_location_info_entry(a, loc, 8));
         isize -= 8;
@@ -408,9 +487,24 @@ assemble_emit_instr(struct assembler *a, instruction *instr)
 
     int size = instr_size(instr);
     if (a->a_offset + size >= len / (int)sizeof(_Py_CODEUNIT)) {
-        if (len > PY_SSIZE_T_MAX / 2) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1829]) {
+          if ((len > 9223372036854775807 / 2 ) && !(0))
+            fprintf(stderr, "triggered bug index 1829\n");
+          else
+            fprintf(stderr, "reached bug index 1829\n");
+        }
+        if ((!FIXREVERTER[1829] && (len > 9223372036854775807 / 2 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         RETURN_IF_ERROR(_PyBytes_Resize(&a->a_bytecode, len * 2));
     }
     code = (_Py_CODEUNIT *)PyBytes_AS_STRING(a->a_bytecode) + a->a_offset;
@@ -452,8 +546,23 @@ dict_keys_inorder(PyObject *dict, Py_ssize_t offset)
     Py_ssize_t pos = 0, size = PyDict_GET_SIZE(dict);
 
     tuple = PyTuple_New(size);
-    if (tuple == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1830]) {
+      if ((tuple == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1830\n");
+      else
+        fprintf(stderr, "reached bug index 1830\n");
+    }
+    if ((!FIXREVERTER[1830] && (tuple == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     while (PyDict_Next(dict, &pos, &k, &v)) {
         Py_ssize_t i = PyLong_AsSsize_t(v);
         if (i == -1 && PyErr_Occurred()) {
@@ -558,9 +667,24 @@ makecode(_PyCompile_CodeUnitMetadata *umd, struct assembler *a, PyObject *const_
     }
 
     consts = PyList_AsTuple(constslist); /* PyCode_New requires a tuple */
-    if (consts == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1831]) {
+      if ((consts == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1831\n");
+      else
+        fprintf(stderr, "reached bug index 1831\n");
+    }
+    if ((!FIXREVERTER[1831] && (consts == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_PyCompile_ConstCacheMergeOne(const_cache, &consts) < 0) {
         goto error;
     }
@@ -574,13 +698,43 @@ makecode(_PyCompile_CodeUnitMetadata *umd, struct assembler *a, PyObject *const_
     int kwonlyargcount = (int)umd->u_kwonlyargcount;
 
     localsplusnames = PyTuple_New(nlocalsplus);
-    if (localsplusnames == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1832]) {
+      if ((localsplusnames == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1832\n");
+      else
+        fprintf(stderr, "reached bug index 1832\n");
+    }
+    if ((!FIXREVERTER[1832] && (localsplusnames == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     localspluskinds = PyBytes_FromStringAndSize(NULL, nlocalsplus);
-    if (localspluskinds == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1833]) {
+      if ((localspluskinds == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1833\n");
+      else
+        fprintf(stderr, "reached bug index 1833\n");
+    }
+    if ((!FIXREVERTER[1833] && (localspluskinds == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (compute_localsplus_info(umd, nlocalsplus,
                                 localsplusnames, localspluskinds) == ERROR) {
         goto error;
@@ -621,9 +775,24 @@ makecode(_PyCompile_CodeUnitMetadata *umd, struct assembler *a, PyObject *const_
     con.localsplusnames = localsplusnames;
 
     co = _PyCode_New(&con);
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1834]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1834\n");
+      else
+        fprintf(stderr, "reached bug index 1834\n");
+    }
+    if ((!FIXREVERTER[1834] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 error:
     Py_XDECREF(names);
diff --git a/Python/ast_opt.c b/Python/ast_opt.c
index 2e2c78b9d4d..bef6bb52722 100644
--- a/Python/ast_opt.c
+++ b/Python/ast_opt.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* AST Optimizer */
 #include "Python.h"
 #include "pycore_ast.h"           // _PyAST_GetDocString()
@@ -21,13 +25,28 @@ make_const(expr_ty node, PyObject *val, PyArena *arena)
 {
     // Even if no new value was calculated, make_const may still
     // need to clear an error (e.g. for division by zero)
-    if (val == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[541]) {
+      if ((val == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 541\n");
+      else
+        fprintf(stderr, "reached bug index 541\n");
+    }
+    if ((!FIXREVERTER[541] && (val == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (PyErr_ExceptionMatches(PyExc_KeyboardInterrupt)) {
             return 0;
         }
         PyErr_Clear();
         return 1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (_PyArena_AddPyObject(arena, val) < 0) {
         Py_DECREF(val);
         return 0;
@@ -267,9 +286,24 @@ parse_literal(PyObject *fmt, Py_ssize_t *ppos, PyArena *arena)
         }
     }
     *ppos = pos;
-    if (pos == start) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[548]) {
+      if ((pos == start ) && !(0))
+        fprintf(stderr, "triggered bug index 548\n");
+      else
+        fprintf(stderr, "reached bug index 548\n");
+    }
+    if ((!FIXREVERTER[548] && (pos == start ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *str = PyUnicode_Substring(fmt, start, pos);
     /* str = str.replace('%%', '%') */
     if (str && has_percents) {
@@ -372,17 +406,47 @@ parse_format(PyObject *fmt, Py_ssize_t *ppos, expr_ty arg, PyArena *arena)
         expr_ty format_spec = NULL;
         if (p != buf) {
             PyObject *str = PyUnicode_FromString(buf);
-            if (str == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[549]) {
+              if ((str == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 549\n");
+              else
+                fprintf(stderr, "reached bug index 549\n");
+            }
+            if ((!FIXREVERTER[549] && (str == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             if (_PyArena_AddPyObject(arena, str) < 0) {
                 Py_DECREF(str);
                 return NULL;
             }
             format_spec = _PyAST_Constant(str, NULL, -1, -1, -1, -1, arena);
-            if (format_spec == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[550]) {
+              if ((format_spec == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 550\n");
+              else
+                fprintf(stderr, "reached bug index 550\n");
+            }
+            if ((!FIXREVERTER[550] && (format_spec == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         return _PyAST_FormattedValue(arg, spec, format_spec,
                                      arg->lineno, arg->col_offset,
@@ -529,9 +593,24 @@ make_const_tuple(asdl_expr_seq *elts)
     }
 
     PyObject *newval = PyTuple_New(asdl_seq_LEN(elts));
-    if (newval == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[551]) {
+      if ((newval == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 551\n");
+      else
+        fprintf(stderr, "reached bug index 551\n");
+    }
+    if ((!FIXREVERTER[551] && (newval == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (Py_ssize_t i = 0; i < asdl_seq_LEN(elts); i++) {
         expr_ty e = (expr_ty)asdl_seq_GET(elts, i);
diff --git a/Python/ast_unparse.c b/Python/ast_unparse.c
index 86f7a582b98..6ce5317b03f 100644
--- a/Python/ast_unparse.c
+++ b/Python/ast_unparse.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_ast.h"           // expr_ty
 #include "pycore_pystate.h"       // _PyInterpreterState_GET()
@@ -924,9 +928,24 @@ maybe_init_static_strings(void)
     PyInterpreterState *interp = _PyInterpreterState_GET();
     if (_str_replace_inf(interp) == NULL) {
         PyObject *tmp = PyUnicode_FromFormat("1e%d", 1 + DBL_MAX_10_EXP);
-        if (tmp == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[2626]) {
+          if ((tmp == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 2626\n");
+          else
+            fprintf(stderr, "reached bug index 2626\n");
+        }
+        if ((!FIXREVERTER[2626] && (tmp == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         _str_replace_inf(interp) = tmp;
     }
     return 0;
diff --git a/Python/ceval.c b/Python/ceval.c
index f4b3a417025..e3b8e5dca67 100644
--- a/Python/ceval.c
+++ b/Python/ceval.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Execute compiled code */
 
 #define _PY_INTERPRETER
@@ -2610,9 +2614,24 @@ PyEval_GetGlobals(void)
 {
     PyThreadState *tstate = _PyThreadState_GET();
     _PyInterpreterFrame *current_frame = _PyThreadState_GetFrame(tstate);
-    if (current_frame == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[6384]) {
+      if ((current_frame == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 6384\n");
+      else
+        fprintf(stderr, "reached bug index 6384\n");
+    }
+    if ((!FIXREVERTER[6384] && (current_frame == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return current_frame->f_globals;
 }
 
diff --git a/Python/ceval_gil.c b/Python/ceval_gil.c
index 5617504a495..6964eb4fb0a 100644
--- a/Python/ceval_gil.c
+++ b/Python/ceval_gil.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 #include "Python.h"
 #include "pycore_ceval.h"         // _PyEval_SignalReceived()
@@ -738,12 +742,27 @@ _next_pending_call(struct _pending_calls *pending,
                    int (**func)(void *), void **arg, int *flags)
 {
     int i = pending->first;
-    if (pending->npending == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4874]) {
+      if ((pending -> npending == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4874\n");
+      else
+        fprintf(stderr, "reached bug index 4874\n");
+    }
+    if ((!FIXREVERTER[4874] && (pending -> npending == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* Queue empty */
         assert(i == pending->next);
         assert(pending->calls[i].func == NULL);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     *func = pending->calls[i].func;
     *arg = pending->calls[i].arg;
     *flags = pending->calls[i].flags;
@@ -860,10 +879,25 @@ _make_pending_calls(struct _pending_calls *pending, int32_t *p_npending)
         PyMutex_Unlock(&pending->mutex);
 
         /* Check if there are any more pending calls. */
-        if (func == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[4875]) {
+          if ((func == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 4875\n");
+          else
+            fprintf(stderr, "reached bug index 4875\n");
+        }
+        if ((!FIXREVERTER[4875] && (func == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             assert(npending == 0);
             break;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         /* having released the lock, perform the callback */
         res = func(arg);
diff --git a/Python/compile.c b/Python/compile.c
index 69de0ec2996..353bf182414 100644
--- a/Python/compile.c
+++ b/Python/compile.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * This file compiles an abstract syntax tree (AST) into Python bytecode.
  *
@@ -173,10 +177,25 @@ _PyCompile_EnsureArrayLargeEnough(int idx, void **array, int *alloc,
             new_alloc = idx + default_alloc;
         }
         arr = PyMem_Calloc(new_alloc, item_size);
-        if (arr == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5011]) {
+          if ((arr == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5011\n");
+          else
+            fprintf(stderr, "reached bug index 5011\n");
+        }
+        if ((!FIXREVERTER[5011] && (arr == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         *alloc = new_alloc;
     }
     else if (idx >= *alloc) {
@@ -194,10 +213,25 @@ _PyCompile_EnsureArrayLargeEnough(int idx, void **array, int *alloc,
 
         assert(newsize > 0);
         void *tmp = PyMem_Realloc(arr, newsize);
-        if (tmp == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5012]) {
+          if ((tmp == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5012\n");
+          else
+            fprintf(stderr, "reached bug index 5012\n");
+        }
+        if ((!FIXREVERTER[5012] && (tmp == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         *alloc = new_alloc;
         arr = tmp;
         memset((char *)arr + oldsize, 0, newsize - oldsize);
@@ -385,12 +419,27 @@ compiler_setup(struct compiler *c, mod_ty mod, PyObject *filename,
         return ERROR;
     }
     c->c_st = _PySymtable_Build(mod, filename, &c->c_future);
-    if (c->c_st == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5013]) {
+      if ((c -> c_st == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5013\n");
+      else
+        fprintf(stderr, "reached bug index 5013\n");
+    }
+    if ((!FIXREVERTER[5013] && (c -> c_st == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (!PyErr_Occurred()) {
             PyErr_SetString(PyExc_SystemError, "no symtable");
         }
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return SUCCESS;
 }
 
@@ -399,9 +448,24 @@ new_compiler(mod_ty mod, PyObject *filename, PyCompilerFlags *pflags,
              int optimize, PyArena *arena)
 {
     struct compiler *c = PyMem_Calloc(1, sizeof(struct compiler));
-    if (c == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5014]) {
+      if ((c == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5014\n");
+      else
+        fprintf(stderr, "reached bug index 5014\n");
+    }
+    if ((!FIXREVERTER[5014] && (c == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (compiler_setup(c, mod, filename, pflags, optimize, arena) < 0) {
         compiler_free(c);
         return NULL;
@@ -415,9 +479,24 @@ _PyAST_Compile(mod_ty mod, PyObject *filename, PyCompilerFlags *pflags,
 {
     assert(!PyErr_Occurred());
     struct compiler *c = new_compiler(mod, filename, pflags, optimize, arena);
-    if (c == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5015]) {
+      if ((c == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5015\n");
+      else
+        fprintf(stderr, "reached bug index 5015\n");
+    }
+    if ((!FIXREVERTER[5015] && (c == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyCodeObject *co = compiler_mod(c, mod);
     compiler_free(c);
@@ -496,8 +575,23 @@ dictbytype(PyObject *src, int scope_type, int flag, Py_ssize_t offset)
     PyObject *sorted_keys;
 
     assert(offset >= 0);
-    if (dest == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5016]) {
+      if ((dest == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5016\n");
+      else
+        fprintf(stderr, "reached bug index 5016\n");
+    }
+    if ((!FIXREVERTER[5016] && (dest == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Sort the keys so that we have a deterministic order on the indexes
        saved in the returned dictionary.  These indexes are used as indexes
@@ -505,8 +599,23 @@ dictbytype(PyObject *src, int scope_type, int flag, Py_ssize_t offset)
        deterministic, then the generated bytecode is not deterministic.
     */
     sorted_keys = PyDict_Keys(src);
-    if (sorted_keys == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5017]) {
+      if ((sorted_keys == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5017\n");
+      else
+        fprintf(stderr, "reached bug index 5017\n");
+    }
+    if ((!FIXREVERTER[5017] && (sorted_keys == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     if (PyList_Sort(sorted_keys) != 0) {
         Py_DECREF(sorted_keys);
         return NULL;
@@ -524,11 +633,26 @@ dictbytype(PyObject *src, int scope_type, int flag, Py_ssize_t offset)
 
         if (scope == scope_type || vi & flag) {
             PyObject *item = PyLong_FromSsize_t(i);
-            if (item == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5018]) {
+              if ((item == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5018\n");
+              else
+                fprintf(stderr, "reached bug index 5018\n");
+            }
+            if ((!FIXREVERTER[5018] && (item == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Py_DECREF(sorted_keys);
                 Py_DECREF(dest);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             i++;
             if (PyDict_SetItem(dest, k, item) < 0) {
                 Py_DECREF(sorted_keys);
@@ -571,9 +695,24 @@ get_class_compiler_unit(struct compiler *c)
         struct compiler_unit *u = (struct compiler_unit *)PyCapsule_GetPointer(
                                                               capsule, CAPSULE_NAME);
         assert(u);
-        if (u->u_scope_type == COMPILER_SCOPE_CLASS) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5019]) {
+          if ((u -> u_scope_type == COMPILER_SCOPE_CLASS ) && !(0))
+            fprintf(stderr, "triggered bug index 5019\n");
+          else
+            fprintf(stderr, "reached bug index 5019\n");
+        }
+        if ((!FIXREVERTER[5019] && (u -> u_scope_type == COMPILER_SCOPE_CLASS ))
+        #else
+        if (0
+        #endif
+        ) {
             return u;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     return NULL;
 }
@@ -599,12 +738,27 @@ compiler_set_qualname(struct compiler *c)
         if (parent->u_scope_type == COMPILER_SCOPE_ANNOTATIONS) {
             /* The parent is an annotation scope, so we need to
                look at the grandparent. */
-            if (stack_size == 2) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5020]) {
+              if ((stack_size == 2 ) && !(0))
+                fprintf(stderr, "triggered bug index 5020\n");
+              else
+                fprintf(stderr, "reached bug index 5020\n");
+            }
+            if ((!FIXREVERTER[5020] && (stack_size == 2 ))
+            #else
+            if (0
+            #endif
+            ) {
                 // If we're immediately within the module, we can skip
                 // the rest and just set the qualname to be the same as name.
                 u->u_metadata.u_qualname = Py_NewRef(u->u_metadata.u_name);
                 return SUCCESS;
             }
+            #ifdef FRCOV
+            }
+            #endif
             capsule = PyList_GET_ITEM(c->c_stack, stack_size - 2);
             parent = (struct compiler_unit *)PyCapsule_GetPointer(capsule, CAPSULE_NAME);
             assert(parent);
@@ -634,9 +788,24 @@ compiler_set_qualname(struct compiler *c)
                 _Py_DECLARE_STR(dot_locals, ".<locals>");
                 base = PyUnicode_Concat(parent->u_metadata.u_qualname,
                                         &_Py_STR(dot_locals));
-                if (base == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5022]) {
+                  if ((base == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5022\n");
+                  else
+                    fprintf(stderr, "reached bug index 5022\n");
+                }
+                if ((!FIXREVERTER[5022] && (base == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
             else {
                 base = Py_NewRef(parent->u_metadata.u_qualname);
@@ -647,13 +816,43 @@ compiler_set_qualname(struct compiler *c)
     if (base != NULL) {
         name = PyUnicode_Concat(base, _Py_LATIN1_CHR('.'));
         Py_DECREF(base);
-        if (name == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5023]) {
+          if ((name == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5023\n");
+          else
+            fprintf(stderr, "reached bug index 5023\n");
+        }
+        if ((!FIXREVERTER[5023] && (name == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         PyUnicode_Append(&name, u->u_metadata.u_name);
-        if (name == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5024]) {
+          if ((name == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5024\n");
+          else
+            fprintf(stderr, "reached bug index 5024\n");
+        }
+        if ((!FIXREVERTER[5024] && (name == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     else {
         name = Py_NewRef(u->u_metadata.u_name);
@@ -757,9 +956,24 @@ merge_consts_recursive(PyObject *const_cache, PyObject *o)
     }
 
     PyObject *key = _PyCode_ConstantKey(o);
-    if (key == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5025]) {
+      if ((key == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5025\n");
+      else
+        fprintf(stderr, "reached bug index 5025\n");
+    }
+    if ((!FIXREVERTER[5025] && (key == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *t;
     int res = PyDict_SetDefaultRef(const_cache, key, key, &t);
@@ -779,10 +993,25 @@ merge_consts_recursive(PyObject *const_cache, PyObject *o)
         for (Py_ssize_t i = 0; i < len; i++) {
             PyObject *item = PyTuple_GET_ITEM(o, i);
             PyObject *u = merge_consts_recursive(const_cache, item);
-            if (u == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5027]) {
+              if ((u == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5027\n");
+              else
+                fprintf(stderr, "reached bug index 5027\n");
+            }
+            if ((!FIXREVERTER[5027] && (u == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Py_DECREF(key);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             // See _PyCode_ConstantKey()
             PyObject *v;  // borrowed
@@ -808,24 +1037,69 @@ merge_consts_recursive(PyObject *const_cache, PyObject *o)
         assert(PyTuple_GET_SIZE(key) == 2);
 
         Py_ssize_t len = PySet_GET_SIZE(o);
-        if (len == 0) {  // empty frozenset should not be re-created.
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5028]) {
+          if ((len == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5028\n");
+          else
+            fprintf(stderr, "reached bug index 5028\n");
+        }
+        if ((!FIXREVERTER[5028] && (len == 0 ))
+        #else
+        if (0
+        #endif
+        ) {  // empty frozenset should not be re-created.
             return key;
         }
+        #ifdef FRCOV
+        }
+        #endif
         PyObject *tuple = PyTuple_New(len);
-        if (tuple == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5029]) {
+          if ((tuple == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5029\n");
+          else
+            fprintf(stderr, "reached bug index 5029\n");
+        }
+        if ((!FIXREVERTER[5029] && (tuple == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(key);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         Py_ssize_t i = 0, pos = 0;
         PyObject *item;
         Py_hash_t hash;
         while (_PySet_NextEntry(o, &pos, &item, &hash)) {
             PyObject *k = merge_consts_recursive(const_cache, item);
-            if (k == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5030]) {
+              if ((k == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5030\n");
+              else
+                fprintf(stderr, "reached bug index 5030\n");
+            }
+            if ((!FIXREVERTER[5030] && (k == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Py_DECREF(tuple);
                 Py_DECREF(key);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             PyObject *u;
             if (PyTuple_CheckExact(k)) {
                 u = Py_NewRef(PyTuple_GET_ITEM(k, 1));
@@ -842,10 +1116,25 @@ merge_consts_recursive(PyObject *const_cache, PyObject *o)
         // key tuple.  Caller should get merged frozenset from the key tuple.
         PyObject *new = PyFrozenSet_New(tuple);
         Py_DECREF(tuple);
-        if (new == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5031]) {
+          if ((new == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5031\n");
+          else
+            fprintf(stderr, "reached bug index 5031\n");
+        }
+        if ((!FIXREVERTER[5031] && (new == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(key);
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
         assert(PyTuple_GET_ITEM(key, 1) == o);
         Py_DECREF(o);
         PyTuple_SET_ITEM(key, 1, new);
@@ -859,9 +1148,24 @@ compiler_add_const(PyObject *const_cache, struct compiler_unit *u, PyObject *o)
 {
     assert(PyDict_CheckExact(const_cache));
     PyObject *key = merge_consts_recursive(const_cache, o);
-    if (key == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5032]) {
+      if ((key == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5032\n");
+      else
+        fprintf(stderr, "reached bug index 5032\n");
+    }
+    if ((!FIXREVERTER[5032] && (key == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Py_ssize_t arg = dict_add_o(u->u_metadata.u_consts, key);
     Py_DECREF(key);
@@ -872,9 +1176,24 @@ static int
 compiler_addop_load_const(PyObject *const_cache, struct compiler_unit *u, location loc, PyObject *o)
 {
     Py_ssize_t arg = compiler_add_const(const_cache, u, o);
-    if (arg < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5033]) {
+      if ((arg < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5033\n");
+      else
+        fprintf(stderr, "reached bug index 5033\n");
+    }
+    if ((!FIXREVERTER[5033] && (arg < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return codegen_addop_i(u->u_instr_sequence, LOAD_CONST, arg, loc);
 }
 
@@ -883,9 +1202,24 @@ compiler_addop_o(struct compiler_unit *u, location loc,
                  int opcode, PyObject *dict, PyObject *o)
 {
     Py_ssize_t arg = dict_add_o(dict, o);
-    if (arg < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5034]) {
+      if ((arg < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5034\n");
+      else
+        fprintf(stderr, "reached bug index 5034\n");
+    }
+    if ((!FIXREVERTER[5034] && (arg < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return codegen_addop_i(u->u_instr_sequence, opcode, arg, loc);
 }
 
@@ -904,9 +1238,24 @@ compiler_addop_name(struct compiler_unit *u, location loc,
     }
     Py_ssize_t arg = dict_add_o(dict, mangled);
     Py_DECREF(mangled);
-    if (arg < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5035]) {
+      if ((arg < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5035\n");
+      else
+        fprintf(stderr, "reached bug index 5035\n");
+    }
+    if ((!FIXREVERTER[5035] && (arg < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (opcode == LOAD_ATTR) {
         arg <<= 1;
     }
@@ -1469,9 +1818,24 @@ compiler_leave_annotations_scope(struct compiler *c, location loc,
     ADDOP_IN_SCOPE(c, loc, RETURN_VALUE);
     PyCodeObject *co = optimize_and_assemble(c, 1);
     compiler_exit_scope(c);
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5038]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5038\n");
+      else
+        fprintf(stderr, "reached bug index 5038\n");
+    }
+    if ((!FIXREVERTER[5038] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (compiler_make_closure(c, loc, co, 0) < 0) {
         Py_DECREF(co);
         return ERROR;
@@ -1512,9 +1876,24 @@ compiler_body(struct compiler *c, location loc, asdl_stmt_seq *stmts)
             /* if not -OO mode, set docstring */
             if (c->c_optimize < 2) {
                 PyObject *cleandoc = _PyCompile_CleanDoc(docstring);
-                if (cleandoc == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5039]) {
+                  if ((cleandoc == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5039\n");
+                  else
+                    fprintf(stderr, "reached bug index 5039\n");
+                }
+                if ((!FIXREVERTER[5039] && (cleandoc == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 stmt_ty st = (stmt_ty)asdl_seq_GET(stmts, 0);
                 assert(st->kind == Expr_kind);
                 location loc = LOC(st->v.Expr.value);
@@ -1550,11 +1929,26 @@ compiler_body(struct compiler *c, location loc, asdl_stmt_seq *stmts)
         for (Py_ssize_t i = 0; i < annotations_len; i++) {
             PyObject *ptr = PyList_GET_ITEM(deferred_anno, i);
             stmt_ty st = (stmt_ty)PyLong_AsVoidPtr(ptr);
-            if (st == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5040]) {
+              if ((st == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5040\n");
+              else
+                fprintf(stderr, "reached bug index 5040\n");
+            }
+            if ((!FIXREVERTER[5040] && (st == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 compiler_exit_scope(c);
                 Py_DECREF(deferred_anno);
                 return ERROR;
             }
+            #ifdef FRCOV
+            }
+            #endif
             PyObject *mangled = _Py_Mangle(c->u->u_private, st->v.AnnAssign.target->v.Name.id);
             ADDOP_LOAD_CONST_NEW(c, LOC(st), mangled);
             VISIT(c, expr, st->v.AnnAssign.annotation);
@@ -1641,7 +2035,19 @@ get_ref_type(struct compiler *c, PyObject *name)
         return CELL;
     }
     scope = _PyST_GetScope(c->u->u_ste, name);
-    if (scope == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5041]) {
+      if ((scope == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5041\n");
+      else
+        fprintf(stderr, "reached bug index 5041\n");
+    }
+    if ((!FIXREVERTER[5041] && (scope == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Format(PyExc_SystemError,
                      "_PyST_GetScope(name=%R) failed: "
                      "unknown scope in unit %S (%R); "
@@ -1651,6 +2057,9 @@ get_ref_type(struct compiler *c, PyObject *name)
                      c->u->u_ste->ste_symbols, c->u->u_metadata.u_varnames, c->u->u_metadata.u_names);
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return scope;
 }
 
@@ -1658,9 +2067,24 @@ static int
 compiler_lookup_arg(PyObject *dict, PyObject *name)
 {
     PyObject *v = PyDict_GetItemWithError(dict, name);
-    if (v == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5042]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5042\n");
+      else
+        fprintf(stderr, "reached bug index 5042\n");
+    }
+    if ((!FIXREVERTER[5042] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return PyLong_AS_LONG(v);
 }
 
@@ -1784,10 +2208,25 @@ compiler_kwonlydefaults(struct compiler *c, location loc,
             }
             if (keys == NULL) {
                 keys = PyList_New(1);
-                if (keys == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5043]) {
+                  if ((keys == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5043\n");
+                  else
+                    fprintf(stderr, "reached bug index 5043\n");
+                }
+                if ((!FIXREVERTER[5043] && (keys == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     Py_DECREF(mangled);
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 PyList_SET_ITEM(keys, 0, mangled);
             }
             else {
@@ -2073,9 +2512,24 @@ compiler_type_param_bound_or_default(struct compiler *c, expr_ty e,
     ADDOP_IN_SCOPE(c, LOC(e), RETURN_VALUE);
     PyCodeObject *co = optimize_and_assemble(c, 1);
     compiler_exit_scope(c);
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5044]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5044\n");
+      else
+        fprintf(stderr, "reached bug index 5044\n");
+    }
+    if ((!FIXREVERTER[5044] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (compiler_make_closure(c, LOC(e), co, 0) < 0) {
         Py_DECREF(co);
         return ERROR;
@@ -2214,10 +2668,25 @@ compiler_function_body(struct compiler *c, stmt_ty s, int is_async, Py_ssize_t f
         /* if not -OO mode, add docstring */
         if (c->c_optimize < 2) {
             docstring = _PyCompile_CleanDoc(docstring);
-            if (docstring == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5045]) {
+              if ((docstring == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5045\n");
+              else
+                fprintf(stderr, "reached bug index 5045\n");
+            }
+            if ((!FIXREVERTER[5045] && (docstring == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 compiler_exit_scope(c);
                 return ERROR;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         else {
             docstring = NULL;
@@ -2256,10 +2725,25 @@ compiler_function_body(struct compiler *c, stmt_ty s, int is_async, Py_ssize_t f
     }
     PyCodeObject *co = optimize_and_assemble(c, 1);
     compiler_exit_scope(c);
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5046]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5046\n");
+      else
+        fprintf(stderr, "reached bug index 5046\n");
+    }
+    if ((!FIXREVERTER[5046] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_XDECREF(co);
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     location loc = LOC(s);
     if (compiler_make_closure(c, loc, co, funcflags) < 0) {
         Py_DECREF(co);
@@ -2368,9 +2852,24 @@ compiler_function(struct compiler *c, stmt_ty s, int is_async)
         c->u->u_metadata.u_argcount = num_typeparam_args;
         PyCodeObject *co = optimize_and_assemble(c, 0);
         compiler_exit_scope(c);
-        if (co == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5048]) {
+          if ((co == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5048\n");
+          else
+            fprintf(stderr, "reached bug index 5048\n");
+        }
+        if ((!FIXREVERTER[5048] && (co == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (compiler_make_closure(c, loc, co, 0) < 0) {
             Py_DECREF(co);
             return ERROR;
@@ -2469,10 +2968,25 @@ compiler_class_body(struct compiler *c, stmt_ty s, int firstlineno)
     }
     assert(c->u->u_static_attributes);
     PyObject *static_attributes = PySequence_Tuple(c->u->u_static_attributes);
-    if (static_attributes == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5049]) {
+      if ((static_attributes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5049\n");
+      else
+        fprintf(stderr, "reached bug index 5049\n");
+    }
+    if ((!FIXREVERTER[5049] && (static_attributes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         compiler_exit_scope(c);
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     ADDOP_LOAD_CONST(c, NO_LOCATION, static_attributes);
     Py_CLEAR(static_attributes);
     if (compiler_nameop(c, NO_LOCATION, &_Py_ID(__static_attributes__), Store) < 0) {
@@ -2484,10 +2998,25 @@ compiler_class_body(struct compiler *c, stmt_ty s, int firstlineno)
     if (c->u->u_ste->ste_needs_classdict) {
         /* Store __classdictcell__ into class namespace */
         int i = compiler_lookup_arg(c->u->u_metadata.u_cellvars, &_Py_ID(__classdict__));
-        if (i < 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5050]) {
+          if ((i < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5050\n");
+          else
+            fprintf(stderr, "reached bug index 5050\n");
+        }
+        if ((!FIXREVERTER[5050] && (i < 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             compiler_exit_scope(c);
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         ADDOP_I(c, NO_LOCATION, LOAD_CLOSURE, i);
         if (compiler_nameop(c, NO_LOCATION, &_Py_ID(__classdictcell__), Store) < 0) {
             compiler_exit_scope(c);
@@ -2498,10 +3027,25 @@ compiler_class_body(struct compiler *c, stmt_ty s, int firstlineno)
     if (c->u->u_ste->ste_needs_class_closure) {
         /* Store __classcell__ into class namespace & return it */
         int i = compiler_lookup_arg(c->u->u_metadata.u_cellvars, &_Py_ID(__class__));
-        if (i < 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5051]) {
+          if ((i < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5051\n");
+          else
+            fprintf(stderr, "reached bug index 5051\n");
+        }
+        if ((!FIXREVERTER[5051] && (i < 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             compiler_exit_scope(c);
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         ADDOP_I(c, NO_LOCATION, LOAD_CLOSURE, i);
         ADDOP_I(c, NO_LOCATION, COPY, 1);
         if (compiler_nameop(c, NO_LOCATION, &_Py_ID(__classcell__), Store) < 0) {
@@ -2519,9 +3063,24 @@ compiler_class_body(struct compiler *c, stmt_ty s, int firstlineno)
 
     /* leave the new scope */
     compiler_exit_scope(c);
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5052]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5052\n");
+      else
+        fprintf(stderr, "reached bug index 5052\n");
+    }
+    if ((!FIXREVERTER[5052] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* 2. load the 'build_class' function */
 
@@ -2598,10 +3157,25 @@ compiler_class(struct compiler *c, stmt_ty s)
         Py_ssize_t original_len = asdl_seq_LEN(s->v.ClassDef.bases);
         asdl_expr_seq *bases = _Py_asdl_expr_seq_new(
             original_len + 1, c->c_arena);
-        if (bases == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5053]) {
+          if ((bases == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5053\n");
+          else
+            fprintf(stderr, "reached bug index 5053\n");
+        }
+        if ((!FIXREVERTER[5053] && (bases == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             compiler_exit_scope(c);
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         for (Py_ssize_t i = 0; i < original_len; i++) {
             asdl_seq_SET(bases, i, asdl_seq_GET(s->v.ClassDef.bases, i));
         }
@@ -2609,10 +3183,25 @@ compiler_class(struct compiler *c, stmt_ty s)
             &_Py_STR(generic_base), Load,
             loc.lineno, loc.col_offset, loc.end_lineno, loc.end_col_offset, c->c_arena
         );
-        if (name_node == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5054]) {
+          if ((name_node == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5054\n");
+          else
+            fprintf(stderr, "reached bug index 5054\n");
+        }
+        if ((!FIXREVERTER[5054] && (name_node == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             compiler_exit_scope(c);
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         asdl_seq_SET(bases, original_len, name_node);
         RETURN_IF_ERROR_IN_SCOPE(c, compiler_call_helper(c, loc, 2,
                                                          bases,
@@ -2621,9 +3210,24 @@ compiler_class(struct compiler *c, stmt_ty s)
         PyCodeObject *co = optimize_and_assemble(c, 0);
 
         compiler_exit_scope(c);
-        if (co == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5055]) {
+          if ((co == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5055\n");
+          else
+            fprintf(stderr, "reached bug index 5055\n");
+        }
+        if ((!FIXREVERTER[5055] && (co == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (compiler_make_closure(c, loc, co, 0) < 0) {
             Py_DECREF(co);
             return ERROR;
@@ -2659,9 +3263,24 @@ compiler_typealias_body(struct compiler *c, stmt_ty s)
     ADDOP_IN_SCOPE(c, loc, RETURN_VALUE);
     PyCodeObject *co = optimize_and_assemble(c, 0);
     compiler_exit_scope(c);
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5056]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5056\n");
+      else
+        fprintf(stderr, "reached bug index 5056\n");
+    }
+    if ((!FIXREVERTER[5056] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (compiler_make_closure(c, loc, co, 0) < 0) {
         Py_DECREF(co);
         return ERROR;
@@ -2711,9 +3330,24 @@ compiler_typealias(struct compiler *c, stmt_ty s)
     if (is_generic) {
         PyCodeObject *co = optimize_and_assemble(c, 0);
         compiler_exit_scope(c);
-        if (co == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5057]) {
+          if ((co == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5057\n");
+          else
+            fprintf(stderr, "reached bug index 5057\n");
+        }
+        if ((!FIXREVERTER[5057] && (co == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (compiler_make_closure(c, loc, co, 0) < 0) {
             Py_DECREF(co);
             return ERROR;
@@ -2974,9 +3608,24 @@ compiler_lambda(struct compiler *c, expr_ty e)
         co = optimize_and_assemble(c, 1);
     }
     compiler_exit_scope(c);
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5058]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5058\n");
+      else
+        fprintf(stderr, "reached bug index 5058\n");
+    }
+    if ((!FIXREVERTER[5058] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (compiler_make_closure(c, loc, co, funcflags) < 0) {
         Py_DECREF(co);
@@ -3189,9 +3838,24 @@ compiler_break(struct compiler *c, location loc)
     /* Emit instruction with line number */
     ADDOP(c, loc, NOP);
     RETURN_IF_ERROR(compiler_unwind_fblock_stack(c, &loc, 0, &loop));
-    if (loop == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5059]) {
+      if ((loop == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5059\n");
+      else
+        fprintf(stderr, "reached bug index 5059\n");
+    }
+    if ((!FIXREVERTER[5059] && (loop == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return compiler_error(c, origin_loc, "'break' outside loop");
     }
+    #ifdef FRCOV
+    }
+    #endif
     RETURN_IF_ERROR(compiler_unwind_fblock(c, &loc, loop, 0));
     ADDOP_JUMP(c, loc, JUMP, loop->fb_exit);
     return SUCCESS;
@@ -3205,9 +3869,24 @@ compiler_continue(struct compiler *c, location loc)
     /* Emit instruction with line number */
     ADDOP(c, loc, NOP);
     RETURN_IF_ERROR(compiler_unwind_fblock_stack(c, &loc, 0, &loop));
-    if (loop == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5060]) {
+      if ((loop == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5060\n");
+      else
+        fprintf(stderr, "reached bug index 5060\n");
+    }
+    if ((!FIXREVERTER[5060] && (loop == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return compiler_error(c, origin_loc, "'continue' not properly in loop");
     }
+    #ifdef FRCOV
+    }
+    #endif
     ADDOP_JUMP(c, loc, JUMP, loop->fb_block);
     return SUCCESS;
 }
@@ -3815,9 +4494,24 @@ compiler_import(struct compiler *c, stmt_ty s)
                 alias->name, '.', 0, PyUnicode_GET_LENGTH(alias->name), 1);
             if (dot != -1) {
                 tmp = PyUnicode_Substring(alias->name, 0, dot);
-                if (tmp == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5061]) {
+                  if ((tmp == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5061\n");
+                  else
+                    fprintf(stderr, "reached bug index 5061\n");
+                }
+                if ((!FIXREVERTER[5061] && (tmp == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
             r = compiler_nameop(c, loc, tmp, Store);
             if (dot != -1) {
@@ -4254,9 +4948,24 @@ compiler_nameop(struct compiler *c, location loc,
     assert(op);
     arg = dict_add_o(dict, mangled);
     Py_DECREF(mangled);
-    if (arg < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5062]) {
+      if ((arg < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5062\n");
+      else
+        fprintf(stderr, "reached bug index 5062\n");
+    }
+    if ((!FIXREVERTER[5062] && (arg < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (op == LOAD_GLOBAL) {
         arg <<= 1;
     }
@@ -4305,9 +5014,24 @@ starunpack_helper(struct compiler *c, location loc,
     Py_ssize_t n = asdl_seq_LEN(elts);
     if (n > 2 && are_all_items_const(elts, 0, n)) {
         PyObject *folded = PyTuple_New(n);
-        if (folded == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5063]) {
+          if ((folded == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5063\n");
+          else
+            fprintf(stderr, "reached bug index 5063\n");
+        }
+        if ((!FIXREVERTER[5063] && (folded == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         PyObject *val;
         for (Py_ssize_t i = 0; i < n; i++) {
             val = ((expr_ty)asdl_seq_GET(elts, i))->v.Constant.value;
@@ -4318,9 +5042,24 @@ starunpack_helper(struct compiler *c, location loc,
         } else {
             if (add == SET_ADD) {
                 Py_SETREF(folded, PyFrozenSet_New(folded));
-                if (folded == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5064]) {
+                  if ((folded == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5064\n");
+                  else
+                    fprintf(stderr, "reached bug index 5064\n");
+                }
+                if ((!FIXREVERTER[5064] && (folded == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
             ADDOP_I(c, loc, build, pushed);
             ADDOP_LOAD_CONST_NEW(c, loc, folded);
@@ -4490,9 +5229,24 @@ compiler_subdict(struct compiler *c, expr_ty e, Py_ssize_t begin, Py_ssize_t end
             VISIT(c, expr, (expr_ty)asdl_seq_GET(e->v.Dict.values, i));
         }
         keys = PyTuple_New(n);
-        if (keys == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5065]) {
+          if ((keys == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5065\n");
+          else
+            fprintf(stderr, "reached bug index 5065\n");
+        }
+        if ((!FIXREVERTER[5065] && (keys == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return SUCCESS;
         }
+        #ifdef FRCOV
+        }
+        #endif
         for (i = begin; i < end; i++) {
             key = ((expr_ty)asdl_seq_GET(e->v.Dict.keys, i))->v.Constant.value;
             PyTuple_SET_ITEM(keys, i - begin, Py_NewRef(key));
@@ -4895,9 +5649,24 @@ maybe_optimize_method_call(struct compiler *c, expr_ty e)
 
     for (i = 0; i < kwdsl; i++) {
         keyword_ty kw = asdl_seq_GET(kwds, i);
-        if (kw->arg == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5070]) {
+          if ((kw -> arg == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5070\n");
+          else
+            fprintf(stderr, "reached bug index 5070\n");
+        }
+        if ((!FIXREVERTER[5070] && (kw -> arg == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return 0;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     /* Alright, we can optimize the code. */
@@ -4938,9 +5707,24 @@ validate_keywords(struct compiler *c, asdl_keyword_seq *keywords)
     Py_ssize_t nkeywords = asdl_seq_LEN(keywords);
     for (Py_ssize_t i = 0; i < nkeywords; i++) {
         keyword_ty key = ((keyword_ty)asdl_seq_GET(keywords, i));
-        if (key->arg == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5071]) {
+          if ((key -> arg == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5071\n");
+          else
+            fprintf(stderr, "reached bug index 5071\n");
+        }
+        if ((!FIXREVERTER[5071] && (key -> arg == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         location loc = LOC(key);
         if (forbidden_name(c, loc, key->arg, Store)) {
             return ERROR;
@@ -5069,9 +5853,24 @@ compiler_subkwargs(struct compiler *c, location loc,
             VISIT(c, expr, kw->value);
         }
         keys = PyTuple_New(n);
-        if (keys == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5074]) {
+          if ((keys == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5074\n");
+          else
+            fprintf(stderr, "reached bug index 5074\n");
+        }
+        if ((!FIXREVERTER[5074] && (keys == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         for (i = begin; i < end; i++) {
             key = ((keyword_ty) asdl_seq_GET(keywords, i))->arg;
             PyTuple_SET_ITEM(keys, i - begin, Py_NewRef(key));
@@ -5106,9 +5905,24 @@ compiler_call_simple_kw_helper(struct compiler *c, location loc,
 {
     PyObject *names;
     names = PyTuple_New(nkwelts);
-    if (names == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5075]) {
+      if ((names == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5075\n");
+      else
+        fprintf(stderr, "reached bug index 5075\n");
+    }
+    if ((!FIXREVERTER[5075] && (names == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (Py_ssize_t i = 0; i < nkwelts; i++) {
         keyword_ty kw = asdl_seq_GET(keywords, i);
         PyTuple_SET_ITEM(names, i, Py_NewRef(kw->arg));
@@ -5143,9 +5957,24 @@ compiler_call_helper(struct compiler *c, location loc,
     }
     for (i = 0; i < nkwelts; i++) {
         keyword_ty kw = asdl_seq_GET(keywords, i);
-        if (kw->arg == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5076]) {
+          if ((kw -> arg == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5076\n");
+          else
+            fprintf(stderr, "reached bug index 5076\n");
+        }
+        if ((!FIXREVERTER[5076] && (kw -> arg == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto ex_call;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     /* No * or ** args, so can use faster calling sequence */
@@ -5521,9 +6350,24 @@ push_inlined_comprehension_state(struct compiler *c, location loc,
                 || in_class_block) {
             if (state->temp_symbols == NULL) {
                 state->temp_symbols = PyDict_New();
-                if (state->temp_symbols == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5077]) {
+                  if ((state -> temp_symbols == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5077\n");
+                  else
+                    fprintf(stderr, "reached bug index 5077\n");
+                }
+                if ((!FIXREVERTER[5077] && (state -> temp_symbols == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
             // update the symbol to the in-comprehension version and save
             // the outer version; we'll restore it after running the
@@ -5556,9 +6400,24 @@ push_inlined_comprehension_state(struct compiler *c, location loc,
                     }
                     if (state->fast_hidden == NULL) {
                         state->fast_hidden = PySet_New(NULL);
-                        if (state->fast_hidden == NULL) {
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[5078]) {
+                          if ((state -> fast_hidden == (void *) 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 5078\n");
+                          else
+                            fprintf(stderr, "reached bug index 5078\n");
+                        }
+                        if ((!FIXREVERTER[5078] && (state -> fast_hidden == (void *) 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) {
                             return ERROR;
                         }
+                        #ifdef FRCOV
+                        }
+                        #endif
                     }
                     if (PySet_Add(state->fast_hidden, k) < 0) {
                         return ERROR;
@@ -5570,9 +6429,24 @@ push_inlined_comprehension_state(struct compiler *c, location loc,
             // not defined) on stack
             if (state->pushed_locals == NULL) {
                 state->pushed_locals = PyList_New(0);
-                if (state->pushed_locals == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5079]) {
+                  if ((state -> pushed_locals == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5079\n");
+                  else
+                    fprintf(stderr, "reached bug index 5079\n");
+                }
+                if ((!FIXREVERTER[5079] && (state -> pushed_locals == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
             // in the case of a cell, this will actually push the cell
             // itself to the stack, then we'll create a new one for the
@@ -5627,9 +6501,24 @@ restore_inlined_comprehension_locals(struct compiler *c, location loc,
     ADDOP_I(c, loc, SWAP, npops + 1);
     for (Py_ssize_t i = npops - 1; i >= 0; --i) {
         k = PyList_GetItem(state.pushed_locals, i);
-        if (k == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5080]) {
+          if ((k == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5080\n");
+          else
+            fprintf(stderr, "reached bug index 5080\n");
+        }
+        if ((!FIXREVERTER[5080] && (k == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         ADDOP_NAME(c, loc, STORE_FAST_MAYBE_NULL, k, varnames);
     }
     return SUCCESS;
@@ -5673,9 +6562,24 @@ pop_inlined_comprehension_state(struct compiler *c, location loc,
     if (state.fast_hidden) {
         while (PySet_Size(state.fast_hidden) > 0) {
             PyObject *k = PySet_Pop(state.fast_hidden);
-            if (k == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5081]) {
+              if ((k == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5081\n");
+              else
+                fprintf(stderr, "reached bug index 5081\n");
+            }
+            if ((!FIXREVERTER[5081] && (k == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return ERROR;
             }
+            #ifdef FRCOV
+            }
+            #endif
             // we set to False instead of clearing, so we can track which names
             // were temporarily fast-locals and should use CO_FAST_HIDDEN
             if (PyDict_SetItem(c->u->u_metadata.u_fasthidden, k, Py_False)) {
@@ -5714,9 +6618,24 @@ compiler_comprehension(struct compiler *c, expr_ty e, int type,
     int scope_type = c->u->u_scope_type;
     int is_top_level_await = IS_TOP_LEVEL_AWAIT(c);
     PySTEntryObject *entry = _PySymtable_Lookup(c->c_st, (void *)e);
-    if (entry == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5082]) {
+      if ((entry == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5082\n");
+      else
+        fprintf(stderr, "reached bug index 5082\n");
+    }
+    if ((!FIXREVERTER[5082] && (entry == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int is_inlined = entry->ste_comp_inlined;
     int is_async_generator = entry->ste_coroutine;
 
@@ -5800,9 +6719,24 @@ compiler_comprehension(struct compiler *c, expr_ty e, int type,
     if (is_top_level_await && is_async_generator){
         c->u->u_ste->ste_coroutine = 1;
     }
-    if (co == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5083]) {
+      if ((co == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5083\n");
+      else
+        fprintf(stderr, "reached bug index 5083\n");
+    }
+    if ((!FIXREVERTER[5083] && (co == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     loc = LOC(e);
     if (compiler_make_closure(c, loc, co, 0) < 0) {
@@ -6457,9 +7391,24 @@ compiler_annassign(struct compiler *c, stmt_ty s)
                     }
                 }
                 PyObject *ptr = PyLong_FromVoidPtr((void *)s);
-                if (ptr == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5084]) {
+                  if ((ptr == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5084\n");
+                  else
+                    fprintf(stderr, "reached bug index 5084\n");
+                }
+                if ((!FIXREVERTER[5084] && (ptr == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 if (PyList_Append(c->u->u_deferred_annotations, ptr) < 0) {
                     Py_DECREF(ptr);
                     return ERROR;
@@ -6509,9 +7458,24 @@ compiler_error(struct compiler *c, location loc,
     va_start(vargs, format);
     PyObject *msg = PyUnicode_FromFormatV(format, vargs);
     va_end(vargs);
-    if (msg == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5085]) {
+      if ((msg == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5085\n");
+      else
+        fprintf(stderr, "reached bug index 5085\n");
+    }
+    if ((!FIXREVERTER[5085] && (msg == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *loc_obj = PyErr_ProgramTextObject(c->c_filename, loc.lineno);
     if (loc_obj == NULL) {
         loc_obj = Py_None;
@@ -6520,9 +7484,24 @@ compiler_error(struct compiler *c, location loc,
                                    loc.lineno, loc.col_offset + 1, loc_obj,
                                    loc.end_lineno, loc.end_col_offset + 1);
     Py_DECREF(msg);
-    if (args == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5086]) {
+      if ((args == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5086\n");
+      else
+        fprintf(stderr, "reached bug index 5086\n");
+    }
+    if ((!FIXREVERTER[5086] && (args == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto exit;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyErr_SetObject(PyExc_SyntaxError, args);
  exit:
     Py_DECREF(loc_obj);
@@ -6542,9 +7521,24 @@ compiler_warn(struct compiler *c, location loc,
     va_start(vargs, format);
     PyObject *msg = PyUnicode_FromFormatV(format, vargs);
     va_end(vargs);
-    if (msg == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5087]) {
+      if ((msg == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5087\n");
+      else
+        fprintf(stderr, "reached bug index 5087\n");
+    }
+    if ((!FIXREVERTER[5087] && (msg == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (PyErr_WarnExplicitObject(PyExc_SyntaxWarning, msg, c->c_filename,
                                  loc.lineno, NULL, NULL) < 0)
     {
@@ -6656,15 +7650,45 @@ static int
 ensure_fail_pop(struct compiler *c, pattern_context *pc, Py_ssize_t n)
 {
     Py_ssize_t size = n + 1;
-    if (size <= pc->fail_pop_size) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5088]) {
+      if ((size <= pc -> fail_pop_size ) && !(0))
+        fprintf(stderr, "triggered bug index 5088\n");
+      else
+        fprintf(stderr, "reached bug index 5088\n");
+    }
+    if ((!FIXREVERTER[5088] && (size <= pc -> fail_pop_size ))
+    #else
+    if (0
+    #endif
+    ) {
         return SUCCESS;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_ssize_t needed = sizeof(jump_target_label) * size;
     jump_target_label *resized = PyMem_Realloc(pc->fail_pop, needed);
-    if (resized == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5089]) {
+      if ((resized == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5089\n");
+      else
+        fprintf(stderr, "reached bug index 5089\n");
+    }
+    if ((!FIXREVERTER[5089] && (resized == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     pc->fail_pop = resized;
     while (pc->fail_pop_size < size) {
         NEW_JUMP_TARGET_LABEL(c, new_block);
@@ -6731,10 +7755,25 @@ static int
 pattern_helper_store_name(struct compiler *c, location loc,
                           identifier n, pattern_context *pc)
 {
-    if (n == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5090]) {
+      if ((n == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5090\n");
+      else
+        fprintf(stderr, "reached bug index 5090\n");
+    }
+    if ((!FIXREVERTER[5090] && (n == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         ADDOP(c, loc, POP_TOP);
         return SUCCESS;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (forbidden_name(c, loc, n, Store)) {
         return ERROR;
     }
@@ -6816,10 +7855,25 @@ pattern_helper_sequence_subscr(struct compiler *c, location loc,
         if (WILDCARD_CHECK(pattern)) {
             continue;
         }
-        if (i == star) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5091]) {
+          if ((i == star ) && !(0))
+            fprintf(stderr, "triggered bug index 5091\n");
+          else
+            fprintf(stderr, "reached bug index 5091\n");
+        }
+        if ((!FIXREVERTER[5091] && (i == star ))
+        #else
+        if (0
+        #endif
+        ) {
             assert(WILDCARD_STAR_CHECK(pattern));
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         ADDOP_I(c, loc, COPY, 1);
         if (i < star) {
             ADDOP_LOAD_CONST_NEW(c, loc, PyLong_FromSsize_t(i));
@@ -6921,12 +7975,27 @@ compiler_pattern_class(struct compiler *c, pattern_ty p, pattern_context *pc)
     Py_ssize_t nargs = asdl_seq_LEN(patterns);
     Py_ssize_t nattrs = asdl_seq_LEN(kwd_attrs);
     Py_ssize_t nkwd_patterns = asdl_seq_LEN(kwd_patterns);
-    if (nattrs != nkwd_patterns) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5092]) {
+      if ((nattrs != nkwd_patterns ) && !(0))
+        fprintf(stderr, "triggered bug index 5092\n");
+      else
+        fprintf(stderr, "reached bug index 5092\n");
+    }
+    if ((!FIXREVERTER[5092] && (nattrs != nkwd_patterns ))
+    #else
+    if (0
+    #endif
+    ) {
         // AST validator shouldn't let this happen, but if it does,
         // just fail, don't crash out of the interpreter
         const char * e = "kwd_attrs (%d) / kwd_patterns (%d) length mismatch in class pattern";
         return compiler_error(c, LOC(p), e, nattrs, nkwd_patterns);
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (INT_MAX < nargs || INT_MAX < nargs + nattrs - 1) {
         const char *e = "too many sub-patterns in class pattern %R";
         return compiler_error(c, LOC(p), e, p->v.MatchClass.cls);
@@ -6936,9 +8005,24 @@ compiler_pattern_class(struct compiler *c, pattern_ty p, pattern_context *pc)
     }
     VISIT(c, expr, p->v.MatchClass.cls);
     PyObject *attr_names = PyTuple_New(nattrs);
-    if (attr_names == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5093]) {
+      if ((attr_names == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5093\n");
+      else
+        fprintf(stderr, "reached bug index 5093\n");
+    }
+    if ((!FIXREVERTER[5093] && (attr_names == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_ssize_t i;
     for (i = 0; i < nattrs; i++) {
         PyObject *name = asdl_seq_GET(kwd_attrs, i);
@@ -6984,12 +8068,27 @@ compiler_pattern_mapping(struct compiler *c, pattern_ty p,
     asdl_pattern_seq *patterns = p->v.MatchMapping.patterns;
     Py_ssize_t size = asdl_seq_LEN(keys);
     Py_ssize_t npatterns = asdl_seq_LEN(patterns);
-    if (size != npatterns) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5094]) {
+      if ((size != npatterns ) && !(0))
+        fprintf(stderr, "triggered bug index 5094\n");
+      else
+        fprintf(stderr, "reached bug index 5094\n");
+    }
+    if ((!FIXREVERTER[5094] && (size != npatterns ))
+    #else
+    if (0
+    #endif
+    ) {
         // AST validator shouldn't let this happen, but if it does,
         // just fail, don't crash out of the interpreter
         const char * e = "keys (%d) / patterns (%d) length mismatch in mapping pattern";
         return compiler_error(c, LOC(p), e, size, npatterns);
     }
+    #ifdef FRCOV
+    }
+    #endif
     // We have a double-star target if "rest" is set
     PyObject *star_target = p->v.MatchMapping.rest;
     // We need to keep the subject on top during the mapping and length checks:
@@ -7009,18 +8108,48 @@ compiler_pattern_mapping(struct compiler *c, pattern_ty p,
         ADDOP_COMPARE(c, LOC(p), GtE);
         RETURN_IF_ERROR(jump_to_fail_pop(c, LOC(p), pc, POP_JUMP_IF_FALSE));
     }
-    if (INT_MAX < size - 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5095]) {
+      if ((2147483647 < size - 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 5095\n");
+      else
+        fprintf(stderr, "reached bug index 5095\n");
+    }
+    if ((!FIXREVERTER[5095] && (2147483647 < size - 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         return compiler_error(c, LOC(p), "too many sub-patterns in mapping pattern");
     }
+    #ifdef FRCOV
+    }
+    #endif
     // Collect all of the keys into a tuple for MATCH_KEYS and
     // **rest. They can either be dotted names or literals:
 
     // Maintaining a set of Constant_kind kind keys allows us to raise a
     // SyntaxError in the case of duplicates.
     PyObject *seen = PySet_New(NULL);
-    if (seen == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5096]) {
+      if ((seen == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5096\n");
+      else
+        fprintf(stderr, "reached bug index 5096\n");
+    }
+    if ((!FIXREVERTER[5096] && (seen == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // NOTE: goto error on failure in the loop below to avoid leaking `seen`
     for (Py_ssize_t i = 0; i < size; i++) {
@@ -7128,9 +8257,24 @@ compiler_pattern_or(struct compiler *c, pattern_ty p, pattern_context *pc)
     for (Py_ssize_t i = 0; i < size; i++) {
         pattern_ty alt = asdl_seq_GET(p->v.MatchOr.patterns, i);
         PyObject *pc_stores = PyList_New(0);
-        if (pc_stores == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5098]) {
+          if ((pc_stores == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5098\n");
+          else
+            fprintf(stderr, "reached bug index 5098\n");
+        }
+        if ((!FIXREVERTER[5098] && (pc_stores == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto error;
         }
+        #ifdef FRCOV
+        }
+        #endif
         Py_SETREF(pc->stores, pc_stores);
         // An irrefutable sub-pattern must be last, if it is allowed at all:
         pc->allow_irrefutable = (i == size - 1) && old_pc.allow_irrefutable;
@@ -7159,10 +8303,25 @@ compiler_pattern_or(struct compiler *c, pattern_ty p, pattern_context *pc)
             while (icontrol--) {
                 PyObject *name = PyList_GET_ITEM(control, icontrol);
                 Py_ssize_t istores = PySequence_Index(pc->stores, name);
-                if (istores < 0) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5099]) {
+                  if ((istores < 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5099\n");
+                  else
+                    fprintf(stderr, "reached bug index 5099\n");
+                }
+                if ((!FIXREVERTER[5099] && (istores < 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     PyErr_Clear();
                     goto diff;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 if (icontrol != istores) {
                     // Reorder the names on the stack to match the order of the
                     // names in control. There's probably a better way of doing
@@ -7389,9 +8548,24 @@ compiler_match_inner(struct compiler *c, stmt_ty s, pattern_context *pc)
             ADDOP_I(c, LOC(m->pattern), COPY, 1);
         }
         pc->stores = PyList_New(0);
-        if (pc->stores == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5102]) {
+          if ((pc -> stores == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5102\n");
+          else
+            fprintf(stderr, "reached bug index 5102\n");
+        }
+        if ((!FIXREVERTER[5102] && (pc -> stores == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         // Irrefutable cases must be either guarded, last, or both:
         pc->allow_irrefutable = m->guard != NULL || i == cases - 1;
         pc->fail_pop = NULL;
@@ -7470,8 +8644,23 @@ consts_dict_keys_inorder(PyObject *dict)
     Py_ssize_t i, pos = 0, size = PyDict_GET_SIZE(dict);
 
     consts = PyList_New(size);   /* PyCode_Optimize() requires a list */
-    if (consts == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5103]) {
+      if ((consts == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5103\n");
+      else
+        fprintf(stderr, "reached bug index 5103\n");
+    }
+    if ((!FIXREVERTER[5103] && (consts == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     while (PyDict_Next(dict, &pos, &k, &v)) {
         i = PyLong_AS_LONG(v);
         /* The keys of the dictionary can be tuples wrapping a constant.
@@ -7527,9 +8716,24 @@ _PyCompile_ConstCacheMergeOne(PyObject *const_cache, PyObject **obj)
 {
     assert(PyDict_CheckExact(const_cache));
     PyObject *key = _PyCode_ConstantKey(*obj);
-    if (key == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5104]) {
+      if ((key == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5104\n");
+      else
+        fprintf(stderr, "reached bug index 5104\n");
+    }
+    if ((!FIXREVERTER[5104] && (key == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *t;
     int res = PyDict_SetDefaultRef(const_cache, key, key, &t);
@@ -7577,13 +8781,43 @@ optimize_and_assemble_code_unit(struct compiler_unit *u, PyObject *const_cache,
 
     PyCodeObject *co = NULL;
     PyObject *consts = consts_dict_keys_inorder(u->u_metadata.u_consts);
-    if (consts == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5107]) {
+      if ((consts == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5107\n");
+      else
+        fprintf(stderr, "reached bug index 5107\n");
+    }
+    if ((!FIXREVERTER[5107] && (consts == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     g = _PyCfg_FromInstructionSequence(u->u_instr_sequence);
-    if (g == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5108]) {
+      if ((g == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5108\n");
+      else
+        fprintf(stderr, "reached bug index 5108\n");
+    }
+    if ((!FIXREVERTER[5108] && (g == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int nlocals = (int)PyDict_GET_SIZE(u->u_metadata.u_varnames);
     int nparams = (int)PyList_GET_SIZE(u->u_ste->ste_varnames);
     assert(u->u_metadata.u_firstlineno);
@@ -7622,9 +8856,24 @@ optimize_and_assemble(struct compiler *c, int addNone)
     PyObject *filename = c->c_filename;
 
     int code_flags = compute_code_flags(c);
-    if (code_flags < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5109]) {
+      if ((code_flags < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5109\n");
+      else
+        fprintf(stderr, "reached bug index 5109\n");
+    }
+    if ((!FIXREVERTER[5109] && (code_flags < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (add_return_at_end(c, addNone) < 0) {
         return NULL;
@@ -7641,16 +8890,46 @@ PyObject *
 _PyCompile_CleanDoc(PyObject *doc)
 {
     doc = PyObject_CallMethod(doc, "expandtabs", NULL);
-    if (doc == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5110]) {
+      if ((doc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5110\n");
+      else
+        fprintf(stderr, "reached bug index 5110\n");
+    }
+    if ((!FIXREVERTER[5110] && (doc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Py_ssize_t doc_size;
     const char *doc_utf8 = PyUnicode_AsUTF8AndSize(doc, &doc_size);
-    if (doc_utf8 == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5111]) {
+      if ((doc_utf8 == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5111\n");
+      else
+        fprintf(stderr, "reached bug index 5111\n");
+    }
+    if ((!FIXREVERTER[5111] && (doc_utf8 == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(doc);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     const char *p = doc_utf8;
     const char *pend = p + doc_size;
 
@@ -7686,11 +8965,26 @@ _PyCompile_CleanDoc(PyObject *doc)
     }
 
     char *buff = PyMem_Malloc(doc_size);
-    if (buff == NULL){
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5112]) {
+      if ((buff == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5112\n");
+      else
+        fprintf(stderr, "reached bug index 5112\n");
+    }
+    if ((!FIXREVERTER[5112] && (buff == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ){
         Py_DECREF(doc);
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     char *w = buff;
 
diff --git a/Python/dtoa.c b/Python/dtoa.c
index d0c89b2b468..b4a9942a22a 100644
--- a/Python/dtoa.c
+++ b/Python/dtoa.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /****************************************************************
  *
  * The author of this software is David M. Gay.
@@ -358,8 +362,23 @@ Balloc(int k)
         }
         else {
             rv = (Bigint*)MALLOC(len*sizeof(double));
-            if (rv == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5743]) {
+              if ((rv == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5743\n");
+              else
+                fprintf(stderr, "reached bug index 5743\n");
+            }
+            if ((!FIXREVERTER[5743] && (rv == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return NULL;
+                #ifdef FRCOV
+                }
+                #endif
         }
         rv->k = k;
         rv->maxwds = x;
@@ -458,10 +477,25 @@ multadd(Bigint *b, int m, int a)       /* multiply by m and add a */
     if (carry) {
         if (wds >= b->maxwds) {
             b1 = Balloc(b->k+1);
-            if (b1 == NULL){
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5744]) {
+              if ((b1 == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5744\n");
+              else
+                fprintf(stderr, "reached bug index 5744\n");
+            }
+            if ((!FIXREVERTER[5744] && (b1 == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ){
                 Bfree(b);
                 return NULL;
             }
+            #ifdef FRCOV
+            }
+            #endif
             Bcopy(b1, b);
             Bfree(b);
             b = b1;
@@ -488,8 +522,23 @@ s2b(const char *s, int nd0, int nd, ULong y9)
     x = (nd + 8) / 9;
     for(k = 0, y = 1; x > y; y <<= 1, k++) ;
     b = Balloc(k);
-    if (b == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5745]) {
+      if ((b == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5745\n");
+      else
+        fprintf(stderr, "reached bug index 5745\n");
+    }
+    if ((!FIXREVERTER[5745] && (b == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     b->x[0] = y9;
     b->wds = 1;
 
@@ -499,14 +548,44 @@ s2b(const char *s, int nd0, int nd, ULong y9)
     s += 9;
     for (i = 9; i < nd0; i++) {
         b = multadd(b, 10, *s++ - '0');
-        if (b == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5747]) {
+          if ((b == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5747\n");
+          else
+            fprintf(stderr, "reached bug index 5747\n");
+        }
+        if ((!FIXREVERTER[5747] && (b == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
     }
     s++;
     for(; i < nd; i++) {
         b = multadd(b, 10, *s++ - '0');
-        if (b == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5748]) {
+          if ((b == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5748\n");
+          else
+            fprintf(stderr, "reached bug index 5748\n");
+        }
+        if ((!FIXREVERTER[5748] && (b == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
     }
     return b;
 }
@@ -596,8 +675,23 @@ i2b(int i)
     Bigint *b;
 
     b = Balloc(1);
-    if (b == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5749]) {
+      if ((b == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5749\n");
+      else
+        fprintf(stderr, "reached bug index 5749\n");
+    }
+    if ((!FIXREVERTER[5749] && (b == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     b->x[0] = i;
     b->wds = 1;
     return b;
@@ -617,8 +711,23 @@ mult(Bigint *a, Bigint *b)
 
     if ((!a->x[0] && a->wds == 1) || (!b->x[0] && b->wds == 1)) {
         c = Balloc(0);
-        if (c == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5750]) {
+          if ((c == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5750\n");
+          else
+            fprintf(stderr, "reached bug index 5750\n");
+        }
+        if ((!FIXREVERTER[5750] && (c == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
         c->wds = 1;
         c->x[0] = 0;
         return c;
@@ -636,8 +745,23 @@ mult(Bigint *a, Bigint *b)
     if (wc > a->maxwds)
         k++;
     c = Balloc(k);
-    if (c == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5751]) {
+      if ((c == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5751\n");
+      else
+        fprintf(stderr, "reached bug index 5751\n");
+    }
+    if ((!FIXREVERTER[5751] && (c == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     for(x = c->x, xa = x + wc; x < xa; x++)
         *x = 0;
     xa = a->x;
@@ -686,8 +810,23 @@ pow5mult(Bigint *b, int k)
 
     if ((i = k & 3)) {
         b = multadd(b, p05[i-1], 0);
-        if (b == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5752]) {
+          if ((b == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5752\n");
+          else
+            fprintf(stderr, "reached bug index 5752\n");
+        }
+        if ((!FIXREVERTER[5752] && (b == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
     if (!(k >>= 2))
@@ -702,8 +841,23 @@ pow5mult(Bigint *b, int k)
             b1 = mult(b, p5);
             Bfree(b);
             b = b1;
-            if (b == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5753]) {
+              if ((b == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5753\n");
+              else
+                fprintf(stderr, "reached bug index 5753\n");
+            }
+            if ((!FIXREVERTER[5753] && (b == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return NULL;
+                #ifdef FRCOV
+                }
+                #endif
         }
         if (!(k >>= 1))
             break;
@@ -783,10 +937,25 @@ lshift(Bigint *b, int k)
     for(i = b->maxwds; n1 > i; i <<= 1)
         k1++;
     b1 = Balloc(k1);
-    if (b1 == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5754]) {
+      if ((b1 == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5754\n");
+      else
+        fprintf(stderr, "reached bug index 5754\n");
+    }
+    if ((!FIXREVERTER[5754] && (b1 == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Bfree(b);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     x1 = b1->x;
     for(i = 0; i < n; i++)
         *x1++ = 0;
@@ -837,8 +1006,23 @@ cmp(Bigint *a, Bigint *b)
     for(;;) {
         if (*--xa != *--xb)
             return *xa < *xb ? -1 : 1;
-        if (xa <= xa0)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5755]) {
+          if ((xa <= xa0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5755\n");
+          else
+            fprintf(stderr, "reached bug index 5755\n");
+        }
+        if ((!FIXREVERTER[5755] && (xa <= xa0 ))
+        #else
+        if (0
+        #endif
+        )
             break;
+            #ifdef FRCOV
+            }
+            #endif
     }
     return 0;
 }
@@ -858,8 +1042,23 @@ diff(Bigint *a, Bigint *b)
     i = cmp(a,b);
     if (!i) {
         c = Balloc(0);
-        if (c == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5756]) {
+          if ((c == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5756\n");
+          else
+            fprintf(stderr, "reached bug index 5756\n");
+        }
+        if ((!FIXREVERTER[5756] && (c == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return NULL;
+            #ifdef FRCOV
+            }
+            #endif
         c->wds = 1;
         c->x[0] = 0;
         return c;
@@ -873,8 +1072,23 @@ diff(Bigint *a, Bigint *b)
     else
         i = 0;
     c = Balloc(a->k);
-    if (c == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5757]) {
+      if ((c == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5757\n");
+      else
+        fprintf(stderr, "reached bug index 5757\n");
+    }
+    if ((!FIXREVERTER[5757] && (c == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     c->sign = i;
     wa = a->wds;
     xa = a->x;
@@ -980,8 +1194,23 @@ sd2b(U *d, int scale, int *e)
     Bigint *b;
 
     b = Balloc(1);
-    if (b == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5758]) {
+      if ((b == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5758\n");
+      else
+        fprintf(stderr, "reached bug index 5758\n");
+    }
+    if ((!FIXREVERTER[5758] && (b == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* First construct b and e assuming that scale == 0. */
     b->wds = 2;
@@ -1146,8 +1375,23 @@ quorem(Bigint *b, Bigint *S)
     /*debug*/ if (b->wds > n)
         /*debug*/       Bug("oversize b in quorem");
 #endif
-    if (b->wds < n)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5760]) {
+      if ((b -> wds < n ) && !(0))
+        fprintf(stderr, "triggered bug index 5760\n");
+      else
+        fprintf(stderr, "reached bug index 5760\n");
+    }
+    if ((!FIXREVERTER[5760] && (b -> wds < n ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
     sx = S->x;
     sxe = sx + --n;
     bx = b->x;
@@ -1279,8 +1523,23 @@ bigcomp(U *rv, const char *s0, BCinfo *bc)
     nd0 = bc->nd0;
     p5 = nd + bc->e0;
     b = sd2b(rv, bc->scale, &p2);
-    if (b == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5761]) {
+      if ((b == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5761\n");
+      else
+        fprintf(stderr, "reached bug index 5761\n");
+    }
+    if ((!FIXREVERTER[5761] && (b == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* record whether the lsb of rv/2^(bc->scale) is odd:  in the exact halfway
        case, this is used for round to even. */
@@ -1289,33 +1548,93 @@ bigcomp(U *rv, const char *s0, BCinfo *bc)
     /* left shift b by 1 bit and or a 1 into the least significant bit;
        this gives us b * 2**p2 = rv/2^(bc->scale) + 0.5 ulp. */
     b = lshift(b, 1);
-    if (b == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5762]) {
+      if ((b == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5762\n");
+      else
+        fprintf(stderr, "reached bug index 5762\n");
+    }
+    if ((!FIXREVERTER[5762] && (b == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     b->x[0] |= 1;
     p2--;
 
     p2 -= p5;
     d = i2b(1);
-    if (d == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5763]) {
+      if ((d == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5763\n");
+      else
+        fprintf(stderr, "reached bug index 5763\n");
+    }
+    if ((!FIXREVERTER[5763] && (d == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Bfree(b);
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     /* Arrange for convenient computation of quotients:
      * shift left if necessary so divisor has 4 leading 0 bits.
      */
     if (p5 > 0) {
         d = pow5mult(d, p5);
-        if (d == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5764]) {
+          if ((d == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5764\n");
+          else
+            fprintf(stderr, "reached bug index 5764\n");
+        }
+        if ((!FIXREVERTER[5764] && (d == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Bfree(b);
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     else if (p5 < 0) {
         b = pow5mult(b, -p5);
-        if (b == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5765]) {
+          if ((b == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5765\n");
+          else
+            fprintf(stderr, "reached bug index 5765\n");
+        }
+        if ((!FIXREVERTER[5765] && (b == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Bfree(d);
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     if (p2 > 0) {
         b2 = p2;
@@ -1328,17 +1647,47 @@ bigcomp(U *rv, const char *s0, BCinfo *bc)
     i = dshift(d, d2);
     if ((b2 += i) > 0) {
         b = lshift(b, b2);
-        if (b == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5766]) {
+          if ((b == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5766\n");
+          else
+            fprintf(stderr, "reached bug index 5766\n");
+        }
+        if ((!FIXREVERTER[5766] && (b == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Bfree(d);
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     if ((d2 += i) > 0) {
         d = lshift(d, d2);
-        if (d == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5767]) {
+          if ((d == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5767\n");
+          else
+            fprintf(stderr, "reached bug index 5767\n");
+        }
+        if ((!FIXREVERTER[5767] && (d == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Bfree(b);
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     /* Compare s0 with b/d: set dd to -1, 0, or 1 according as s0 < b/d, s0 ==
@@ -1351,10 +1700,25 @@ bigcomp(U *rv, const char *s0, BCinfo *bc)
         i = 0;
         for(;;) {
             b = multadd(b, 10, 0);
-            if (b == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5768]) {
+              if ((b == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5768\n");
+              else
+                fprintf(stderr, "reached bug index 5768\n");
+            }
+            if ((!FIXREVERTER[5768] && (b == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Bfree(d);
                 return -1;
             }
+            #ifdef FRCOV
+            }
+            #endif
             dd = s0[i < nd0 ? i : i+1] - '0' - quorem(b, d);
             i++;
 
@@ -1455,11 +1819,26 @@ _Py_dg_strtod(const char *s00, char **se)
 
     /* Range check ndigits and fraclen to make sure that they, and values
        computed with them, can safely fit in an int. */
-    if (ndigits > MAX_DIGITS || fraclen > MAX_DIGITS) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5769]) {
+      if ((ndigits > 1000000000 || fraclen > 1000000000 ) && !(0))
+        fprintf(stderr, "triggered bug index 5769\n");
+      else
+        fprintf(stderr, "reached bug index 5769\n");
+    }
+    if ((!FIXREVERTER[5769] && (ndigits > 1000000000 || fraclen > 1000000000 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (se)
             *se = (char *)s00;
         goto parse_error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     nd = (int)ndigits;
     nd0 = (int)ndigits - (int)fraclen;
 
@@ -1510,8 +1889,23 @@ _Py_dg_strtod(const char *s00, char **se)
 
     /* Adjust exponent to take into account position of the point. */
     e -= nd - nd0;
-    if (nd0 <= 0)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5770]) {
+      if ((nd0 <= 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5770\n");
+      else
+        fprintf(stderr, "reached bug index 5770\n");
+    }
+    if ((!FIXREVERTER[5770] && (nd0 <= 0 ))
+    #else
+    if (0
+    #endif
+    )
         nd0 = nd;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Finished parsing.  Set se to indicate how far we parsed */
     if (se)
@@ -1530,8 +1924,23 @@ _Py_dg_strtod(const char *s00, char **se)
     }
     e += nd - i;
     nd = i;
-    if (nd0 > nd)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5771]) {
+      if ((nd0 > nd ) && !(0))
+        fprintf(stderr, "triggered bug index 5771\n");
+      else
+        fprintf(stderr, "reached bug index 5771\n");
+    }
+    if ((!FIXREVERTER[5771] && (nd0 > nd ))
+    #else
+    if (0
+    #endif
+    )
         nd0 = nd;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Summary of parsing results.  After parsing, and dealing with zero
      * inputs, we have values s0, nd0, nd, e, sign, where:
@@ -1591,10 +2000,25 @@ _Py_dg_strtod(const char *s00, char **se)
         if (!e)
             goto ret;
         if (e > 0) {
-            if (e <= Ten_pmax) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5772]) {
+              if ((e <= 22 ) && !(0))
+                fprintf(stderr, "triggered bug index 5772\n");
+              else
+                fprintf(stderr, "reached bug index 5772\n");
+            }
+            if ((!FIXREVERTER[5772] && (e <= 22 ))
+            #else
+            if (0
+            #endif
+            ) {
                 dval(&rv) *= tens[e];
                 goto ret;
             }
+            #ifdef FRCOV
+            }
+            #endif
             i = DBL_DIG - nd;
             if (e <= Ten_pmax + i) {
                 /* A fancier test would sometimes let us do
@@ -1621,8 +2045,23 @@ _Py_dg_strtod(const char *s00, char **se)
         if ((i = e1 & 15))
             dval(&rv) *= tens[i];
         if (e1 &= ~15) {
-            if (e1 > DBL_MAX_10_EXP)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5773]) {
+              if ((e1 > 308 ) && !(0))
+                fprintf(stderr, "triggered bug index 5773\n");
+              else
+                fprintf(stderr, "reached bug index 5773\n");
+            }
+            if ((!FIXREVERTER[5773] && (e1 > 308 ))
+            #else
+            if (0
+            #endif
+            )
                 goto ovfl;
+                #ifdef FRCOV
+                }
+                #endif
             e1 >>= 4;
             for(j = 0; e1 > 1; j++, e1 >>= 1)
                 if (e1 & 1)
@@ -1710,8 +2149,23 @@ _Py_dg_strtod(const char *s00, char **se)
         }
         e += nd - i;
         nd = i;
-        if (nd0 > nd)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5774]) {
+          if ((nd0 > nd ) && !(0))
+            fprintf(stderr, "triggered bug index 5774\n");
+          else
+            fprintf(stderr, "reached bug index 5774\n");
+        }
+        if ((!FIXREVERTER[5774] && (nd0 > nd ))
+        #else
+        if (0
+        #endif
+        )
             nd0 = nd;
+            #ifdef FRCOV
+            }
+            #endif
         if (nd < 9) { /* must recompute y */
             y = 0;
             for(i = 0; i < nd0; ++i)
@@ -1721,8 +2175,23 @@ _Py_dg_strtod(const char *s00, char **se)
         }
     }
     bd0 = s2b(s0, nd0, nd, y);
-    if (bd0 == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5775]) {
+      if ((bd0 == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5775\n");
+      else
+        fprintf(stderr, "reached bug index 5775\n");
+    }
+    if ((!FIXREVERTER[5775] && (bd0 == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto failed_malloc;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Notation for the comments below.  Write:
 
@@ -1753,23 +2222,68 @@ _Py_dg_strtod(const char *s00, char **se)
         */
 
         bd = Balloc(bd0->k);
-        if (bd == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5776]) {
+          if ((bd == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5776\n");
+          else
+            fprintf(stderr, "reached bug index 5776\n");
+        }
+        if ((!FIXREVERTER[5776] && (bd == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto failed_malloc;
         }
+        #ifdef FRCOV
+        }
+        #endif
         Bcopy(bd, bd0);
         bb = sd2b(&rv, bc.scale, &bbe);   /* srv = bb * 2^bbe */
-        if (bb == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5777]) {
+          if ((bb == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5777\n");
+          else
+            fprintf(stderr, "reached bug index 5777\n");
+        }
+        if ((!FIXREVERTER[5777] && (bb == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto failed_malloc;
         }
+        #ifdef FRCOV
+        }
+        #endif
         /* Record whether lsb of bb is odd, in case we need this
            for the round-to-even step later. */
         odd = bb->x[0] & 1;
 
         /* tdv = bd * 10**e;  srv = bb * 2**bbe */
         bs = i2b(1);
-        if (bs == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5778]) {
+          if ((bs == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5778\n");
+          else
+            fprintf(stderr, "reached bug index 5778\n");
+        }
+        if ((!FIXREVERTER[5778] && (bs == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto failed_malloc;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (e >= 0) {
             bb2 = bb5 = 0;
@@ -1806,8 +2320,23 @@ _Py_dg_strtod(const char *s00, char **se)
 
         /* Remove factor of 2**i, where i = min(bb2, bd2, bs2). */
         i = bb2 < bd2 ? bb2 : bd2;
-        if (i > bs2)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5779]) {
+          if ((i > bs2 ) && !(0))
+            fprintf(stderr, "triggered bug index 5779\n");
+          else
+            fprintf(stderr, "reached bug index 5779\n");
+        }
+        if ((!FIXREVERTER[5779] && (i > bs2 ))
+        #else
+        if (0
+        #endif
+        )
             i = bs2;
+            #ifdef FRCOV
+            }
+            #endif
         if (i > 0) {
             bb2 -= i;
             bd2 -= i;
@@ -1817,39 +2346,129 @@ _Py_dg_strtod(const char *s00, char **se)
         /* Scale bb, bd, bs by the appropriate powers of 2 and 5. */
         if (bb5 > 0) {
             bs = pow5mult(bs, bb5);
-            if (bs == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5780]) {
+              if ((bs == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5780\n");
+              else
+                fprintf(stderr, "reached bug index 5780\n");
+            }
+            if ((!FIXREVERTER[5780] && (bs == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto failed_malloc;
             }
+            #ifdef FRCOV
+            }
+            #endif
             Bigint *bb1 = mult(bs, bb);
             Bfree(bb);
             bb = bb1;
-            if (bb == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5781]) {
+              if ((bb == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5781\n");
+              else
+                fprintf(stderr, "reached bug index 5781\n");
+            }
+            if ((!FIXREVERTER[5781] && (bb == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto failed_malloc;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         if (bb2 > 0) {
             bb = lshift(bb, bb2);
-            if (bb == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5782]) {
+              if ((bb == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5782\n");
+              else
+                fprintf(stderr, "reached bug index 5782\n");
+            }
+            if ((!FIXREVERTER[5782] && (bb == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto failed_malloc;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         if (bd5 > 0) {
             bd = pow5mult(bd, bd5);
-            if (bd == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5783]) {
+              if ((bd == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5783\n");
+              else
+                fprintf(stderr, "reached bug index 5783\n");
+            }
+            if ((!FIXREVERTER[5783] && (bd == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto failed_malloc;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         if (bd2 > 0) {
             bd = lshift(bd, bd2);
-            if (bd == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5784]) {
+              if ((bd == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5784\n");
+              else
+                fprintf(stderr, "reached bug index 5784\n");
+            }
+            if ((!FIXREVERTER[5784] && (bd == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto failed_malloc;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         if (bs2 > 0) {
             bs = lshift(bs, bs2);
-            if (bs == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5785]) {
+              if ((bs == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5785\n");
+              else
+                fprintf(stderr, "reached bug index 5785\n");
+            }
+            if ((!FIXREVERTER[5785] && (bs == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto failed_malloc;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
 
         /* Now bd, bb and bs are scaled versions of tdv, srv and 0.5 ulp(srv),
@@ -1857,13 +2476,43 @@ _Py_dg_strtod(const char *s00, char **se)
            with 0.5 ulp(srv). */
 
         delta = diff(bb, bd);
-        if (delta == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5786]) {
+          if ((delta == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5786\n");
+          else
+            fprintf(stderr, "reached bug index 5786\n");
+        }
+        if ((!FIXREVERTER[5786] && (delta == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto failed_malloc;
         }
+        #ifdef FRCOV
+        }
+        #endif
         dsign = delta->sign;
         delta->sign = 0;
         i = cmp(delta, bs);
-        if (bc.nd > nd && i <= 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5788]) {
+          fprintf(stderr, "reached bug index 5788\n");
+        }
+        if ((FIXREVERTER[5788] && (bc . nd > nd )) || (!FIXREVERTER[5788] && (bc . nd > nd && i <= 0 ))
+        #else
+        if (bc . nd > nd 
+        #endif
+        ) {
+          
+        #ifdef FRCOV
+          if (!(i <= 0 ))
+            fprintf(stderr, "triggered bug index 5788\n");
+          #endif
+        
             if (dsign)
                 break;  /* Must use bigcomp(). */
 
@@ -1884,10 +2533,25 @@ _Py_dg_strtod(const char *s00, char **se)
                 j = (int)(word0(&rv) & Exp_mask) >> Exp_shift;
                 /* rv / 2^bc.scale = 2^(j - 1023 - bc.scale); use bigcomp if
                    rv / 2^bc.scale >= 2^-1021. */
-                if (j - bc.scale >= 2) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[5787]) {
+                  if ((j - bc . scale >= 2 ) && !(0))
+                    fprintf(stderr, "triggered bug index 5787\n");
+                  else
+                    fprintf(stderr, "reached bug index 5787\n");
+                }
+                if ((!FIXREVERTER[5787] && (j - bc . scale >= 2 ))
+                #else
+                if (0
+                #endif
+                ) {
                     dval(&rv) -= 0.5 * sulp(&rv, &bc);
                     break; /* Use bigcomp. */
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
 
             {
@@ -1895,6 +2559,9 @@ _Py_dg_strtod(const char *s00, char **se)
                 i = -1; /* Discarded digits make delta smaller. */
             }
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (i < 0) {
             /* Error is less than half an ulp -- check for
@@ -1910,9 +2577,24 @@ _Py_dg_strtod(const char *s00, char **se)
                 break;
             }
             delta = lshift(delta,Log2P);
-            if (delta == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5789]) {
+              if ((delta == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5789\n");
+              else
+                fprintf(stderr, "reached bug index 5789\n");
+            }
+            if ((!FIXREVERTER[5789] && (delta == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto failed_malloc;
             }
+            #ifdef FRCOV
+            }
+            #endif
             if (cmp(delta, bs) > 0)
                 goto drop_down;
             break;
@@ -1946,8 +2628,23 @@ _Py_dg_strtod(const char *s00, char **se)
                             /* accept rv */
                             break;
                         /* rv = smallest denormal */
-                        if (bc.nd > nd)
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[5790]) {
+                          if ((bc . nd > nd ) && !(0))
+                            fprintf(stderr, "triggered bug index 5790\n");
+                          else
+                            fprintf(stderr, "reached bug index 5790\n");
+                        }
+                        if ((!FIXREVERTER[5790] && (bc . nd > nd ))
+                        #else
+                        if (0
+                        #endif
+                        )
                             break;
+                            #ifdef FRCOV
+                            }
+                            #endif
                         goto undfl;
                     }
                 }
@@ -1963,8 +2660,23 @@ _Py_dg_strtod(const char *s00, char **se)
             else {
                 dval(&rv) -= sulp(&rv, &bc);
                 if (!dval(&rv)) {
-                    if (bc.nd >nd)
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[5791]) {
+                      if ((bc . nd > nd ) && !(0))
+                        fprintf(stderr, "triggered bug index 5791\n");
+                      else
+                        fprintf(stderr, "reached bug index 5791\n");
+                    }
+                    if ((!FIXREVERTER[5791] && (bc . nd > nd ))
+                    #else
+                    if (0
+                    #endif
+                    )
                         break;
+                        #ifdef FRCOV
+                        }
+                        #endif
                     goto undfl;
                 }
             }
@@ -1976,8 +2688,23 @@ _Py_dg_strtod(const char *s00, char **se)
                 aadj = aadj1 = 1.;
             else if (word1(&rv) || word0(&rv) & Bndry_mask) {
                 if (word1(&rv) == Tiny1 && !word0(&rv)) {
-                    if (bc.nd >nd)
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[5792]) {
+                      if ((bc . nd > nd ) && !(0))
+                        fprintf(stderr, "triggered bug index 5792\n");
+                      else
+                        fprintf(stderr, "reached bug index 5792\n");
+                    }
+                    if ((!FIXREVERTER[5792] && (bc . nd > nd ))
+                    #else
+                    if (0
+                    #endif
+                    )
                         break;
+                        #ifdef FRCOV
+                        }
+                        #endif
                     goto undfl;
                 }
                 aadj = 1.;
diff --git a/Python/errors.c b/Python/errors.c
index ad6b7dbef07..4d0ef490077 100644
--- a/Python/errors.c
+++ b/Python/errors.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Error handling */
 
@@ -73,11 +77,26 @@ _PyErr_Restore(PyThreadState *tstate, PyObject *type, PyObject *value,
     else {
         PyObject *exc = _PyErr_CreateException(type, value);
         Py_XDECREF(value);
-        if (exc == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[5340]) {
+          if ((exc == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 5340\n");
+          else
+            fprintf(stderr, "reached bug index 5340\n");
+        }
+        if ((!FIXREVERTER[5340] && (exc == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(type);
             Py_XDECREF(traceback);
             return;
         }
+        #ifdef FRCOV
+        }
+        #endif
         value = exc;
     }
     assert(PyExceptionInstance_Check(value));
@@ -315,10 +334,25 @@ PyErr_Occurred(void)
 int
 PyErr_GivenExceptionMatches(PyObject *err, PyObject *exc)
 {
-    if (err == NULL || exc == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5342]) {
+      if ((err == (void *) 0 || exc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5342\n");
+      else
+        fprintf(stderr, "reached bug index 5342\n");
+    }
+    if ((!FIXREVERTER[5342] && (err == (void *) 0 || exc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* maybe caused by "import exceptions" that failed early on */
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (PyTuple_Check(exc)) {
         Py_ssize_t i, n;
         n = PyTuple_Size(exc);
@@ -379,11 +413,26 @@ _PyErr_NormalizeException(PyThreadState *tstate, PyObject **exc,
 
   restart:
     type = *exc;
-    if (type == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5343]) {
+      if ((type == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5343\n");
+      else
+        fprintf(stderr, "reached bug index 5343\n");
+    }
+    if ((!FIXREVERTER[5343] && (type == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* There was no exception, so nothing to do. */
         tstate->recursion_headroom--;
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     value = *val;
     /* If PyErr_SetNone() was used, the value will have been actually
@@ -415,9 +464,24 @@ _PyErr_NormalizeException(PyThreadState *tstate, PyObject **exc,
         */
         if (!is_subclass) {
             PyObject *fixed_value = _PyErr_CreateException(type, value);
-            if (fixed_value == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5345]) {
+              if ((fixed_value == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5345\n");
+              else
+                fprintf(stderr, "reached bug index 5345\n");
+            }
+            if ((!FIXREVERTER[5345] && (fixed_value == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto error;
             }
+            #ifdef FRCOV
+            }
+            #endif
             Py_SETREF(value, fixed_value);
         }
         /* If the class of the instance doesn't exactly match the
@@ -686,9 +750,24 @@ _PyErr_ChainExceptions(PyObject *typ, PyObject *val, PyObject *tb)
 void
 _PyErr_ChainExceptions1(PyObject *exc)
 {
-    if (exc == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5347]) {
+      if ((exc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5347\n");
+      else
+        fprintf(stderr, "reached bug index 5347\n");
+    }
+    if ((!FIXREVERTER[5347] && (exc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyThreadState *tstate = _PyThreadState_GET();
     if (_PyErr_Occurred(tstate)) {
         PyObject *exc2 = _PyErr_GetRaisedException(tstate);
@@ -852,13 +931,28 @@ PyErr_SetFromErrnoWithFilenameObjects(PyObject *exc, PyObject *filenameObject, P
     }
 #endif /* Unix/Windows */
 
-    if (message == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5348]) {
+      if ((message == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5348\n");
+      else
+        fprintf(stderr, "reached bug index 5348\n");
+    }
+    if ((!FIXREVERTER[5348] && (message == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
     {
 #ifdef MS_WINDOWS
         LocalFree(s_buf);
 #endif
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (filenameObject != NULL) {
         if (filenameObject2 != NULL)
@@ -1364,9 +1458,24 @@ make_unraisable_hook_args(PyThreadState *tstate, PyObject *exc_type,
                           PyObject *err_msg, PyObject *obj)
 {
     PyObject *args = PyStructSequence_New(&UnraisableHookArgsType);
-    if (args == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5363]) {
+      if ((args == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5363\n");
+      else
+        fprintf(stderr, "reached bug index 5363\n");
+    }
+    if ((!FIXREVERTER[5363] && (args == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Py_ssize_t pos = 0;
 #define ADD_ITEM(exc_type) \
@@ -1589,10 +1698,25 @@ format_unraisable_v(const char *format, va_list va, PyObject *obj)
 
     assert(exc_type != NULL);
 
-    if (exc_type == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5364]) {
+      if ((exc_type == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5364\n");
+      else
+        fprintf(stderr, "reached bug index 5364\n");
+    }
+    if ((!FIXREVERTER[5364] && (exc_type == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* sys.unraisablehook requires that at least exc_type is set */
         goto default_hook;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (exc_tb == NULL) {
         PyFrameObject *frame = PyThreadState_GetFrame(tstate);
@@ -1622,17 +1746,47 @@ format_unraisable_v(const char *format, va_list va, PyObject *obj)
 
     PyObject *hook_args = make_unraisable_hook_args(
         tstate, exc_type, exc_value, exc_tb, err_msg, obj);
-    if (hook_args == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5365]) {
+      if ((hook_args == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5365\n");
+      else
+        fprintf(stderr, "reached bug index 5365\n");
+    }
+    if ((!FIXREVERTER[5365] && (hook_args == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         err_msg_str = ("Exception ignored on building "
                        "sys.unraisablehook arguments");
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *hook = _PySys_GetAttr(tstate, &_Py_ID(unraisablehook));
-    if (hook == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5366]) {
+      if ((hook == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5366\n");
+      else
+        fprintf(stderr, "reached bug index 5366\n");
+    }
+    if ((!FIXREVERTER[5366] && (hook == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(hook_args);
         goto default_hook;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (_PySys_Audit(tstate, "sys.unraisablehook", "OO", hook, hook_args) < 0) {
         Py_DECREF(hook_args);
@@ -1861,9 +2015,24 @@ err_programtext(PyThreadState *tstate, FILE *fp, int lineno, const char* encodin
 {
     int i;
     char linebuf[1000];
-    if (fp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5367]) {
+      if ((fp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5367\n");
+      else
+        fprintf(stderr, "reached bug index 5367\n");
+    }
+    if ((!FIXREVERTER[5367] && (fp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i = 0; i < lineno; i++) {
         char *pLastChar = &linebuf[sizeof(linebuf) - 2];
@@ -1917,16 +2086,46 @@ PyErr_ProgramText(const char *filename, int lineno)
 PyObject *
 _PyErr_ProgramDecodedTextObject(PyObject *filename, int lineno, const char* encoding)
 {
-    if (filename == NULL || lineno <= 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5370]) {
+      if ((filename == (void *) 0 ) && !(lineno <= 0 ))
+        fprintf(stderr, "triggered bug index 5370\n");
+      else
+        fprintf(stderr, "reached bug index 5370\n");
+    }
+    if ((FIXREVERTER[5370] && (lineno <= 0 )) || (!FIXREVERTER[5370] && (filename == (void *) 0 || lineno <= 0 ))
+    #else
+    if (lineno <= 0 
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyThreadState *tstate = _PyThreadState_GET();
     FILE *fp = _Py_fopen_obj(filename, "r" PY_STDIOTEXTMODE);
-    if (fp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[5371]) {
+      if ((fp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 5371\n");
+      else
+        fprintf(stderr, "reached bug index 5371\n");
+    }
+    if ((!FIXREVERTER[5371] && (fp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyErr_Clear(tstate);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return err_programtext(tstate, fp, lineno, encoding);
 }
 
diff --git a/Python/fileutils.c b/Python/fileutils.c
index c9ae1b3f54e..2e2b42b2fe4 100644
--- a/Python/fileutils.c
+++ b/Python/fileutils.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_fileutils.h"     // fileutils definitions
 #include "pycore_runtime.h"       // _PyRuntime
@@ -210,9 +214,24 @@ static int
 check_force_ascii(void)
 {
     char *loc = setlocale(LC_CTYPE, NULL);
-    if (loc == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3396]) {
+      if ((loc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3396\n");
+      else
+        fprintf(stderr, "reached bug index 3396\n");
+    }
+    if ((!FIXREVERTER[3396] && (loc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (strcmp(loc, "C") != 0 && strcmp(loc, "POSIX") != 0) {
         /* the LC_CTYPE locale is different than C and POSIX */
         return 0;
@@ -347,9 +366,24 @@ encode_ascii(const wchar_t *text, char **str,
     else {
         result = PyMem_Malloc(len + 1);
     }
-    if (result == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3397]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3397\n");
+      else
+        fprintf(stderr, "reached bug index 3397\n");
+    }
+    if ((!FIXREVERTER[3397] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     out = result;
     for (i=0; i<len; i++) {
@@ -518,10 +552,25 @@ decode_current_locale(const char* arg, wchar_t **wstr, size_t *wlen,
     memset(&mbs, 0, sizeof mbs);
     while (argsize) {
         size_t converted = _Py_mbrtowc(out, (char*)in, argsize, &mbs);
-        if (converted == 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3398]) {
+          if ((converted == 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3398\n");
+          else
+            fprintf(stderr, "reached bug index 3398\n");
+        }
+        if ((!FIXREVERTER[3398] && (converted == 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             /* Reached end of string; null char stored. */
             break;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (converted == INCOMPLETE_CHARACTER) {
             /* Incomplete character. This should never happen,
@@ -667,13 +716,28 @@ Py_DecodeLocale(const char* arg, size_t *wlen)
     int res = _Py_DecodeLocaleEx(arg, &wstr, wlen,
                                  NULL, 0,
                                  _Py_ERROR_SURROGATEESCAPE);
-    if (res != 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3399]) {
+      if ((res != 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3399\n");
+      else
+        fprintf(stderr, "reached bug index 3399\n");
+    }
+    if ((!FIXREVERTER[3399] && (res != 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         assert(res != -3);
         if (wlen != NULL) {
             *wlen = (size_t)res;
         }
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return wstr;
 }
 
@@ -747,9 +811,24 @@ encode_current_locale(const wchar_t *text, char **str,
         else {
             result = PyMem_Malloc(size);
         }
-        if (result == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3400]) {
+          if ((result == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3400\n");
+          else
+            fprintf(stderr, "reached bug index 3400\n");
+        }
+        if ((!FIXREVERTER[3400] && (result == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
         bytes = result;
     }
     *str = result;
@@ -1829,11 +1908,26 @@ _Py_fopen_obj(PyObject *path, const char *mode)
     if (async_err)
         return NULL;
 
-    if (f == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3415]) {
+      if ((f == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3415\n");
+      else
+        fprintf(stderr, "reached bug index 3415\n");
+    }
+    if ((!FIXREVERTER[3415] && (f == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         errno = saved_errno;
         PyErr_SetFromErrnoWithFilenameObject(PyExc_OSError, path);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (set_inheritable(fileno(f), 0, 1, NULL) < 0) {
         fclose(f);
@@ -2630,13 +2724,43 @@ _Py_wgetcwd(wchar_t *buf, size_t buflen)
     if (getcwd(fname, Py_ARRAY_LENGTH(fname)) == NULL)
         return NULL;
     wname = Py_DecodeLocale(fname, &len);
-    if (wname == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3427]) {
+      if ((wname == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3427\n");
+      else
+        fprintf(stderr, "reached bug index 3427\n");
+    }
+    if ((!FIXREVERTER[3427] && (wname == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     /* wname must have space to store the trailing NUL character */
-    if (buflen <= len) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3428]) {
+      if ((buflen <= len ) && !(0))
+        fprintf(stderr, "triggered bug index 3428\n");
+      else
+        fprintf(stderr, "reached bug index 3428\n");
+    }
+    if ((!FIXREVERTER[3428] && (buflen <= len ))
+    #else
+    if (0
+    #endif
+    ) {
         PyMem_RawFree(wname);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     wcsncpy(buf, wname, buflen);
     PyMem_RawFree(wname);
     return buf;
diff --git a/Python/flowgraph.c b/Python/flowgraph.c
index ec91b0e616c..998452f1ef8 100644
--- a/Python/flowgraph.c
+++ b/Python/flowgraph.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 #include <stdbool.h>
 
@@ -148,10 +152,25 @@ basicblock_next_instr(basicblock *b)
 static cfg_instr *
 basicblock_last_instr(const basicblock *b) {
     assert(b->b_iused >= 0);
-    if (b->b_iused > 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3706]) {
+      if ((b -> b_iused > 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3706\n");
+      else
+        fprintf(stderr, "reached bug index 3706\n");
+    }
+    if ((!FIXREVERTER[3706] && (b -> b_iused > 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         assert(b->b_instr != NULL);
         return &b->b_instr[b->b_iused - 1];
     }
+    #ifdef FRCOV
+    }
+    #endif
     return NULL;
 }
 
@@ -163,10 +182,25 @@ static basicblock *
 cfg_builder_new_block(cfg_builder *g)
 {
     basicblock *b = (basicblock *)PyMem_Calloc(1, sizeof(basicblock));
-    if (b == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3707]) {
+      if ((b == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3707\n");
+      else
+        fprintf(stderr, "reached bug index 3707\n");
+    }
+    if ((!FIXREVERTER[3707] && (b == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     /* Extend the singly linked list of blocks with new block. */
     b->b_list = g->g_block_list;
     g->g_block_list = b;
@@ -183,9 +217,24 @@ basicblock_addop(basicblock *b, int opcode, int oparg, location loc)
     assert(0 <= oparg && oparg < (1 << 30));
 
     int off = basicblock_next_instr(b);
-    if (off < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3708]) {
+      if ((off < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3708\n");
+      else
+        fprintf(stderr, "reached bug index 3708\n");
+    }
+    if ((!FIXREVERTER[3708] && (off < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     cfg_instr *i = &b->b_instr[off];
     i->i_opcode = opcode;
     i->i_oparg = oparg;
@@ -243,9 +292,24 @@ copy_basicblock(cfg_builder *g, basicblock *block)
      */
     assert(BB_NO_FALLTHROUGH(block));
     basicblock *result = cfg_builder_new_block(g);
-    if (result == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3710]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3710\n");
+      else
+        fprintf(stderr, "reached bug index 3710\n");
+    }
+    if ((!FIXREVERTER[3710] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (basicblock_append_instructions(result, block) < 0) {
         return NULL;
     }
@@ -367,9 +431,24 @@ cfg_builder_maybe_start_new_block(cfg_builder *g)
 {
     if (cfg_builder_current_block_is_terminated(g)) {
         basicblock *b = cfg_builder_new_block(g);
-        if (b == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3711]) {
+          if ((b == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3711\n");
+          else
+            fprintf(stderr, "reached bug index 3711\n");
+        }
+        if ((!FIXREVERTER[3711] && (b == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         b->b_label = g->g_current_label;
         g->g_current_label = NO_LABEL;
         cfg_builder_use_next_block(g, b);
@@ -403,9 +482,24 @@ init_cfg_builder(cfg_builder *g)
 {
     g->g_block_list = NULL;
     basicblock *block = cfg_builder_new_block(g);
-    if (block == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3712]) {
+      if ((block == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3712\n");
+      else
+        fprintf(stderr, "reached bug index 3712\n");
+    }
+    if ((!FIXREVERTER[3712] && (block == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     g->g_curblock = g->g_entryblock = block;
     g->g_current_label = NO_LABEL;
     return SUCCESS;
@@ -415,10 +509,25 @@ cfg_builder *
 _PyCfgBuilder_New(void)
 {
     cfg_builder *g = PyMem_Malloc(sizeof(cfg_builder));
-    if (g == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3713]) {
+      if ((g == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3713\n");
+      else
+        fprintf(stderr, "reached bug index 3713\n");
+    }
+    if ((!FIXREVERTER[3713] && (g == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     memset(g, 0, sizeof(cfg_builder));
     if (init_cfg_builder(g) < 0) {
         PyMem_Free(g);
@@ -430,9 +539,24 @@ _PyCfgBuilder_New(void)
 void
 _PyCfgBuilder_Free(cfg_builder *g)
 {
-    if (g == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3714]) {
+      if ((g == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3714\n");
+      else
+        fprintf(stderr, "reached bug index 3714\n");
+    }
+    if ((!FIXREVERTER[3714] && (g == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(cfg_builder_check(g));
     basicblock *b = g->g_block_list;
     while (b != NULL) {
@@ -572,9 +696,24 @@ normalize_jumps_in_block(cfg_builder *g, basicblock *b) {
 
     basicblock *target = last->i_target;
     basicblock *backwards_jump = cfg_builder_new_block(g);
-    if (backwards_jump == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3715]) {
+      if ((backwards_jump == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3715\n");
+      else
+        fprintf(stderr, "reached bug index 3715\n");
+    }
+    if ((!FIXREVERTER[3715] && (backwards_jump == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     RETURN_IF_ERROR(
         basicblock_add_jump(backwards_jump, JUMP, target, last->i_loc));
     last->i_opcode = reversed_opcode;
@@ -609,10 +748,25 @@ check_cfg(cfg_builder *g) {
             int opcode = b->b_instr[i].i_opcode;
             assert(!IS_ASSEMBLER_OPCODE(opcode));
             if (IS_TERMINATOR_OPCODE(opcode)) {
-                if (i != b->b_iused - 1) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3716]) {
+                  if ((i != b -> b_iused - 1 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3716\n");
+                  else
+                    fprintf(stderr, "reached bug index 3716\n");
+                }
+                if ((!FIXREVERTER[3716] && (i != b -> b_iused - 1 ))
+                #else
+                if (0
+                #endif
+                ) {
                     PyErr_SetString(PyExc_SystemError, "malformed control flow graph.");
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
         }
     }
@@ -717,10 +871,25 @@ except_stack_top(struct _PyCfgExceptStack *stack) {
 static struct _PyCfgExceptStack *
 make_except_stack(void) {
     struct _PyCfgExceptStack *new = PyMem_Malloc(sizeof(struct _PyCfgExceptStack));
-    if (new == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3717]) {
+      if ((new == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3717\n");
+      else
+        fprintf(stderr, "reached bug index 3717\n");
+    }
+    if ((!FIXREVERTER[3717] && (new == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     new->depth = 0;
     new->handlers[0] = NULL;
     return new;
@@ -729,10 +898,25 @@ make_except_stack(void) {
 static struct _PyCfgExceptStack *
 copy_except_stack(struct _PyCfgExceptStack *stack) {
     struct _PyCfgExceptStack *copy = PyMem_Malloc(sizeof(struct _PyCfgExceptStack));
-    if (copy == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3718]) {
+      if ((copy == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3718\n");
+      else
+        fprintf(stderr, "reached bug index 3718\n");
+    }
+    if ((!FIXREVERTER[3718] && (copy == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     memcpy(copy, stack, sizeof(struct _PyCfgExceptStack));
     return copy;
 }
@@ -826,29 +1010,74 @@ calculate_stackdepth(cfg_builder *g)
         for (int i = 0; i < b->b_iused; i++) {
             cfg_instr *instr = &b->b_instr[i];
             int effect = stack_effect(instr->i_opcode, instr->i_oparg, 0);
-            if (effect == PY_INVALID_STACK_EFFECT) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3719]) {
+              if ((effect == 2147483647 ) && !(0))
+                fprintf(stderr, "triggered bug index 3719\n");
+              else
+                fprintf(stderr, "reached bug index 3719\n");
+            }
+            if ((!FIXREVERTER[3719] && (effect == 2147483647 ))
+            #else
+            if (0
+            #endif
+            ) {
                 PyErr_Format(PyExc_SystemError,
                              "Invalid stack effect for opcode=%d, arg=%i",
                              instr->i_opcode, instr->i_oparg);
                 goto error;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int new_depth = depth + effect;
-            if (new_depth < 0) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3720]) {
+              if ((new_depth < 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3720\n");
+              else
+                fprintf(stderr, "reached bug index 3720\n");
+            }
+            if ((!FIXREVERTER[3720] && (new_depth < 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                PyErr_Format(PyExc_ValueError,
                             "Invalid CFG, stack underflow");
                goto error;
             }
+            #ifdef FRCOV
+            }
+            #endif
             if (new_depth > maxdepth) {
                 maxdepth = new_depth;
             }
             if (HAS_TARGET(instr->i_opcode)) {
                 effect = stack_effect(instr->i_opcode, instr->i_oparg, 1);
-                if (effect == PY_INVALID_STACK_EFFECT) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3721]) {
+                  if ((effect == 2147483647 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3721\n");
+                  else
+                    fprintf(stderr, "reached bug index 3721\n");
+                }
+                if ((!FIXREVERTER[3721] && (effect == 2147483647 ))
+                #else
+                if (0
+                #endif
+                ) {
                     PyErr_Format(PyExc_SystemError,
                                  "Invalid stack effect for opcode=%d, arg=%i",
                                  instr->i_opcode, instr->i_oparg);
                     goto error;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 int target_depth = depth + effect;
                 assert(target_depth >= 0); /* invalid code or bug in stackdepth() */
                 if (target_depth > maxdepth) {
@@ -860,13 +1089,27 @@ calculate_stackdepth(cfg_builder *g)
             }
             depth = new_depth;
             assert(!IS_ASSEMBLER_OPCODE(instr->i_opcode));
-            if (IS_UNCONDITIONAL_JUMP_OPCODE(instr->i_opcode) ||
-                IS_SCOPE_EXIT_OPCODE(instr->i_opcode))
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3722]) {
+              if ((instr -> i_opcode == 256 || instr -> i_opcode == 257 || instr -> i_opcode == 76 || instr -> i_opcode == 74 || instr -> i_opcode == 75 || instr -> i_opcode == 33 || instr -> i_opcode == 102 || instr -> i_opcode == 100 || instr -> i_opcode == 101 ) && !(0))
+                fprintf(stderr, "triggered bug index 3722\n");
+              else
+                fprintf(stderr, "reached bug index 3722\n");
+            }
+            if ((!FIXREVERTER[3722] && (instr -> i_opcode == 256 || instr -> i_opcode == 257 || instr -> i_opcode == 76 || instr -> i_opcode == 74 || instr -> i_opcode == 75 || instr -> i_opcode == 33 || instr -> i_opcode == 102 || instr -> i_opcode == 100 || instr -> i_opcode == 101 ))
+            #else
+            if (0
+            #endif
+            )
             {
                 /* remaining code is dead */
                 next = NULL;
                 break;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         if (next != NULL) {
             assert(BB_HAS_FALLTHROUGH(b));
@@ -884,15 +1127,45 @@ calculate_stackdepth(cfg_builder *g)
 static int
 label_exception_targets(basicblock *entryblock) {
     basicblock **todo_stack = make_cfg_traversal_stack(entryblock);
-    if (todo_stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3723]) {
+      if ((todo_stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3723\n");
+      else
+        fprintf(stderr, "reached bug index 3723\n");
+    }
+    if ((!FIXREVERTER[3723] && (todo_stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     struct _PyCfgExceptStack *except_stack = make_except_stack();
-    if (except_stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3724]) {
+      if ((except_stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3724\n");
+      else
+        fprintf(stderr, "reached bug index 3724\n");
+    }
+    if ((!FIXREVERTER[3724] && (except_stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyMem_Free(todo_stack);
         PyErr_NoMemory();
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     except_stack->depth = 0;
     todo_stack[0] = entryblock;
     entryblock->b_visited = 1;
@@ -913,9 +1186,24 @@ label_exception_targets(basicblock *entryblock) {
             if (is_block_push(instr)) {
                 if (!instr->i_target->b_visited) {
                     struct _PyCfgExceptStack *copy = copy_except_stack(except_stack);
-                    if (copy == NULL) {
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[3725]) {
+                      if ((copy == (void *) 0 ) && !(0))
+                        fprintf(stderr, "triggered bug index 3725\n");
+                      else
+                        fprintf(stderr, "reached bug index 3725\n");
+                    }
+                    if ((!FIXREVERTER[3725] && (copy == (void *) 0 ))
+                    #else
+                    if (0
+                    #endif
+                    ) {
                         goto error;
                     }
+                    #ifdef FRCOV
+                    }
+                    #endif
                     instr->i_target->b_exceptstack = copy;
                     todo[0] = instr->i_target;
                     instr->i_target->b_visited = 1;
@@ -933,9 +1221,24 @@ label_exception_targets(basicblock *entryblock) {
                 if (!instr->i_target->b_visited) {
                     if (BB_HAS_FALLTHROUGH(b)) {
                         struct _PyCfgExceptStack *copy = copy_except_stack(except_stack);
-                        if (copy == NULL) {
+                        
+                        #ifdef FRCOV
+                        {if (FIXREVERTER[3726]) {
+                          if ((copy == (void *) 0 ) && !(0))
+                            fprintf(stderr, "triggered bug index 3726\n");
+                          else
+                            fprintf(stderr, "reached bug index 3726\n");
+                        }
+                        if ((!FIXREVERTER[3726] && (copy == (void *) 0 ))
+                        #else
+                        if (0
+                        #endif
+                        ) {
                             goto error;
                         }
+                        #ifdef FRCOV
+                        }
+                        #endif
                         instr->i_target->b_exceptstack = copy;
                     }
                     else {
@@ -997,9 +1300,24 @@ remove_unreachable(basicblock *entryblock) {
         b->b_predecessors = 0;
     }
     basicblock **stack = make_cfg_traversal_stack(entryblock);
-    if (stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3727]) {
+      if ((stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3727\n");
+      else
+        fprintf(stderr, "reached bug index 3727\n");
+    }
+    if ((!FIXREVERTER[3727] && (stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     basicblock **sp = stack;
     entryblock->b_predecessors = 1;
     *sp++ = entryblock;
@@ -1079,9 +1397,24 @@ basicblock_remove_redundant_nops(basicblock *bb) {
                         next_loc = instr->i_loc;
                         break;
                     }
-                    if (lineno == next_loc.lineno) {
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[3732]) {
+                      if ((lineno == next_loc . lineno ) && !(0))
+                        fprintf(stderr, "triggered bug index 3732\n");
+                      else
+                        fprintf(stderr, "reached bug index 3732\n");
+                    }
+                    if ((!FIXREVERTER[3732] && (lineno == next_loc . lineno ))
+                    #else
+                    if (0
+                    #endif
+                    ) {
                         continue;
                     }
+                    #ifdef FRCOV
+                    }
+                    #endif
                 }
             }
 
@@ -1166,16 +1499,46 @@ remove_redundant_jumps(cfg_builder *g) {
     int changes = 0;
     for (basicblock *b = g->g_entryblock; b != NULL; b = b->b_next) {
         cfg_instr *last = basicblock_last_instr(b);
-        if (last == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3734]) {
+          if ((last == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3734\n");
+          else
+            fprintf(stderr, "reached bug index 3734\n");
+        }
+        if ((!FIXREVERTER[3734] && (last == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         assert(!IS_ASSEMBLER_OPCODE(last->i_opcode));
         if (IS_UNCONDITIONAL_JUMP_OPCODE(last->i_opcode)) {
             basicblock* jump_target = next_nonempty_block(last->i_target);
-            if (jump_target == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3735]) {
+              if ((jump_target == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3735\n");
+              else
+                fprintf(stderr, "reached bug index 3735\n");
+            }
+            if ((!FIXREVERTER[3735] && (jump_target == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 PyErr_SetString(PyExc_SystemError, "jump with NULL target");
                 return ERROR;
             }
+            #ifdef FRCOV
+            }
+            #endif
             basicblock *next = next_nonempty_block(b->b_next);
             if (jump_target == next) {
                 changes++;
@@ -1208,9 +1571,24 @@ basicblock_has_no_lineno(basicblock *b) {
 static int
 basicblock_inline_small_or_no_lineno_blocks(basicblock *bb) {
     cfg_instr *last = basicblock_last_instr(bb);
-    if (last == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3736]) {
+      if ((last == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3736\n");
+      else
+        fprintf(stderr, "reached bug index 3736\n");
+    }
+    if ((!FIXREVERTER[3736] && (last == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!IS_UNCONDITIONAL_JUMP_OPCODE(last->i_opcode)) {
         return 0;
     }
@@ -1290,11 +1668,26 @@ get_const_value(int opcode, int oparg, PyObject *co_consts)
         constant = PyList_GET_ITEM(co_consts, oparg);
     }
 
-    if (constant == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3737]) {
+      if ((constant == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3737\n");
+      else
+        fprintf(stderr, "reached bug index 3737\n");
+    }
+    if ((!FIXREVERTER[3737] && (constant == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_SystemError,
                         "Internal error: failed to get value of a constant");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return Py_NewRef(constant);
 }
 
@@ -1353,22 +1746,67 @@ fold_tuple_on_constants(PyObject *const_cache,
 
     /* Buildup new tuple of constants */
     PyObject *newconst = PyTuple_New(n);
-    if (newconst == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3738]) {
+      if ((newconst == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3738\n");
+      else
+        fprintf(stderr, "reached bug index 3738\n");
+    }
+    if ((!FIXREVERTER[3738] && (newconst == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (int i = 0; i < n; i++) {
         int op = inst[i].i_opcode;
         int arg = inst[i].i_oparg;
         PyObject *constant = get_const_value(op, arg, consts);
-        if (constant == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3739]) {
+          if ((constant == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3739\n");
+          else
+            fprintf(stderr, "reached bug index 3739\n");
+        }
+        if ((!FIXREVERTER[3739] && (constant == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         PyTuple_SET_ITEM(newconst, i, constant);
     }
     int index = add_const(newconst, consts, const_cache);
-    if (index < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3740]) {
+      if ((index < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3740\n");
+      else
+        fprintf(stderr, "reached bug index 3740\n");
+    }
+    if ((!FIXREVERTER[3740] && (index < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (int i = 0; i < n; i++) {
         INSTR_SET_OP0(&inst[i], NOP);
     }
@@ -1410,10 +1848,25 @@ swaptimize(basicblock *block, int *ix)
     }
     // Create an array with elements {0, 1, 2, ..., depth - 1}:
     int *stack = PyMem_Malloc(depth * sizeof(int));
-    if (stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3742]) {
+      if ((stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3742\n");
+      else
+        fprintf(stderr, "reached bug index 3742\n");
+    }
+    if ((!FIXREVERTER[3742] && (stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (int i = 0; i < depth; i++) {
         stack[i] = i;
     }
@@ -1501,12 +1954,42 @@ next_swappable_instruction(basicblock *block, int i, int lineno)
             // changes in the names bound between line tracing events!
             return -1;
         }
-        if (instruction->i_opcode == NOP) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3743]) {
+          if ((instruction -> i_opcode == 27 ) && !(0))
+            fprintf(stderr, "triggered bug index 3743\n");
+          else
+            fprintf(stderr, "reached bug index 3743\n");
+        }
+        if ((!FIXREVERTER[3743] && (instruction -> i_opcode == 27 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
-        if (SWAPPABLE(instruction->i_opcode)) {
+        #ifdef FRCOV
+        }
+        #endif
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3744]) {
+          if ((instruction -> i_opcode == 109 || instruction -> i_opcode == 263 || instruction -> i_opcode == 29 ) && !(0))
+            fprintf(stderr, "triggered bug index 3744\n");
+          else
+            fprintf(stderr, "reached bug index 3744\n");
+        }
+        if ((!FIXREVERTER[3744] && (instruction -> i_opcode == 109 || instruction -> i_opcode == 263 || instruction -> i_opcode == 29 ))
+        #else
+        if (0
+        #endif
+        ) {
             return i;
         }
+        #ifdef FRCOV
+        }
+        #endif
         return -1;
     }
     return -1;
@@ -1522,25 +2005,85 @@ apply_static_swaps(basicblock *block, int i)
     for (; 0 <= i; i--) {
         assert(i < block->b_iused);
         cfg_instr *swap = &block->b_instr[i];
-        if (swap->i_opcode != SWAP) {
-            if (swap->i_opcode == NOP || SWAPPABLE(swap->i_opcode)) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3746]) {
+          if ((swap -> i_opcode != 114 ) && !(0))
+            fprintf(stderr, "triggered bug index 3746\n");
+          else
+            fprintf(stderr, "reached bug index 3746\n");
+        }
+        if ((!FIXREVERTER[3746] && (swap -> i_opcode != 114 ))
+        #else
+        if (0
+        #endif
+        ) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3745]) {
+              if ((swap -> i_opcode == 27 || swap -> i_opcode == 109 || swap -> i_opcode == 263 || swap -> i_opcode == 29 ) && !(0))
+                fprintf(stderr, "triggered bug index 3745\n");
+              else
+                fprintf(stderr, "reached bug index 3745\n");
+            }
+            if ((!FIXREVERTER[3745] && (swap -> i_opcode == 27 || swap -> i_opcode == 109 || swap -> i_opcode == 263 || swap -> i_opcode == 29 ))
+            #else
+            if (0
+            #endif
+            ) {
                 // Nope, but we know how to handle these. Keep looking:
                 continue;
             }
+            #ifdef FRCOV
+            }
+            #endif
             // We can't reason about what this instruction does. Bail:
             return;
         }
+        #ifdef FRCOV
+        }
+        #endif
         int j = next_swappable_instruction(block, i, -1);
-        if (j < 0) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3747]) {
+          if ((j < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3747\n");
+          else
+            fprintf(stderr, "reached bug index 3747\n");
+        }
+        if ((!FIXREVERTER[3747] && (j < 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return;
         }
+        #ifdef FRCOV
+        }
+        #endif
         int k = j;
         int lineno = block->b_instr[j].i_loc.lineno;
         for (int count = swap->i_oparg - 1; 0 < count; count--) {
             k = next_swappable_instruction(block, k, lineno);
-            if (k < 0) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3748]) {
+              if ((k < 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3748\n");
+              else
+                fprintf(stderr, "reached bug index 3748\n");
+            }
+            if ((!FIXREVERTER[3748] && (k < 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return;
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         // The reordering is not safe if the two instructions to be swapped
         // store to the same location, or if any intervening instruction stores
@@ -1594,9 +2137,24 @@ basicblock_optimize_load_const(PyObject *const_cache, basicblock *bb, PyObject *
             {
                 /* Remove LOAD_CONST const; conditional jump */
                 PyObject* cnt = get_const_value(opcode, oparg, consts);
-                if (cnt == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3751]) {
+                  if ((cnt == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3751\n");
+                  else
+                    fprintf(stderr, "reached bug index 3751\n");
+                }
+                if ((!FIXREVERTER[3751] && (cnt == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 int is_true = PyObject_IsTrue(cnt);
                 Py_DECREF(cnt);
                 if (is_true == -1) {
@@ -1625,33 +2183,93 @@ basicblock_optimize_load_const(PyObject *const_cache, basicblock *bb, PyObject *
                 // - LOAD_CONST(None) IS_OP(0) TO_BOOL POP_JUMP_IF_FALSE
                 // - LOAD_CONST(None) IS_OP(1) TO_BOOL POP_JUMP_IF_TRUE
                 PyObject *cnt = get_const_value(opcode, oparg, consts);
-                if (cnt == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3752]) {
+                  if ((cnt == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3752\n");
+                  else
+                    fprintf(stderr, "reached bug index 3752\n");
+                }
+                if ((!FIXREVERTER[3752] && (cnt == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 if (!Py_IsNone(cnt)) {
                     Py_DECREF(cnt);
                     break;
                 }
-                if (bb->b_iused <= i + 2) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3753]) {
+                  if ((bb -> b_iused <= i + 2 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3753\n");
+                  else
+                    fprintf(stderr, "reached bug index 3753\n");
+                }
+                if ((!FIXREVERTER[3753] && (bb -> b_iused <= i + 2 ))
+                #else
+                if (0
+                #endif
+                ) {
                     break;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 cfg_instr *is_instr = &bb->b_instr[i + 1];
                 cfg_instr *jump_instr = &bb->b_instr[i + 2];
                 // Get rid of TO_BOOL regardless:
                 if (jump_instr->i_opcode == TO_BOOL) {
                     INSTR_SET_OP0(jump_instr, NOP);
-                    if (bb->b_iused <= i + 3) {
+                    
+                    #ifdef FRCOV
+                    {if (FIXREVERTER[3754]) {
+                      if ((bb -> b_iused <= i + 3 ) && !(0))
+                        fprintf(stderr, "triggered bug index 3754\n");
+                      else
+                        fprintf(stderr, "reached bug index 3754\n");
+                    }
+                    if ((!FIXREVERTER[3754] && (bb -> b_iused <= i + 3 ))
+                    #else
+                    if (0
+                    #endif
+                    ) {
                         break;
                     }
+                    #ifdef FRCOV
+                    }
+                    #endif
                     jump_instr = &bb->b_instr[i + 3];
                 }
                 bool invert = is_instr->i_oparg;
                 if (jump_instr->i_opcode == POP_JUMP_IF_FALSE) {
                     invert = !invert;
                 }
-                else if (jump_instr->i_opcode != POP_JUMP_IF_TRUE) {
+                else 
+                #ifdef FRCOV
+                {if (FIXREVERTER[3755]) {
+                  if ((jump_instr -> i_opcode != 99 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3755\n");
+                  else
+                    fprintf(stderr, "reached bug index 3755\n");
+                }
+                if ((!FIXREVERTER[3755] && (jump_instr -> i_opcode != 99 ))
+                #else
+                if (0
+                #endif
+                ) {
                     break;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 INSTR_SET_OP0(inst, NOP);
                 INSTR_SET_OP0(is_instr, NOP);
                 jump_instr->i_opcode = invert ? POP_JUMP_IF_NOT_NONE
@@ -1667,9 +2285,24 @@ basicblock_optimize_load_const(PyObject *const_cache, basicblock *bb, PyObject *
             case TO_BOOL:
             {
                 PyObject *cnt = get_const_value(opcode, oparg, consts);
-                if (cnt == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3756]) {
+                  if ((cnt == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3756\n");
+                  else
+                    fprintf(stderr, "reached bug index 3756\n");
+                }
+                if ((!FIXREVERTER[3756] && (cnt == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 int is_true = PyObject_IsTrue(cnt);
                 Py_DECREF(cnt);
                 if (is_true == -1) {
@@ -1677,9 +2310,24 @@ basicblock_optimize_load_const(PyObject *const_cache, basicblock *bb, PyObject *
                 }
                 cnt = PyBool_FromLong(is_true);
                 int index = add_const(cnt, consts, const_cache);
-                if (index < 0) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3757]) {
+                  if ((index < 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3757\n");
+                  else
+                    fprintf(stderr, "reached bug index 3757\n");
+                }
+                if ((!FIXREVERTER[3757] && (index < 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 INSTR_SET_OP0(inst, NOP);
                 INSTR_SET_OP1(&bb->b_instr[i + 1], LOAD_CONST, index);
                 break;
@@ -1908,9 +2556,24 @@ make_super_instruction(cfg_instr *inst1, cfg_instr *inst2, int super_op)
     if (line1 >= 0 && line2 >= 0 && line1 != line2) {
         return;
     }
-    if (inst1->i_oparg >= 16 || inst2->i_oparg >= 16) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3759]) {
+      if ((inst1 -> i_oparg >= 16 || inst2 -> i_oparg >= 16 ) && !(0))
+        fprintf(stderr, "triggered bug index 3759\n");
+      else
+        fprintf(stderr, "reached bug index 3759\n");
+    }
+    if ((!FIXREVERTER[3759] && (inst1 -> i_oparg >= 16 || inst2 -> i_oparg >= 16 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     INSTR_SET_OP1(inst1, super_op, (inst1->i_oparg << 4) | inst2->i_oparg);
     INSTR_SET_OP0(inst2, NOP);
 }
@@ -1977,9 +2640,24 @@ scan_block_for_locals(basicblock *b, basicblock ***sp)
         if (instr->i_except != NULL) {
             maybe_push(instr->i_except, unsafe_mask, sp);
         }
-        if (instr->i_oparg >= 64) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3760]) {
+          if ((instr -> i_oparg >= 64 ) && !(0))
+            fprintf(stderr, "triggered bug index 3760\n");
+          else
+            fprintf(stderr, "reached bug index 3760\n");
+        }
+        if ((!FIXREVERTER[3760] && (instr -> i_oparg >= 64 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         assert(instr->i_oparg >= 0);
         uint64_t bit = (uint64_t)1 << instr->i_oparg;
         switch (instr->i_opcode) {
@@ -2018,10 +2696,25 @@ fast_scan_many_locals(basicblock *entryblock, int nlocals)
 {
     assert(nlocals > 64);
     Py_ssize_t *states = PyMem_Calloc(nlocals - 64, sizeof(Py_ssize_t));
-    if (states == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3761]) {
+      if ((states == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3761\n");
+      else
+        fprintf(stderr, "reached bug index 3761\n");
+    }
+    if ((!FIXREVERTER[3761] && (states == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_ssize_t blocknum = 0;
     // state[i - 64] == blocknum if local i is guaranteed to
     // be initialized, i.e., if it has had a previous LOAD_FAST or
@@ -2033,9 +2726,24 @@ fast_scan_many_locals(basicblock *entryblock, int nlocals)
             cfg_instr *instr = &b->b_instr[i];
             assert(instr->i_opcode != EXTENDED_ARG);
             int arg = instr->i_oparg;
-            if (arg < 64) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3762]) {
+              if ((arg < 64 ) && !(0))
+                fprintf(stderr, "triggered bug index 3762\n");
+              else
+                fprintf(stderr, "reached bug index 3762\n");
+            }
+            if ((!FIXREVERTER[3762] && (arg < 64 ))
+            #else
+            if (0
+            #endif
+            ) {
                 continue;
             }
+            #ifdef FRCOV
+            }
+            #endif
             assert(arg >= 0);
             switch (instr->i_opcode) {
                 case DELETE_FAST:
@@ -2065,18 +2773,48 @@ remove_unused_consts(basicblock *entryblock, PyObject *consts)
 {
     assert(PyList_CheckExact(consts));
     Py_ssize_t nconsts = PyList_GET_SIZE(consts);
-    if (nconsts == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3763]) {
+      if ((nconsts == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3763\n");
+      else
+        fprintf(stderr, "reached bug index 3763\n");
+    }
+    if ((!FIXREVERTER[3763] && (nconsts == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return SUCCESS;  /* nothing to do */
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Py_ssize_t *index_map = NULL;
     Py_ssize_t *reverse_index_map = NULL;
     int err = ERROR;
 
     index_map = PyMem_Malloc(nconsts * sizeof(Py_ssize_t));
-    if (index_map == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3764]) {
+      if ((index_map == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3764\n");
+      else
+        fprintf(stderr, "reached bug index 3764\n");
+    }
+    if ((!FIXREVERTER[3764] && (index_map == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto end;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (Py_ssize_t i = 1; i < nconsts; i++) {
         index_map[i] = -1;
     }
@@ -2101,11 +2839,26 @@ remove_unused_consts(basicblock *entryblock, PyObject *consts)
             index_map[n_used_consts++] = index_map[i];
         }
     }
-    if (n_used_consts == nconsts) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3765]) {
+      if ((n_used_consts == nconsts ) && !(0))
+        fprintf(stderr, "triggered bug index 3765\n");
+      else
+        fprintf(stderr, "reached bug index 3765\n");
+    }
+    if ((!FIXREVERTER[3765] && (n_used_consts == nconsts ))
+    #else
+    if (0
+    #endif
+    ) {
         /* nothing to do */
         err = SUCCESS;
         goto end;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* move all used consts to the beginning of the consts list */
     assert(n_used_consts < nconsts);
@@ -2125,9 +2878,24 @@ remove_unused_consts(basicblock *entryblock, PyObject *consts)
     }
     /* adjust const indices in the bytecode */
     reverse_index_map = PyMem_Malloc(nconsts * sizeof(Py_ssize_t));
-    if (reverse_index_map == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3766]) {
+      if ((reverse_index_map == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3766\n");
+      else
+        fprintf(stderr, "reached bug index 3766\n");
+    }
+    if ((!FIXREVERTER[3766] && (reverse_index_map == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto end;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (Py_ssize_t i = 0; i < nconsts; i++) {
         reverse_index_map[i] = -1;
     }
@@ -2175,9 +2943,24 @@ add_checks_for_loads_of_uninitialized_variables(basicblock *entryblock,
         nlocals = 64;
     }
     basicblock **stack = make_cfg_traversal_stack(entryblock);
-    if (stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3768]) {
+      if ((stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3768\n");
+      else
+        fprintf(stderr, "reached bug index 3768\n");
+    }
+    if ((!FIXREVERTER[3768] && (stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     basicblock **sp = stack;
 
     // First origin of being uninitialized:
@@ -2210,9 +2993,24 @@ add_checks_for_loads_of_uninitialized_variables(basicblock *entryblock,
 static int
 mark_warm(basicblock *entryblock) {
     basicblock **stack = make_cfg_traversal_stack(entryblock);
-    if (stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3769]) {
+      if ((stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3769\n");
+      else
+        fprintf(stderr, "reached bug index 3769\n");
+    }
+    if ((!FIXREVERTER[3769] && (stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
     basicblock **sp = stack;
 
     *sp++ = entryblock;
@@ -2248,9 +3046,24 @@ mark_cold(basicblock *entryblock) {
     }
 
     basicblock **stack = make_cfg_traversal_stack(entryblock);
-    if (stack == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3770]) {
+      if ((stack == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3770\n");
+      else
+        fprintf(stderr, "reached bug index 3770\n");
+    }
+    if ((!FIXREVERTER[3770] && (stack == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     basicblock **sp = stack;
     for (basicblock *b = entryblock; b != NULL; b = b->b_next) {
@@ -2291,10 +3104,25 @@ mark_cold(basicblock *entryblock) {
 static int
 push_cold_blocks_to_end(cfg_builder *g) {
     basicblock *entryblock = g->g_entryblock;
-    if (entryblock->b_next == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3771]) {
+      if ((entryblock -> b_next == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3771\n");
+      else
+        fprintf(stderr, "reached bug index 3771\n");
+    }
+    if ((!FIXREVERTER[3771] && (entryblock -> b_next == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* single basicblock, no need to reorder */
         return SUCCESS;
     }
+    #ifdef FRCOV
+    }
+    #endif
     RETURN_IF_ERROR(mark_cold(entryblock));
 
     int next_lbl = get_max_label(g->g_entryblock) + 1;
@@ -2304,9 +3132,24 @@ push_cold_blocks_to_end(cfg_builder *g) {
     for (basicblock *b = entryblock; b != NULL; b = b->b_next) {
         if (b->b_cold && BB_HAS_FALLTHROUGH(b) && b->b_next && b->b_next->b_warm) {
             basicblock *explicit_jump = cfg_builder_new_block(g);
-            if (explicit_jump == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[3772]) {
+              if ((explicit_jump == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 3772\n");
+              else
+                fprintf(stderr, "reached bug index 3772\n");
+            }
+            if ((!FIXREVERTER[3772] && (explicit_jump == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return ERROR;
             }
+            #ifdef FRCOV
+            }
+            #endif
             if (!IS_LABEL(b->b_next->b_label)) {
                 b->b_next->b_label.id = next_lbl++;
             }
@@ -2333,10 +3176,25 @@ push_cold_blocks_to_end(cfg_builder *g) {
         while (b->b_next && !b->b_next->b_cold) {
             b = b->b_next;
         }
-        if (b->b_next == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3773]) {
+          if ((b -> b_next == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3773\n");
+          else
+            fprintf(stderr, "reached bug index 3773\n");
+        }
+        if ((!FIXREVERTER[3773] && (b -> b_next == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             /* no more cold blocks */
             break;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         /* b->b_next is the beginning of a cold streak */
         assert(!b->b_cold && b->b_next->b_cold);
@@ -2422,16 +3280,46 @@ duplicate_exits_without_lineno(cfg_builder *g)
     basicblock *entryblock = g->g_entryblock;
     for (basicblock *b = entryblock; b != NULL; b = b->b_next) {
         cfg_instr *last = basicblock_last_instr(b);
-        if (last == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3774]) {
+          if ((last == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3774\n");
+          else
+            fprintf(stderr, "reached bug index 3774\n");
+        }
+        if ((!FIXREVERTER[3774] && (last == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (is_jump(last)) {
             basicblock *target = next_nonempty_block(last->i_target);
             if (is_exit_or_eval_check_without_lineno(target) && target->b_predecessors > 1) {
                 basicblock *new_target = copy_basicblock(g, target);
-                if (new_target == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[3775]) {
+                  if ((new_target == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 3775\n");
+                  else
+                    fprintf(stderr, "reached bug index 3775\n");
+                }
+                if ((!FIXREVERTER[3775] && (new_target == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     return ERROR;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 new_target->b_instr[0].i_loc = last->i_loc;
                 last->i_target = new_target;
                 target->b_predecessors--;
@@ -2469,9 +3357,24 @@ static void
 propagate_line_numbers(basicblock *entryblock) {
     for (basicblock *b = entryblock; b != NULL; b = b->b_next) {
         cfg_instr *last = basicblock_last_instr(b);
-        if (last == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3776]) {
+          if ((last == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3776\n");
+          else
+            fprintf(stderr, "reached bug index 3776\n");
+        }
+        if ((!FIXREVERTER[3776] && (last == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         location prev_location = NO_LOCATION;
         for (int i = 0; i < b->b_iused; i++) {
@@ -2542,10 +3445,25 @@ build_cellfixedoffsets(_PyCompile_CodeUnitMetadata *umd)
 
     int noffsets = ncellvars + nfreevars;
     int *fixed = PyMem_New(int, noffsets);
-    if (fixed == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3777]) {
+      if ((fixed == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3777\n");
+      else
+        fprintf(stderr, "reached bug index 3777\n");
+    }
+    if ((!FIXREVERTER[3777] && (fixed == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (int i = 0; i < noffsets; i++) {
         fixed[i] = nlocals + i;
     }
@@ -2557,9 +3475,24 @@ build_cellfixedoffsets(_PyCompile_CodeUnitMetadata *umd)
         if (PyDict_GetItemRef(umd->u_varnames, varname, &varindex) < 0) {
             goto error;
         }
-        if (varindex == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3778]) {
+          if ((varindex == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3778\n");
+          else
+            fprintf(stderr, "reached bug index 3778\n");
+        }
+        if ((!FIXREVERTER[3778] && (varindex == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         int argoffset = PyLong_AsInt(varindex);
         Py_DECREF(varindex);
@@ -2621,10 +3554,25 @@ insert_prefix_instructions(_PyCompile_CodeUnitMetadata *umd, basicblock *entrybl
         // adjust for arg cells, which come first.
         const int nvars = ncellvars + (int)PyDict_GET_SIZE(umd->u_varnames);
         int *sorted = PyMem_RawCalloc(nvars, sizeof(int));
-        if (sorted == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3779]) {
+          if ((sorted == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3779\n");
+          else
+            fprintf(stderr, "reached bug index 3779\n");
+        }
+        if ((!FIXREVERTER[3779] && (sorted == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
         for (int i = 0; i < ncellvars; i++) {
             sorted[fixed[i]] = i + 1;
         }
@@ -2720,9 +3668,24 @@ prepare_localsplus(_PyCompile_CodeUnitMetadata *umd, cfg_builder *g, int code_fl
     assert(INT_MAX - nlocals - ncellvars - nfreevars > 0);
     int nlocalsplus = nlocals + ncellvars + nfreevars;
     int* cellfixedoffsets = build_cellfixedoffsets(umd);
-    if (cellfixedoffsets == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3780]) {
+      if ((cellfixedoffsets == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3780\n");
+      else
+        fprintf(stderr, "reached bug index 3780\n");
+    }
+    if ((!FIXREVERTER[3780] && (cellfixedoffsets == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     // This must be called before fix_cell_offsets().
     if (insert_prefix_instructions(umd, g->g_entryblock, cellfixedoffsets, nfreevars, code_flags)) {
@@ -2733,9 +3696,24 @@ prepare_localsplus(_PyCompile_CodeUnitMetadata *umd, cfg_builder *g, int code_fl
     int numdropped = fix_cell_offsets(umd, g->g_entryblock, cellfixedoffsets);
     PyMem_Free(cellfixedoffsets);  // At this point we're done with it.
     cellfixedoffsets = NULL;
-    if (numdropped < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3781]) {
+      if ((numdropped < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3781\n");
+      else
+        fprintf(stderr, "reached bug index 3781\n");
+    }
+    if ((!FIXREVERTER[3781] && (numdropped < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return ERROR;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     nlocalsplus -= numdropped;
     return nlocalsplus;
@@ -2748,9 +3726,24 @@ _PyCfg_FromInstructionSequence(_PyInstructionSequence *seq)
         return NULL;
     }
     cfg_builder *g = _PyCfgBuilder_New();
-    if (g == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3782]) {
+      if ((g == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3782\n");
+      else
+        fprintf(stderr, "reached bug index 3782\n");
+    }
+    if ((!FIXREVERTER[3782] && (g == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     for (int i = 0; i < seq->s_used; i++) {
         seq->s_instrs[i].i_target = 0;
     }
diff --git a/Python/frame.c b/Python/frame.c
index 9c7e59601e6..adfb8f90741 100644
--- a/Python/frame.c
+++ b/Python/frame.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 #define _PY_INTERPRETER
 
@@ -32,10 +36,25 @@ _PyFrame_MakeAndSetFrameObject(_PyInterpreterFrame *frame)
     PyObject *exc = PyErr_GetRaisedException();
 
     PyFrameObject *f = _PyFrame_New_NoTrack(_PyFrame_GetCode(frame));
-    if (f == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4263]) {
+      if ((f == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4263\n");
+      else
+        fprintf(stderr, "reached bug index 4263\n");
+    }
+    if ((!FIXREVERTER[4263] && (f == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_XDECREF(exc);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyErr_SetRaisedException(exc);
 
     // GH-97002: There was a time when a frame object could be created when we
diff --git a/Python/gc.c b/Python/gc.c
index 38a0da91a97..06bf1a2b2a6 100644
--- a/Python/gc.c
+++ b/Python/gc.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 //  This implements the reference cycle garbage collector.
 //  The Python module interface to the collector is in gcmodule.c.
 //  See https://devguide.python.org/internals/garbage-collector/
@@ -1598,18 +1602,48 @@ do_gc_callback(GCState *gcstate, const char *phase,
             "generation", generation,
             "collected", stats->collected,
             "uncollectable", stats->uncollectable);
-        if (info == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1858]) {
+          if ((info == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 1858\n");
+          else
+            fprintf(stderr, "reached bug index 1858\n");
+        }
+        if ((!FIXREVERTER[1858] && (info == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_FormatUnraisable("Exception ignored on invoking gc callbacks");
             return;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     PyObject *phase_obj = PyUnicode_FromString(phase);
-    if (phase_obj == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1859]) {
+      if ((phase_obj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1859\n");
+      else
+        fprintf(stderr, "reached bug index 1859\n");
+    }
+    if ((!FIXREVERTER[1859] && (phase_obj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_XDECREF(info);
         PyErr_FormatUnraisable("Exception ignored on invoking gc callbacks");
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *stack[] = {phase_obj, info};
     for (Py_ssize_t i=0; i<PyList_GET_SIZE(gcstate->callbacks); i++) {
@@ -1633,9 +1667,24 @@ static void
 invoke_gc_callback(GCState *gcstate, const char *phase,
                    int generation, struct gc_collection_stats *stats)
 {
-    if (gcstate->callbacks == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1860]) {
+      if ((gcstate -> callbacks == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1860\n");
+      else
+        fprintf(stderr, "reached bug index 1860\n");
+    }
+    if ((!FIXREVERTER[1860] && (gcstate -> callbacks == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     do_gc_callback(gcstate, phase, generation, stats);
 }
 
@@ -2015,14 +2064,44 @@ static PyObject *
 gc_alloc(PyTypeObject *tp, size_t basicsize, size_t presize)
 {
     PyThreadState *tstate = _PyThreadState_GET();
-    if (basicsize > PY_SSIZE_T_MAX - presize) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1862]) {
+      if ((basicsize > 9223372036854775807 - presize ) && !(0))
+        fprintf(stderr, "triggered bug index 1862\n");
+      else
+        fprintf(stderr, "reached bug index 1862\n");
+    }
+    if ((!FIXREVERTER[1862] && (basicsize > 9223372036854775807 - presize ))
+    #else
+    if (0
+    #endif
+    ) {
         return _PyErr_NoMemory(tstate);
     }
+    #ifdef FRCOV
+    }
+    #endif
     size_t size = presize + basicsize;
     char *mem = _PyObject_MallocWithType(tp, size);
-    if (mem == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1863]) {
+      if ((mem == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1863\n");
+      else
+        fprintf(stderr, "reached bug index 1863\n");
+    }
+    if ((!FIXREVERTER[1863] && (mem == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return _PyErr_NoMemory(tstate);
     }
+    #ifdef FRCOV
+    }
+    #endif
     ((PyObject **)mem)[0] = NULL;
     ((PyObject **)mem)[1] = NULL;
     PyObject *op = (PyObject *)(mem + presize);
@@ -2040,9 +2119,24 @@ _PyObject_GC_New(PyTypeObject *tp)
         size += _PyInlineValuesSize(tp);
     }
     PyObject *op = gc_alloc(tp, size, presize);
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1864]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1864\n");
+      else
+        fprintf(stderr, "reached bug index 1864\n");
+    }
+    if ((!FIXREVERTER[1864] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyObject_Init(op, tp);
     return op;
 }
@@ -2052,16 +2146,46 @@ _PyObject_GC_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
 {
     PyVarObject *op;
 
-    if (nitems < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1865]) {
+      if ((nitems < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1865\n");
+      else
+        fprintf(stderr, "reached bug index 1865\n");
+    }
+    if ((!FIXREVERTER[1865] && (nitems < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_BadInternalCall();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     size_t presize = _PyType_PreHeaderSize(tp);
     size_t size = _PyObject_VAR_SIZE(tp, nitems);
     op = (PyVarObject *)gc_alloc(tp, size, presize);
-    if (op == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1866]) {
+      if ((op == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1866\n");
+      else
+        fprintf(stderr, "reached bug index 1866\n");
+    }
+    if ((!FIXREVERTER[1866] && (op == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     _PyObject_InitVar(op, tp, nitems);
     return op;
 }
diff --git a/Python/getargs.c b/Python/getargs.c
index b96ce3a22da..d4cac3f7463 100644
--- a/Python/getargs.c
+++ b/Python/getargs.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* New getargs implementation */
 
@@ -289,17 +293,47 @@ vgetargs1_impl(PyObject *compat_args, PyObject *const *stack, Py_ssize_t nargs,
 
     if (max > STATIC_FREELIST_ENTRIES) {
         freelist.entries = PyMem_NEW(freelistentry_t, max);
-        if (freelist.entries == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3]) {
+          if ((freelist . entries == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3\n");
+          else
+            fprintf(stderr, "reached bug index 3\n");
+        }
+        if ((!FIXREVERTER[3] && (freelist . entries == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return 0;
         }
+        #ifdef FRCOV
+        }
+        #endif
         freelist.entries_malloced = 1;
     }
 
     if (compat) {
         if (max == 0) {
-            if (compat_args == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[4]) {
+              if ((compat_args == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 4\n");
+              else
+                fprintf(stderr, "reached bug index 4\n");
+            }
+            if ((!FIXREVERTER[4] && (compat_args == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return 1;
+                #ifdef FRCOV
+                }
+                #endif
             PyErr_Format(PyExc_TypeError,
                          "%.200s%s takes no arguments",
                          fname==NULL ? "function" : fname,
@@ -307,17 +341,47 @@ vgetargs1_impl(PyObject *compat_args, PyObject *const *stack, Py_ssize_t nargs,
             return cleanreturn(0, &freelist);
         }
         else if (min == 1 && max == 1) {
-            if (compat_args == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[5]) {
+              if ((compat_args == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 5\n");
+              else
+                fprintf(stderr, "reached bug index 5\n");
+            }
+            if ((!FIXREVERTER[5] && (compat_args == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 PyErr_Format(PyExc_TypeError,
                              "%.200s%s takes at least one argument",
                              fname==NULL ? "function" : fname,
                              fname==NULL ? "" : "()");
                 return cleanreturn(0, &freelist);
             }
+            #ifdef FRCOV
+            }
+            #endif
             msg = convertitem(compat_args, &format, p_va, flags, levels,
                               msgbuf, sizeof(msgbuf), &freelist);
-            if (msg == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[6]) {
+              if ((msg == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 6\n");
+              else
+                fprintf(stderr, "reached bug index 6\n");
+            }
+            if ((!FIXREVERTER[6] && (msg == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return cleanreturn(1, &freelist);
+                #ifdef FRCOV
+                }
+                #endif
             seterror(levels[0], msg, levels+1, fname, message);
             return cleanreturn(0, &freelist);
         }
@@ -328,7 +392,19 @@ vgetargs1_impl(PyObject *compat_args, PyObject *const *stack, Py_ssize_t nargs,
         }
     }
 
-    if (nargs < min || max < nargs) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7]) {
+      if ((nargs < min || max < nargs ) && !(0))
+        fprintf(stderr, "triggered bug index 7\n");
+      else
+        fprintf(stderr, "reached bug index 7\n");
+    }
+    if ((!FIXREVERTER[7] && (nargs < min || max < nargs ))
+    #else
+    if (0
+    #endif
+    ) {
         if (message == NULL)
             PyErr_Format(PyExc_TypeError,
                          "%.150s%s takes %s %d argument%s (%zd given)",
@@ -343,6 +419,9 @@ vgetargs1_impl(PyObject *compat_args, PyObject *const *stack, Py_ssize_t nargs,
             PyErr_SetString(PyExc_TypeError, message);
         return cleanreturn(0, &freelist);
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (i = 0; i < nargs; i++) {
         if (*format == '|')
@@ -494,13 +573,28 @@ converttuple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
     }
 
     len = PySequence_Size(arg);
-    if (len != n) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[9]) {
+      if ((len != n ) && !(0))
+        fprintf(stderr, "triggered bug index 9\n");
+      else
+        fprintf(stderr, "reached bug index 9\n");
+    }
+    if ((!FIXREVERTER[9] && (len != n ))
+    #else
+    if (0
+    #endif
+    ) {
         levels[0] = 0;
         PyOS_snprintf(msgbuf, bufsize,
                       "must be sequence of length %d, not %zd",
                       n, len);
         return msgbuf;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     format = *p_format;
     for (i = 0; i < n; i++) {
@@ -878,8 +972,23 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
             break;
         }
         count = convertbuffer(arg, (const void **)p, &buf);
-        if (count < 0)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[10]) {
+          if ((count < 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 10\n");
+          else
+            fprintf(stderr, "reached bug index 10\n");
+        }
+        if ((!FIXREVERTER[10] && (count < 0 ))
+        #else
+        if (0
+        #endif
+        )
             return converterr(buf, arg, msgbuf, bufsize);
+            #ifdef FRCOV
+            }
+            #endif
         if (*format == '#') {
             Py_ssize_t *psize = va_arg(*p_va, Py_ssize_t*);
             *psize = count;
@@ -905,9 +1014,24 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
             else if (PyUnicode_Check(arg)) {
                 Py_ssize_t len;
                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);
-                if (sarg == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[11]) {
+                  if ((sarg == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 11\n");
+                  else
+                    fprintf(stderr, "reached bug index 11\n");
+                }
+                if ((!FIXREVERTER[11] && (sarg == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     return converterr(CONV_UNICODE,
                                       arg, msgbuf, bufsize);
+                                      #ifdef FRCOV
+                                      }
+                                      #endif
                 PyBuffer_FillInfo(p, arg, (void *)sarg, len, 1, 0);
             }
             else { /* any bytes-like object */
@@ -933,9 +1057,24 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
             else if (PyUnicode_Check(arg)) {
                 Py_ssize_t len;
                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);
-                if (sarg == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[12]) {
+                  if ((sarg == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 12\n");
+                  else
+                    fprintf(stderr, "reached bug index 12\n");
+                }
+                if ((!FIXREVERTER[12] && (sarg == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     return converterr(CONV_UNICODE,
                                       arg, msgbuf, bufsize);
+                                      #ifdef FRCOV
+                                      }
+                                      #endif
                 *p = sarg;
                 *psize = len;
             }
@@ -943,8 +1082,23 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
                 /* XXX Really? */
                 const char *buf;
                 Py_ssize_t count = convertbuffer(arg, p, &buf);
-                if (count < 0)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[13]) {
+                  if ((count < 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 13\n");
+                  else
+                    fprintf(stderr, "reached bug index 13\n");
+                }
+                if ((!FIXREVERTER[13] && (count < 0 ))
+                #else
+                if (0
+                #endif
+                )
                     return converterr(buf, arg, msgbuf, bufsize);
+                    #ifdef FRCOV
+                    }
+                    #endif
                 *psize = count;
             }
             format++;
@@ -958,9 +1112,24 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
                 *p = NULL;
             else if (PyUnicode_Check(arg)) {
                 sarg = PyUnicode_AsUTF8AndSize(arg, &len);
-                if (sarg == NULL)
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[14]) {
+                  if ((sarg == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 14\n");
+                  else
+                    fprintf(stderr, "reached bug index 14\n");
+                }
+                if ((!FIXREVERTER[14] && (sarg == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                )
                     return converterr(CONV_UNICODE,
                                       arg, msgbuf, bufsize);
+                                      #ifdef FRCOV
+                                      }
+                                      #endif
                 if (strlen(sarg) != (size_t)len) {
                     PyErr_SetString(PyExc_ValueError, "embedded null character");
                     RETURN_ERR_OCCURRED;
@@ -984,8 +1153,23 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
 
         /* Get 'e' parameter: the encoding name */
         encoding = (const char *)va_arg(*p_va, const char *);
-        if (encoding == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[15]) {
+          if ((encoding == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 15\n");
+          else
+            fprintf(stderr, "reached bug index 15\n");
+        }
+        if ((!FIXREVERTER[15] && (encoding == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             encoding = PyUnicode_GetDefaultEncoding();
+            #ifdef FRCOV
+            }
+            #endif
 
         /* Get output buffer parameter:
            's' (recode all objects via Unicode) or
@@ -1001,9 +1185,24 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
                 arg, msgbuf, bufsize);
         buffer = (char **)va_arg(*p_va, char **);
         format++;
-        if (buffer == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[16]) {
+          if ((buffer == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 16\n");
+          else
+            fprintf(stderr, "reached bug index 16\n");
+        }
+        if ((!FIXREVERTER[16] && (buffer == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return converterr("(buffer is NULL)",
                               arg, msgbuf, bufsize);
+                              #ifdef FRCOV
+                              }
+                              #endif
 
         /* Encode object */
         if (!recode_strings &&
@@ -1023,14 +1222,44 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
             s = PyUnicode_AsEncodedString(arg,
                                           encoding,
                                           NULL);
-            if (s == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[17]) {
+              if ((s == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 17\n");
+              else
+                fprintf(stderr, "reached bug index 17\n");
+            }
+            if ((!FIXREVERTER[17] && (s == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 return converterr("(encoding failed)",
                                   arg, msgbuf, bufsize);
+                                  #ifdef FRCOV
+                                  }
+                                  #endif
             assert(PyBytes_Check(s));
             size = PyBytes_GET_SIZE(s);
             ptr = PyBytes_AS_STRING(s);
-            if (ptr == NULL)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[18]) {
+              if ((ptr == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 18\n");
+              else
+                fprintf(stderr, "reached bug index 18\n");
+            }
+            if ((!FIXREVERTER[18] && (ptr == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            )
                 ptr = "";
+                #ifdef FRCOV
+                }
+                #endif
         }
         else {
             return converterr(
@@ -1064,12 +1293,27 @@ convertsimple(PyObject *arg, const char **p_format, va_list *p_va, int flags,
             Py_ssize_t *psize = va_arg(*p_va, Py_ssize_t*);
 
             format++;
-            if (psize == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[19]) {
+              if ((psize == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 19\n");
+              else
+                fprintf(stderr, "reached bug index 19\n");
+            }
+            if ((!FIXREVERTER[19] && (psize == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 Py_DECREF(s);
                 return converterr(
                     "(buffer_len is NULL)",
                     arg, msgbuf, bufsize);
             }
+            #ifdef FRCOV
+            }
+            #endif
             if (*buffer == NULL) {
                 *buffer = PyMem_NEW(char, size + 1);
                 if (*buffer == NULL) {
diff --git a/Python/hashtable.c b/Python/hashtable.c
index faf68fe4ff0..8150a082a74 100644
--- a/Python/hashtable.c
+++ b/Python/hashtable.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* The implementation of the hash table (_Py_hashtable_t) is based on the
    cfuhash project:
    http://sourceforge.net/projects/libcfu/
@@ -227,10 +231,25 @@ _Py_hashtable_set(_Py_hashtable_t *ht, const void *key, void *value)
 #endif
 
     entry = ht->alloc.malloc(sizeof(_Py_hashtable_entry_t));
-    if (entry == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7345]) {
+      if ((entry == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7345\n");
+      else
+        fprintf(stderr, "reached bug index 7345\n");
+    }
+    if ((!FIXREVERTER[7345] && (entry == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* memory allocation failed */
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     entry->key_hash = ht->hash_func(key);
     entry->key = (void *)key;
@@ -287,16 +306,46 @@ static int
 hashtable_rehash(_Py_hashtable_t *ht)
 {
     size_t new_size = round_size((size_t)(ht->nentries * HASHTABLE_REHASH_FACTOR));
-    if (new_size == ht->nbuckets) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7346]) {
+      if ((new_size == ht -> nbuckets ) && !(0))
+        fprintf(stderr, "triggered bug index 7346\n");
+      else
+        fprintf(stderr, "reached bug index 7346\n");
+    }
+    if ((!FIXREVERTER[7346] && (new_size == ht -> nbuckets ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     size_t buckets_size = new_size * sizeof(ht->buckets[0]);
     _Py_slist_t *new_buckets = ht->alloc.malloc(buckets_size);
-    if (new_buckets == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7347]) {
+      if ((new_buckets == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7347\n");
+      else
+        fprintf(stderr, "reached bug index 7347\n");
+    }
+    if ((!FIXREVERTER[7347] && (new_buckets == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* memory allocation failed */
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     memset(new_buckets, 0, buckets_size);
 
     for (size_t bucket = 0; bucket < ht->nbuckets; bucket++) {
diff --git a/Python/import.c b/Python/import.c
index 20ad1002004..09331eee20a 100644
--- a/Python/import.c
+++ b/Python/import.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Module definition and import implementation */
 
 #include "Python.h"
@@ -157,7 +161,19 @@ get_modules_dict(PyThreadState *tstate, bool fatal)
      * unlikely, especially since we can rely on a global lock
      * (i.e. the GIL) for thread-safety. */
     PyObject *modules = MODULES(tstate->interp);
-    if (modules == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[92]) {
+      if ((modules == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 92\n");
+      else
+        fprintf(stderr, "reached bug index 92\n");
+    }
+    if ((!FIXREVERTER[92] && (modules == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (fatal) {
             Py_FatalError("interpreter has no modules dictionary");
         }
@@ -165,6 +181,9 @@ get_modules_dict(PyThreadState *tstate, bool fatal)
                          "unable to get sys.modules");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return modules;
 }
 
@@ -195,9 +214,24 @@ static PyObject *
 import_get_module(PyThreadState *tstate, PyObject *name)
 {
     PyObject *modules = get_modules_dict(tstate, false);
-    if (modules == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[93]) {
+      if ((modules == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 93\n");
+      else
+        fprintf(stderr, "reached bug index 93\n");
+    }
+    if ((!FIXREVERTER[93] && (modules == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *m;
     Py_INCREF(modules);
@@ -227,9 +261,24 @@ import_ensure_initialized(PyInterpreterState *interp, PyObject *mod, PyObject *n
     /* Wait until module is done importing. */
     PyObject *value = PyObject_CallMethodOneArg(
         IMPORTLIB(interp), &_Py_ID(_lock_unlock_module), name);
-    if (value == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[95]) {
+      if ((value == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 95\n");
+      else
+        fprintf(stderr, "reached bug index 95\n");
+    }
+    if ((!FIXREVERTER[95] && (value == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_DECREF(value);
     return 0;
 }
@@ -3353,8 +3402,23 @@ PyImport_ImportModule(const char *name)
     PyObject *result;
 
     pname = PyUnicode_FromString(name);
-    if (pname == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[188]) {
+      if ((pname == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 188\n");
+      else
+        fprintf(stderr, "reached bug index 188\n");
+    }
+    if ((!FIXREVERTER[188] && (pname == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     result = PyImport_Import(pname);
     Py_DECREF(pname);
     return result;
@@ -3462,10 +3526,25 @@ resolve_name(PyThreadState *tstate, PyObject *name, PyObject *globals, int level
     PyObject *base;
     int level_up;
 
-    if (globals == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[189]) {
+      if ((globals == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 189\n");
+      else
+        fprintf(stderr, "reached bug index 189\n");
+    }
+    if ((!FIXREVERTER[189] && (globals == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyErr_SetString(tstate, PyExc_KeyError, "'__name__' not in globals");
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyDict_Check(globals)) {
         _PyErr_SetString(tstate, PyExc_TypeError, "globals must be a dict");
         goto error;
@@ -3490,9 +3569,24 @@ resolve_name(PyThreadState *tstate, PyObject *name, PyObject *globals, int level
         else if (spec != NULL && spec != Py_None) {
             int equal;
             PyObject *parent = PyObject_GetAttr(spec, &_Py_ID(parent));
-            if (parent == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[190]) {
+              if ((parent == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 190\n");
+              else
+                fprintf(stderr, "reached bug index 190\n");
+            }
+            if ((!FIXREVERTER[190] && (parent == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto error;
             }
+            #ifdef FRCOV
+            }
+            #endif
 
             equal = PyObject_RichCompareBool(package, parent, Py_EQ);
             Py_DECREF(parent);
@@ -3528,11 +3622,26 @@ resolve_name(PyThreadState *tstate, PyObject *name, PyObject *globals, int level
         if (PyDict_GetItemRef(globals, &_Py_ID(__name__), &package) < 0) {
             goto error;
         }
-        if (package == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[191]) {
+          if ((package == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 191\n");
+          else
+            fprintf(stderr, "reached bug index 191\n");
+        }
+        if ((!FIXREVERTER[191] && (package == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             _PyErr_SetString(tstate, PyExc_KeyError,
                              "'__name__' not in globals");
             goto error;
         }
+        #ifdef FRCOV
+        }
+        #endif
 
         if (!PyUnicode_Check(package)) {
             _PyErr_SetString(tstate, PyExc_TypeError,
@@ -3556,17 +3665,47 @@ resolve_name(PyThreadState *tstate, PyObject *name, PyObject *globals, int level
                 goto no_parent_error;
             }
             PyObject *substr = PyUnicode_Substring(package, 0, dot);
-            if (substr == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[193]) {
+              if ((substr == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 193\n");
+              else
+                fprintf(stderr, "reached bug index 193\n");
+            }
+            if ((!FIXREVERTER[193] && (substr == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 goto error;
             }
+            #ifdef FRCOV
+            }
+            #endif
             Py_SETREF(package, substr);
         }
     }
 
     last_dot = PyUnicode_GET_LENGTH(package);
-    if (last_dot == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[194]) {
+      if ((last_dot == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 194\n");
+      else
+        fprintf(stderr, "reached bug index 194\n");
+    }
+    if ((!FIXREVERTER[194] && (last_dot == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto no_parent_error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     for (level_up = 1; level_up < level; level_up += 1) {
         last_dot = PyUnicode_FindChar(package, '.', 0, last_dot, -1);
@@ -3687,10 +3826,25 @@ PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals,
     PyInterpreterState *interp = tstate->interp;
     int has_from;
 
-    if (name == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[195]) {
+      if ((name == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 195\n");
+      else
+        fprintf(stderr, "reached bug index 195\n");
+    }
+    if ((!FIXREVERTER[195] && (name == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyErr_SetString(tstate, PyExc_ValueError, "Empty module name");
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* The below code is importlib.__import__() & _gcd_import(), ported to C
        for added performance. */
@@ -3707,8 +3861,23 @@ PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals,
 
     if (level > 0) {
         abs_name = resolve_name(tstate, name, globals, level);
-        if (abs_name == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[197]) {
+          if ((abs_name == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 197\n");
+          else
+            fprintf(stderr, "reached bug index 197\n");
+        }
+        if ((!FIXREVERTER[197] && (abs_name == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto error;
+            #ifdef FRCOV
+            }
+            #endif
     }
     else {  /* level == 0 */
         if (PyUnicode_GET_LENGTH(name) == 0) {
@@ -3731,9 +3900,24 @@ PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals,
     else {
         Py_XDECREF(mod);
         mod = import_find_and_load(tstate, abs_name);
-        if (mod == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[198]) {
+          if ((mod == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 198\n");
+          else
+            fprintf(stderr, "reached bug index 198\n");
+        }
+        if ((!FIXREVERTER[198] && (mod == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto error;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     has_from = 0;
@@ -3760,9 +3944,24 @@ PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals,
 
             if (level == 0) {
                 PyObject *front = PyUnicode_Substring(name, 0, dot);
-                if (front == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[200]) {
+                  if ((front == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 200\n");
+                  else
+                    fprintf(stderr, "reached bug index 200\n");
+                }
+                if ((!FIXREVERTER[200] && (front == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     goto error;
                 }
+                #ifdef FRCOV
+                }
+                #endif
 
                 final_mod = PyImport_ImportModuleLevelObject(front, NULL, NULL, NULL, 0);
                 Py_DECREF(front);
@@ -3772,13 +3971,40 @@ PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals,
                 Py_ssize_t abs_name_len = PyUnicode_GET_LENGTH(abs_name);
                 PyObject *to_return = PyUnicode_Substring(abs_name, 0,
                                                         abs_name_len - cut_off);
-                if (to_return == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[201]) {
+                  if ((to_return == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 201\n");
+                  else
+                    fprintf(stderr, "reached bug index 201\n");
+                }
+                if ((!FIXREVERTER[201] && (to_return == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     goto error;
                 }
+                #ifdef FRCOV
+                }
+                #endif
 
                 final_mod = import_get_module(tstate, to_return);
                 Py_DECREF(to_return);
-                if (final_mod == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[202]) {
+                  if ((final_mod == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 202\n");
+                  else
+                    fprintf(stderr, "reached bug index 202\n");
+                }
+                if ((!FIXREVERTER[202] && (final_mod == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     if (!_PyErr_Occurred(tstate)) {
                         _PyErr_Format(tstate, PyExc_KeyError,
                                       "%R not in sys.modules as expected",
@@ -3786,6 +4012,9 @@ PyImport_ImportModuleLevelObject(PyObject *name, PyObject *globals,
                     }
                     goto error;
                 }
+                #ifdef FRCOV
+                }
+                #endif
             }
         }
         else {
@@ -3823,8 +4052,23 @@ PyImport_ImportModuleLevel(const char *name, PyObject *globals, PyObject *locals
 {
     PyObject *nameobj, *mod;
     nameobj = PyUnicode_FromString(name);
-    if (nameobj == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[204]) {
+      if ((nameobj == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 204\n");
+      else
+        fprintf(stderr, "reached bug index 204\n");
+    }
+    if ((!FIXREVERTER[204] && (nameobj == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     mod = PyImport_ImportModuleLevelObject(nameobj, globals, locals,
                                            fromlist, level);
     Py_DECREF(nameobj);
@@ -3876,28 +4120,88 @@ PyImport_Import(PyObject *module_name)
     PyObject *r = NULL;
 
     PyObject *from_list = PyList_New(0);
-    if (from_list == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[206]) {
+      if ((from_list == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 206\n");
+      else
+        fprintf(stderr, "reached bug index 206\n");
+    }
+    if ((!FIXREVERTER[206] && (from_list == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto err;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Get the builtins from current globals */
     globals = PyEval_GetGlobals();
     if (globals != NULL) {
         Py_INCREF(globals);
         builtins = PyObject_GetItem(globals, &_Py_ID(__builtins__));
-        if (builtins == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[207]) {
+          if ((builtins == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 207\n");
+          else
+            fprintf(stderr, "reached bug index 207\n");
+        }
+        if ((!FIXREVERTER[207] && (builtins == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto err;
+            #ifdef FRCOV
+            }
+            #endif
     }
     else {
         /* No globals -- use standard builtins, and fake globals */
         builtins = PyImport_ImportModuleLevel("builtins",
                                               NULL, NULL, NULL, 0);
-        if (builtins == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[208]) {
+          if ((builtins == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 208\n");
+          else
+            fprintf(stderr, "reached bug index 208\n");
+        }
+        if ((!FIXREVERTER[208] && (builtins == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             goto err;
         }
+        #ifdef FRCOV
+        }
+        #endif
         globals = Py_BuildValue("{OO}", &_Py_ID(__builtins__), builtins);
-        if (globals == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[209]) {
+          if ((globals == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 209\n");
+          else
+            fprintf(stderr, "reached bug index 209\n");
+        }
+        if ((!FIXREVERTER[209] && (globals == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto err;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
     /* Get the __import__ function from the builtins */
@@ -3909,16 +4213,46 @@ PyImport_Import(PyObject *module_name)
     }
     else
         import = PyObject_GetAttr(builtins, &_Py_ID(__import__));
-    if (import == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[210]) {
+      if ((import == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 210\n");
+      else
+        fprintf(stderr, "reached bug index 210\n");
+    }
+    if ((!FIXREVERTER[210] && (import == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto err;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Call the __import__ function with the proper argument list
        Always use absolute import here.
        Calling for side-effect of import. */
     r = PyObject_CallFunction(import, "OOOOi", module_name, globals,
                               globals, from_list, 0, NULL);
-    if (r == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[211]) {
+      if ((r == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 211\n");
+      else
+        fprintf(stderr, "reached bug index 211\n");
+    }
+    if ((!FIXREVERTER[211] && (r == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto err;
+        #ifdef FRCOV
+        }
+        #endif
     Py_DECREF(r);
 
     r = import_get_module(tstate, module_name);
@@ -4147,9 +4481,24 @@ PyObject *
 _PyImport_GetModuleAttr(PyObject *modname, PyObject *attrname)
 {
     PyObject *mod = PyImport_Import(modname);
-    if (mod == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[214]) {
+      if ((mod == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 214\n");
+      else
+        fprintf(stderr, "reached bug index 214\n");
+    }
+    if ((!FIXREVERTER[214] && (mod == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *result = PyObject_GetAttr(mod, attrname);
     Py_DECREF(mod);
     return result;
@@ -4159,14 +4508,44 @@ PyObject *
 _PyImport_GetModuleAttrString(const char *modname, const char *attrname)
 {
     PyObject *pmodname = PyUnicode_FromString(modname);
-    if (pmodname == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[215]) {
+      if ((pmodname == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 215\n");
+      else
+        fprintf(stderr, "reached bug index 215\n");
+    }
+    if ((!FIXREVERTER[215] && (pmodname == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *pattrname = PyUnicode_FromString(attrname);
-    if (pattrname == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[216]) {
+      if ((pattrname == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 216\n");
+      else
+        fprintf(stderr, "reached bug index 216\n");
+    }
+    if ((!FIXREVERTER[216] && (pattrname == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(pmodname);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *result = _PyImport_GetModuleAttr(pmodname, pattrname);
     Py_DECREF(pattrname);
     Py_DECREF(pmodname);
diff --git a/Python/instruction_sequence.c b/Python/instruction_sequence.c
index a3f85f754d7..3f695eb9ce2 100644
--- a/Python/instruction_sequence.c
+++ b/Python/instruction_sequence.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /*
  * This file implements a data structure representing a sequence of
  * instructions, which is used by different parts of the compilation
@@ -75,10 +79,25 @@ _PyInstructionSequence_UseLabel(instr_sequence *seq, int lbl)
 int
 _PyInstructionSequence_ApplyLabelMap(instr_sequence *instrs)
 {
-    if (instrs->s_labelmap == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7462]) {
+      if ((instrs -> s_labelmap == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7462\n");
+      else
+        fprintf(stderr, "reached bug index 7462\n");
+    }
+    if ((!FIXREVERTER[7462] && (instrs -> s_labelmap == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* Already applied - nothing to do */
         return SUCCESS;
     }
+    #ifdef FRCOV
+    }
+    #endif
     /* Replace labels by offsets in the code */
     for (int i=0; i < instrs->s_used; i++) {
         instruction *instr = &instrs->s_instrs[i];
@@ -148,9 +167,24 @@ _PyInstructionSequence_AddNested(instr_sequence *seq, instr_sequence *nested)
 {
     if (seq->s_nested == NULL) {
         seq->s_nested = PyList_New(0);
-        if (seq->s_nested == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[7463]) {
+          if ((seq -> s_nested == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 7463\n");
+          else
+            fprintf(stderr, "reached bug index 7463\n");
+        }
+        if ((!FIXREVERTER[7463] && (seq -> s_nested == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             return ERROR;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
     if (PyList_Append(seq->s_nested, (PyObject*)nested) < 0) {
         return ERROR;
@@ -179,9 +213,24 @@ inst_seq_create(void)
 {
     _PyInstructionSequence *seq;
     seq = PyObject_GC_New(_PyInstructionSequence, &_PyInstructionSequence_Type);
-    if (seq == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7464]) {
+      if ((seq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7464\n");
+      else
+        fprintf(stderr, "reached bug index 7464\n");
+    }
+    if ((!FIXREVERTER[7464] && (seq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     seq->s_instrs = NULL;
     seq->s_allocated = 0;
     seq->s_used = 0;
@@ -198,9 +247,24 @@ PyObject*
 _PyInstructionSequence_New(void)
 {
     _PyInstructionSequence *seq = inst_seq_create();
-    if (seq == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7465]) {
+      if ((seq == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7465\n");
+      else
+        fprintf(stderr, "reached bug index 7465\n");
+    }
+    if ((!FIXREVERTER[7465] && (seq == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     return (PyObject*)seq;
 }
 
diff --git a/Python/modsupport.c b/Python/modsupport.c
index 0fb7783345c..329925694c5 100644
--- a/Python/modsupport.c
+++ b/Python/modsupport.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Module support implementation */
 
@@ -540,25 +544,70 @@ _Py_VaBuildStack(PyObject **small_stack, Py_ssize_t small_stack_len,
     int res;
 
     n = countformat(format, '\0');
-    if (n < 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3800]) {
+      if ((n < 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3800\n");
+      else
+        fprintf(stderr, "reached bug index 3800\n");
+    }
+    if ((!FIXREVERTER[3800] && (n < 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *p_nargs = 0;
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
-    if (n == 0) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3801]) {
+      if ((n == 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3801\n");
+      else
+        fprintf(stderr, "reached bug index 3801\n");
+    }
+    if ((!FIXREVERTER[3801] && (n == 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *p_nargs = 0;
         return small_stack;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     if (n <= small_stack_len) {
         stack = small_stack;
     }
     else {
         stack = PyMem_Malloc(n * sizeof(stack[0]));
-        if (stack == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[3802]) {
+          if ((stack == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 3802\n");
+          else
+            fprintf(stderr, "reached bug index 3802\n");
+        }
+        if ((!FIXREVERTER[3802] && (stack == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_NoMemory();
             return NULL;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     va_copy(lva, va);
diff --git a/Python/mysnprintf.c b/Python/mysnprintf.c
index 2a505d14f82..1279b9bd271 100644
--- a/Python/mysnprintf.c
+++ b/Python/mysnprintf.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 
 /* snprintf() and vsnprintf() wrappers.
@@ -61,10 +65,25 @@ PyOS_vsnprintf(char *str, size_t size, const char  *format, va_list va)
     /* We take a size_t as input but return an int.  Sanity check
      * our input so that it won't cause an overflow in the
      * vsnprintf return value.  */
-    if (size > INT_MAX - 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4879]) {
+      if ((size > 2147483647 - 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 4879\n");
+      else
+        fprintf(stderr, "reached bug index 4879\n");
+    }
+    if ((!FIXREVERTER[4879] && (size > 2147483647 - 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         len = -666;
         goto Done;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
 #if defined(_MSC_VER)
     len = _vsnprintf(str, size, format, va);
diff --git a/Python/mystrtoul.c b/Python/mystrtoul.c
index fcd3e27f17f..5280f5006f1 100644
--- a/Python/mystrtoul.c
+++ b/Python/mystrtoul.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 // strtol() and strtoul(), renamed to avoid conflicts.
 //
 // API:
@@ -201,11 +205,26 @@ PyOS_strtoul(const char *str, char **ptr, int base)
     }
 
     /* catch silly bases */
-    if (base < 2 || base > 36) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[227]) {
+      if ((base < 2 || base > 36 ) && !(0))
+        fprintf(stderr, "triggered bug index 227\n");
+      else
+        fprintf(stderr, "reached bug index 227\n");
+    }
+    if ((!FIXREVERTER[227] && (base < 2 || base > 36 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (ptr)
             *ptr = (char *)str;
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* skip leading zeroes */
     while (*str == '0')
@@ -233,8 +252,23 @@ PyOS_strtoul(const char *str, char **ptr, int base)
 
             /* check overflow from the digit's value */
             temp_result = result + c;
-            if (temp_result < result)
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[229]) {
+              if ((temp_result < result ) && !(0))
+                fprintf(stderr, "triggered bug index 229\n");
+              else
+                fprintf(stderr, "reached bug index 229\n");
+            }
+            if ((!FIXREVERTER[229] && (temp_result < result ))
+            #else
+            if (0
+            #endif
+            )
                 goto overflowed;
+                #ifdef FRCOV
+                }
+                #endif
 
             result = temp_result;
         }
diff --git a/Python/pylifecycle.c b/Python/pylifecycle.c
index 39eaa86098b..72ee8900193 100644
--- a/Python/pylifecycle.c
+++ b/Python/pylifecycle.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 /* Python interpreter top-level routines, including init/exit */
 
 #include "Python.h"
@@ -1566,10 +1570,25 @@ finalize_remove_modules(PyObject *modules, int verbose)
             PyObject *key;
             while ((key = PyIter_Next(iterator))) {
                 PyObject *value = PyObject_GetItem(modules, key);
-                if (value == NULL) {
+                
+                #ifdef FRCOV
+                {if (FIXREVERTER[1436]) {
+                  if ((value == (void *) 0 ) && !(0))
+                    fprintf(stderr, "triggered bug index 1436\n");
+                  else
+                    fprintf(stderr, "reached bug index 1436\n");
+                }
+                if ((!FIXREVERTER[1436] && (value == (void *) 0 ))
+                #else
+                if (0
+                #endif
+                ) {
                     PyErr_FormatUnraisable("Exception ignored on removing modules");
                     continue;
                 }
+                #ifdef FRCOV
+                }
+                #endif
                 CLEAR_MODULE(key, value);
                 Py_DECREF(value);
                 Py_DECREF(key);
@@ -1626,9 +1645,24 @@ finalize_modules_clear_weaklist(PyInterpreterState *interp,
         PyObject *tup = PyList_GET_ITEM(weaklist, i);
         PyObject *name = PyTuple_GET_ITEM(tup, 0);
         PyObject *mod = _PyWeakref_GET_REF(PyTuple_GET_ITEM(tup, 1));
-        if (mod == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[1437]) {
+          if ((mod == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 1437\n");
+          else
+            fprintf(stderr, "reached bug index 1437\n");
+        }
+        if ((!FIXREVERTER[1437] && (mod == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         assert(PyModule_Check(mod));
         PyObject *dict = _PyModule_GetDict(mod);  // borrowed reference
         if (dict == interp->builtins || dict == interp->sysdict) {
@@ -1679,10 +1713,25 @@ finalize_modules(PyThreadState *tstate)
     PyDict_Unwatch(0, interp->builtins);
 
     PyObject *modules = _PyImport_GetModules(interp);
-    if (modules == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1438]) {
+      if ((modules == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1438\n");
+      else
+        fprintf(stderr, "reached bug index 1438\n");
+    }
+    if ((!FIXREVERTER[1438] && (modules == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         // Already done
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int verbose = _PyInterpreterState_GetConfig(interp)->verbose;
 
     // Delete some special builtins._ and sys attributes first.  These are
@@ -1762,10 +1811,25 @@ file_is_closed(PyObject *fobj)
 {
     int r;
     PyObject *tmp = PyObject_GetAttrString(fobj, "closed");
-    if (tmp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1439]) {
+      if ((tmp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1439\n");
+      else
+        fprintf(stderr, "reached bug index 1439\n");
+    }
+    if ((!FIXREVERTER[1439] && (tmp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Clear();
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     r = PyObject_IsTrue(tmp);
     Py_DECREF(tmp);
     if (r < 0)
@@ -2438,9 +2502,24 @@ finalize_subinterpreters(void)
     HEAD_UNLOCK(runtime);
 
     /* Bail out if there are no subinterpreters left. */
-    if (interp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1442]) {
+      if ((interp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1442\n");
+      else
+        fprintf(stderr, "reached bug index 1442\n");
+    }
+    if ((!FIXREVERTER[1442] && (interp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     /* Warn the user if they forgot to clean up subinterpreters. */
     (void)PyErr_WarnEx(
@@ -2926,10 +3005,25 @@ static int
 _Py_FatalError_PrintExc(PyThreadState *tstate)
 {
     PyObject *exc = _PyErr_GetRaisedException(tstate);
-    if (exc == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1457]) {
+      if ((exc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1457\n");
+      else
+        fprintf(stderr, "reached bug index 1457\n");
+    }
+    if ((!FIXREVERTER[1457] && (exc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         /* No current exception */
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *ferr = _PySys_GetAttr(tstate, &_Py_ID(stderr));
     if (ferr == NULL || ferr == Py_None) {
@@ -3069,9 +3163,24 @@ release_dict_lock_for_dump(PyObject *obj)
 void
 _Py_DumpExtensionModules(int fd, PyInterpreterState *interp)
 {
-    if (interp == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1458]) {
+      if ((interp == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1458\n");
+      else
+        fprintf(stderr, "reached bug index 1458\n");
+    }
+    if ((!FIXREVERTER[1458] && (interp == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *modules = _PyImport_GetModules(interp);
     if (modules == NULL || !PyDict_Check(modules)) {
         return;
@@ -3328,13 +3437,28 @@ wait_for_thread_shutdown(PyThreadState *tstate)
 {
     PyObject *result;
     PyObject *threading = PyImport_GetModule(&_Py_ID(threading));
-    if (threading == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1459]) {
+      if ((threading == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1459\n");
+      else
+        fprintf(stderr, "reached bug index 1459\n");
+    }
+    if ((!FIXREVERTER[1459] && (threading == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         if (_PyErr_Occurred(tstate)) {
             PyErr_FormatUnraisable("Exception ignored on threading shutdown");
         }
         /* else: threading not imported */
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     result = PyObject_CallMethodNoArgs(threading, &_Py_ID(_shutdown));
     if (result == NULL) {
         PyErr_FormatUnraisable("Exception ignored on threading shutdown");
diff --git a/Python/pystate.c b/Python/pystate.c
index 602b13e18c7..7e34be6c328 100644
--- a/Python/pystate.c
+++ b/Python/pystate.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Thread and interpreter state structures and their interfaces */
 
@@ -1536,9 +1540,24 @@ new_threadstate(PyInterpreterState *interp, int whence)
     // taking the interpreters lock.  See GH-96071.
     _PyThreadStateImpl *new_tstate = alloc_threadstate();
     int used_newtstate;
-    if (new_tstate == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3341]) {
+      if ((new_tstate == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3341\n");
+      else
+        fprintf(stderr, "reached bug index 3341\n");
+    }
+    if ((!FIXREVERTER[3341] && (new_tstate == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 #ifdef Py_GIL_DISABLED
     Py_ssize_t qsbr_idx = _Py_qsbr_reserve(interp);
     if (qsbr_idx < 0) {
@@ -1968,9 +1987,24 @@ PyThreadState_GetFrame(PyThreadState *tstate)
 {
     assert(tstate != NULL);
     _PyInterpreterFrame *f = _PyThreadState_GetFrame(tstate);
-    if (f == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[3343]) {
+      if ((f == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 3343\n");
+      else
+        fprintf(stderr, "reached bug index 3343\n");
+    }
+    if ((!FIXREVERTER[3343] && (f == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyFrameObject *frame = _PyFrame_GetFrameObject(f);
     if (frame == NULL) {
         PyErr_Clear();
diff --git a/Python/pythonrun.c b/Python/pythonrun.c
index ce7f194e929..0cdd4ec6168 100644
--- a/Python/pythonrun.c
+++ b/Python/pythonrun.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Top level execution of Python code (including in __main__) */
 
@@ -551,9 +555,24 @@ _Py_HandleSystemExit(int *exitcode_p)
     int exitcode = 0;
 
     PyObject *exc = PyErr_GetRaisedException();
-    if (exc == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1971]) {
+      if ((exc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1971\n");
+      else
+        fprintf(stderr, "reached bug index 1971\n");
+    }
+    if ((!FIXREVERTER[1971] && (exc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto done;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(PyExceptionInstance_Check(exc));
 
     /* The error code should be in the `code' attribute. */
@@ -613,9 +632,24 @@ _PyErr_PrintEx(PyThreadState *tstate, int set_sys_last_vars)
     handle_system_exit();
 
     PyObject *exc = _PyErr_GetRaisedException(tstate);
-    if (exc == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1972]) {
+      if ((exc == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1972\n");
+      else
+        fprintf(stderr, "reached bug index 1972\n");
+    }
+    if ((!FIXREVERTER[1972] && (exc == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto done;
     }
+    #ifdef FRCOV
+    }
+    #endif
     assert(PyExceptionInstance_Check(exc));
     typ = Py_NewRef(Py_TYPE(exc));
     tb = PyException_GetTraceback(exc);
@@ -770,9 +804,24 @@ print_exception_file_and_line(struct exception_print_context *ctx,
     PyObject *line = PyUnicode_FromFormat("  File \"%S\", line %zd\n",
                                           filename, lineno);
     Py_DECREF(filename);
-    if (line == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1974]) {
+      if ((line == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1974\n");
+      else
+        fprintf(stderr, "reached bug index 1974\n");
+    }
+    if ((!FIXREVERTER[1974] && (line == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto error;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (PyFile_WriteObject(line, f, Py_PRINT_RAW) < 0) {
         goto error;
     }
@@ -958,10 +1007,25 @@ print_exception_seen_lookup(struct exception_print_context *ctx,
                             PyObject *value)
 {
     PyObject *check_id = PyLong_FromVoidPtr(value);
-    if (check_id == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1979]) {
+      if ((check_id == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1979\n");
+      else
+        fprintf(stderr, "reached bug index 1979\n");
+    }
+    if ((!FIXREVERTER[1979] && (check_id == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Clear();
         return true;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     int in_seen = PySet_Contains(ctx->seen, check_id);
     Py_DECREF(check_id);
@@ -1064,9 +1128,24 @@ _PyErr_Display(PyObject *file, PyObject *unused, PyObject *value, PyObject *tb)
     // Try first with the stdlib traceback module
     PyObject *traceback_module = PyImport_ImportModule("traceback");
 
-    if (traceback_module == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1981]) {
+      if ((traceback_module == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1981\n");
+      else
+        fprintf(stderr, "reached bug index 1981\n");
+    }
+    if ((!FIXREVERTER[1981] && (traceback_module == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         goto fallback;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *print_exception_fn = PyObject_GetAttrString(traceback_module, "_print_exception_bltin");
 
@@ -1122,11 +1201,26 @@ PyErr_Display(PyObject *unused, PyObject *value, PyObject *tb)
 {
     PyThreadState *tstate = _PyThreadState_GET();
     PyObject *file = _PySys_GetAttr(tstate, &_Py_ID(stderr));
-    if (file == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1982]) {
+      if ((file == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1982\n");
+      else
+        fprintf(stderr, "reached bug index 1982\n");
+    }
+    if ((!FIXREVERTER[1982] && (file == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyObject_Dump(value);
         fprintf(stderr, "lost sys.stderr\n");
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (file == Py_None) {
         return;
     }
@@ -1429,14 +1523,44 @@ Py_CompileStringObject(const char *str, PyObject *filename, int start,
     PyCodeObject *co;
     mod_ty mod;
     PyArena *arena = _PyArena_New();
-    if (arena == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1990]) {
+      if ((arena == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1990\n");
+      else
+        fprintf(stderr, "reached bug index 1990\n");
+    }
+    if ((!FIXREVERTER[1990] && (arena == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
 
     mod = _PyParser_ASTFromString(str, filename, start, flags, arena);
-    if (mod == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1991]) {
+      if ((mod == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1991\n");
+      else
+        fprintf(stderr, "reached bug index 1991\n");
+    }
+    if ((!FIXREVERTER[1991] && (mod == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PyArena_Free(arena);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (flags && (flags->cf_flags & PyCF_ONLY_AST)) {
         if ((flags->cf_flags & PyCF_OPTIMIZED_AST) == PyCF_OPTIMIZED_AST) {
             if (_PyCompile_AstOptimize(mod, filename, flags, optimize, arena) < 0) {
@@ -1458,8 +1582,23 @@ Py_CompileStringExFlags(const char *str, const char *filename_str, int start,
 {
     PyObject *filename, *co;
     filename = PyUnicode_DecodeFSDefault(filename_str);
-    if (filename == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1992]) {
+      if ((filename == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1992\n");
+      else
+        fprintf(stderr, "reached bug index 1992\n");
+    }
+    if ((!FIXREVERTER[1992] && (filename == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     co = Py_CompileStringObject(str, filename, start, flags, optimize);
     Py_DECREF(filename);
     return co;
diff --git a/Python/symtable.c b/Python/symtable.c
index 2e56ea6e830..175778d0f14 100644
--- a/Python/symtable.c
+++ b/Python/symtable.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_ast.h"           // stmt_ty
 #include "pycore_parser.h"        // _PyParser_ASTFromString()
@@ -86,13 +90,43 @@ ste_new(struct symtable *st, identifier name, _Py_block_ty block,
     PyObject *k = NULL;
 
     k = PyLong_FromVoidPtr(key);
-    if (k == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[552]) {
+      if ((k == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 552\n");
+      else
+        fprintf(stderr, "reached bug index 552\n");
+    }
+    if ((!FIXREVERTER[552] && (k == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto fail;
+        #ifdef FRCOV
+        }
+        #endif
     ste = PyObject_New(PySTEntryObject, &PySTEntry_Type);
-    if (ste == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[553]) {
+      if ((ste == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 553\n");
+      else
+        fprintf(stderr, "reached bug index 553\n");
+    }
+    if ((!FIXREVERTER[553] && (ste == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(k);
         goto fail;
     }
+    #ifdef FRCOV
+    }
+    #endif
     ste->ste_table = st;
     ste->ste_id = k; /* ste owns reference to k */
 
@@ -140,10 +174,23 @@ ste_new(struct symtable *st, identifier name, _Py_block_ty block,
     ste->ste_symbols = PyDict_New();
     ste->ste_varnames = PyList_New(0);
     ste->ste_children = PyList_New(0);
-    if (ste->ste_symbols == NULL
-        || ste->ste_varnames == NULL
-        || ste->ste_children == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[554]) {
+      if ((ste -> ste_symbols == (void *) 0 || ste -> ste_varnames == (void *) 0 || ste -> ste_children == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 554\n");
+      else
+        fprintf(stderr, "reached bug index 554\n");
+    }
+    if ((!FIXREVERTER[554] && (ste -> ste_symbols == (void *) 0 || ste -> ste_varnames == (void *) 0 || ste -> ste_children == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto fail;
+        #ifdef FRCOV
+        }
+        #endif
 
     if (PyDict_SetItem(st->st_blocks, ste->ste_id, (PyObject *)ste) < 0)
         goto fail;
@@ -373,10 +420,25 @@ symtable_new(void)
     struct symtable *st;
 
     st = (struct symtable *)PyMem_Malloc(sizeof(struct symtable));
-    if (st == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[555]) {
+      if ((st == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 555\n");
+      else
+        fprintf(stderr, "reached bug index 555\n");
+    }
+    if ((!FIXREVERTER[555] && (st == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_NoMemory();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     st->st_filename = NULL;
     st->st_blocks = NULL;
@@ -402,12 +464,42 @@ _PySymtable_Build(mod_ty mod, PyObject *filename, _PyFutureFeatures *future)
     PyThreadState *tstate;
     int starting_recursion_depth;
 
-    if (st == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[556]) {
+      if ((st == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 556\n");
+      else
+        fprintf(stderr, "reached bug index 556\n");
+    }
+    if ((!FIXREVERTER[556] && (st == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
-    if (filename == NULL) {
+        #ifdef FRCOV
+        }
+        #endif
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[557]) {
+      if ((filename == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 557\n");
+      else
+        fprintf(stderr, "reached bug index 557\n");
+    }
+    if ((!FIXREVERTER[557] && (filename == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         _PySymtable_Free(st);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     st->st_filename = Py_NewRef(filename);
     st->st_future = future;
 
@@ -459,13 +551,28 @@ _PySymtable_Build(mod_ty mod, PyObject *filename, _PyFutureFeatures *future)
         return NULL;
     }
     /* Check that the recursion depth counting balanced correctly */
-    if (st->recursion_depth != starting_recursion_depth) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[558]) {
+      if ((st -> recursion_depth != starting_recursion_depth ) && !(0))
+        fprintf(stderr, "triggered bug index 558\n");
+      else
+        fprintf(stderr, "reached bug index 558\n");
+    }
+    if ((!FIXREVERTER[558] && (st -> recursion_depth != starting_recursion_depth ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Format(PyExc_SystemError,
             "symtable analysis recursion depth mismatch (before=%d, after=%d)",
             starting_recursion_depth, st->recursion_depth);
         _PySymtable_Free(st);
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     /* Make the second symbol analysis pass */
     if (symtable_analyze(st)) {
 #if _PY_DUMP_SYMTABLE
@@ -497,8 +604,23 @@ _PySymtable_Lookup(struct symtable *st, void *key)
     PyObject *k, *v;
 
     k = PyLong_FromVoidPtr(key);
-    if (k == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[559]) {
+      if ((k == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 559\n");
+      else
+        fprintf(stderr, "reached bug index 559\n");
+    }
+    if ((!FIXREVERTER[559] && (k == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return NULL;
+        #ifdef FRCOV
+        }
+        #endif
     if (PyDict_GetItemRef(st->st_blocks, k, &v) == 0) {
         PyErr_SetString(PyExc_KeyError,
                         "unknown symbol table entry");
@@ -514,10 +636,25 @@ _PySymtable_LookupOptional(struct symtable *st, void *key,
                            PySTEntryObject **out)
 {
     PyObject *k = PyLong_FromVoidPtr(key);
-    if (k == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[560]) {
+      if ((k == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 560\n");
+      else
+        fprintf(stderr, "reached bug index 560\n");
+    }
+    if ((!FIXREVERTER[560] && (k == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         *out = NULL;
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int result = PyDict_GetItemRef(st->st_blocks, k, (PyObject **)out);
     Py_DECREF(k);
     assert(*out == NULL || PySTEntry_Check(*out));
@@ -816,9 +953,24 @@ inline_comprehension(PySTEntryObject *ste, PySTEntryObject *comp,
             // name does not exist in scope, copy from comprehension
             assert(scope != FREE || PySet_Contains(comp_free, k) == 1);
             PyObject *v_flags = PyLong_FromLong(only_flags);
-            if (v_flags == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[566]) {
+              if ((v_flags == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 566\n");
+              else
+                fprintf(stderr, "reached bug index 566\n");
+            }
+            if ((!FIXREVERTER[566] && (v_flags == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 return 0;
             }
+            #ifdef FRCOV
+            }
+            #endif
             int ok = PyDict_SetItem(ste->ste_symbols, k, v_flags);
             Py_DECREF(v_flags);
             if (ok < 0) {
@@ -962,10 +1114,25 @@ update_symbols(PyObject *symbols, PyObject *scopes,
         return 0;
 
     itr = PyObject_GetIter(free);
-    if (itr == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[574]) {
+      if ((itr == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 574\n");
+      else
+        fprintf(stderr, "reached bug index 574\n");
+    }
+    if ((!FIXREVERTER[574] && (itr == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         Py_DECREF(v_free);
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     while ((name = PyIter_Next(itr))) {
         v = PyDict_GetItemWithError(symbols, name);
@@ -1384,8 +1551,23 @@ symtable_enter_block(struct symtable *st, identifier name, _Py_block_ty block,
 {
     PySTEntryObject *ste = ste_new(st, name, block, ast,
                                    lineno, col_offset, end_lineno, end_col_offset);
-    if (ste == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[576]) {
+      if ((ste == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 576\n");
+      else
+        fprintf(stderr, "reached bug index 576\n");
+    }
+    if ((!FIXREVERTER[576] && (ste == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
     int result = symtable_enter_existing_block(st, ste);
     Py_DECREF(ste);
     return result;
@@ -1462,8 +1644,23 @@ symtable_add_def_helper(struct symtable *st, PyObject *name, int flag, struct _s
         val |= DEF_COMP_ITER;
     }
     o = PyLong_FromLong(val);
-    if (o == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[577]) {
+      if ((o == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 577\n");
+      else
+        fprintf(stderr, "reached bug index 577\n");
+    }
+    if ((!FIXREVERTER[577] && (o == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         goto error;
+        #ifdef FRCOV
+        }
+        #endif
     if (PyDict_SetItem(dict, mangled, o) < 0) {
         Py_DECREF(o);
         goto error;
@@ -1484,8 +1681,23 @@ symtable_add_def_helper(struct symtable *st, PyObject *name, int flag, struct _s
             goto error;
         }
         o = PyLong_FromLong(val);
-        if (o == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[578]) {
+          if ((o == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 578\n");
+          else
+            fprintf(stderr, "reached bug index 578\n");
+        }
+        if ((!FIXREVERTER[578] && (o == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             goto error;
+            #ifdef FRCOV
+            }
+            #endif
         if (PyDict_SetItem(st->st_global, mangled, o) < 0) {
             Py_DECREF(o);
             goto error;
@@ -2481,8 +2693,23 @@ static int
 symtable_implicit_arg(struct symtable *st, int pos)
 {
     PyObject *id = PyUnicode_FromFormat(".%d", pos);
-    if (id == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[582]) {
+      if ((id == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 582\n");
+      else
+        fprintf(stderr, "reached bug index 582\n");
+    }
+    if ((!FIXREVERTER[582] && (id == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
     if (!symtable_add_def(st, id, DEF_PARAM, ST_LOCATION(st->st_cur))) {
         Py_DECREF(id);
         return 0;
@@ -2967,16 +3194,46 @@ _Py_Mangle(PyObject *privateobj, PyObject *ident)
     while (PyUnicode_READ_CHAR(privateobj, ipriv) == '_') {
         ipriv++;
     }
-    if (ipriv == plen) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[587]) {
+      if ((ipriv == plen ) && !(0))
+        fprintf(stderr, "triggered bug index 587\n");
+      else
+        fprintf(stderr, "reached bug index 587\n");
+    }
+    if ((!FIXREVERTER[587] && (ipriv == plen ))
+    #else
+    if (0
+    #endif
+    ) {
         return Py_NewRef(ident); /* Don't mangle if class is just underscores */
     }
+    #ifdef FRCOV
+    }
+    #endif
     plen -= ipriv;
 
-    if (plen + nlen >= PY_SSIZE_T_MAX - 1) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[588]) {
+      if ((plen + nlen >= 9223372036854775807 - 1 ) && !(0))
+        fprintf(stderr, "triggered bug index 588\n");
+      else
+        fprintf(stderr, "reached bug index 588\n");
+    }
+    if ((!FIXREVERTER[588] && (plen + nlen >= 9223372036854775807 - 1 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_SetString(PyExc_OverflowError,
                         "private identifier too large to be mangled");
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     Py_UCS4 maxchar = PyUnicode_MAX_CHAR_VALUE(ident);
     if (PyUnicode_MAX_CHAR_VALUE(privateobj) > maxchar) {
diff --git a/Python/sysmodule.c b/Python/sysmodule.c
index 1fff7e41767..e3075ba1edf 100644
--- a/Python/sysmodule.c
+++ b/Python/sysmodule.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* System module */
 
@@ -74,9 +78,24 @@ PyObject *
 _PySys_GetAttr(PyThreadState *tstate, PyObject *name)
 {
     PyObject *sd = tstate->interp->sysdict;
-    if (sd == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[964]) {
+      if ((sd == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 964\n");
+      else
+        fprintf(stderr, "reached bug index 964\n");
+    }
+    if ((!FIXREVERTER[964] && (sd == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *exc = _PyErr_GetRaisedException(tstate);
     /* XXX Suppress a new exception if it was raised and restore
      * the old one. */
@@ -89,9 +108,24 @@ static PyObject *
 _PySys_GetObject(PyInterpreterState *interp, const char *name)
 {
     PyObject *sysdict = interp->sysdict;
-    if (sysdict == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[965]) {
+      if ((sysdict == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 965\n");
+      else
+        fprintf(stderr, "reached bug index 965\n");
+    }
+    if ((!FIXREVERTER[965] && (sysdict == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *value;
     if (PyDict_GetItemStringRef(sysdict, name, &value) != 1) {
         return NULL;
@@ -119,9 +153,24 @@ PySys_GetObject(const char *name)
 static int
 sys_set_object(PyInterpreterState *interp, PyObject *key, PyObject *v)
 {
-    if (key == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[966]) {
+      if ((key == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 966\n");
+      else
+        fprintf(stderr, "reached bug index 966\n");
+    }
+    if ((!FIXREVERTER[966] && (key == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     PyObject *sd = interp->sysdict;
     if (v == NULL) {
         if (PyDict_Pop(sd, key, NULL) < 0) {
@@ -3988,13 +4037,43 @@ _Py_COMP_DIAG_POP
 static int
 sys_pyfile_write_unicode(PyObject *unicode, PyObject *file)
 {
-    if (file == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1040]) {
+      if ((file == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1040\n");
+      else
+        fprintf(stderr, "reached bug index 1040\n");
+    }
+    if ((!FIXREVERTER[1040] && (file == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
     assert(unicode != NULL);
     PyObject *result = PyObject_CallMethodOneArg(file, &_Py_ID(write), unicode);
-    if (result == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1041]) {
+      if ((result == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1041\n");
+      else
+        fprintf(stderr, "reached bug index 1041\n");
+    }
+    if ((!FIXREVERTER[1041] && (result == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     Py_DECREF(result);
     return 0;
 }
@@ -4005,12 +4084,42 @@ sys_pyfile_write(const char *text, PyObject *file)
     PyObject *unicode = NULL;
     int err;
 
-    if (file == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1042]) {
+      if ((file == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1042\n");
+      else
+        fprintf(stderr, "reached bug index 1042\n");
+    }
+    if ((!FIXREVERTER[1042] && (file == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     unicode = PyUnicode_FromString(text);
-    if (unicode == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[1043]) {
+      if ((unicode == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 1043\n");
+      else
+        fprintf(stderr, "reached bug index 1043\n");
+    }
+    if ((!FIXREVERTER[1043] && (unicode == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return -1;
+        #ifdef FRCOV
+        }
+        #endif
 
     err = sys_pyfile_write_unicode(unicode, file);
     Py_DECREF(unicode);
diff --git a/Python/traceback.c b/Python/traceback.c
index 47b77c9108d..96d062516ae 100644
--- a/Python/traceback.c
+++ b/Python/traceback.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 
 /* Traceback implementation */
 
@@ -331,10 +335,25 @@ _Py_FindSourceFile(PyObject *filename, char* namebuf, size_t namelen, PyObject *
     PyObject *open = NULL;
 
     filebytes = PyUnicode_EncodeFSDefault(filename);
-    if (filebytes == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7498]) {
+      if ((filebytes == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7498\n");
+      else
+        fprintf(stderr, "reached bug index 7498\n");
+    }
+    if ((!FIXREVERTER[7498] && (filebytes == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PyErr_Clear();
         return NULL;
     }
+    #ifdef FRCOV
+    }
+    #endif
     filepath = PyBytes_AS_STRING(filebytes);
 
     /* Search tail of filename in sys.path before giving up */
@@ -354,17 +373,47 @@ _Py_FindSourceFile(PyObject *filename, char* namebuf, size_t namelen, PyObject *
     open = PyObject_GetAttr(io, &_Py_ID(open));
     for (i = 0; i < npath; i++) {
         v = PyList_GetItem(syspath, i);
-        if (v == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[7499]) {
+          if ((v == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 7499\n");
+          else
+            fprintf(stderr, "reached bug index 7499\n");
+        }
+        if ((!FIXREVERTER[7499] && (v == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_Clear();
             break;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (!PyUnicode_Check(v))
             continue;
         path = PyUnicode_EncodeFSDefault(v);
-        if (path == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[7500]) {
+          if ((path == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 7500\n");
+          else
+            fprintf(stderr, "reached bug index 7500\n");
+        }
+        if ((!FIXREVERTER[7500] && (path == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             PyErr_Clear();
             continue;
         }
+        #ifdef FRCOV
+        }
+        #endif
         len = PyBytes_GET_SIZE(path);
         if (len + 1 + (Py_ssize_t)taillen >= (Py_ssize_t)namelen - 1) {
             Py_DECREF(path);
@@ -432,8 +481,23 @@ display_source_line(PyObject *f, PyObject *filename, int lineno, int indent,
     const void *data;
 
     /* open the file */
-    if (filename == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7501]) {
+      if ((filename == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7501\n");
+      else
+        fprintf(stderr, "reached bug index 7501\n");
+    }
+    if ((!FIXREVERTER[7501] && (filename == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return 0;
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Do not attempt to open things like <string> or <stdin> */
     assert(PyUnicode_Check(filename));
@@ -445,19 +509,49 @@ display_source_line(PyObject *f, PyObject *filename, int lineno, int indent,
     }
 
     io = PyImport_ImportModule("io");
-    if (io == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7502]) {
+      if ((io == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7502\n");
+      else
+        fprintf(stderr, "reached bug index 7502\n");
+    }
+    if ((!FIXREVERTER[7502] && (io == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     binary = _PyObject_CallMethod(io, &_Py_ID(open), "Os", filename, "rb");
     if (binary == NULL) {
         PyErr_Clear();
 
         binary = _Py_FindSourceFile(filename, buf, sizeof(buf), io);
-        if (binary == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[7503]) {
+          if ((binary == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 7503\n");
+          else
+            fprintf(stderr, "reached bug index 7503\n");
+        }
+        if ((!FIXREVERTER[7503] && (binary == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             Py_DECREF(io);
             return -1;
         }
+        #ifdef FRCOV
+        }
+        #endif
     }
 
     /* use the right encoding to decode the file as unicode */
@@ -591,15 +685,45 @@ static int
 tb_displayline(PyTracebackObject* tb, PyObject *f, PyObject *filename, int lineno,
                PyFrameObject *frame, PyObject *name)
 {
-    if (filename == NULL || name == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7505]) {
+      if ((filename == (void *) 0 || name == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7505\n");
+      else
+        fprintf(stderr, "reached bug index 7505\n");
+    }
+    if ((!FIXREVERTER[7505] && (filename == (void *) 0 || name == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     PyObject *line = PyUnicode_FromFormat("  File \"%U\", line %d, in %U\n",
                                           filename, lineno, name);
-    if (line == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7506]) {
+      if ((line == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7506\n");
+      else
+        fprintf(stderr, "reached bug index 7506\n");
+    }
+    if ((!FIXREVERTER[7506] && (line == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     int res = PyFile_WriteObject(line, f, Py_PRINT_RAW);
     Py_DECREF(line);
@@ -633,9 +757,24 @@ tb_print_line_repeated(PyObject *f, long cnt)
           ? "  [Previous line repeated %ld more times]\n"
           : "  [Previous line repeated %ld more time]\n",
         cnt);
-    if (line == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7508]) {
+      if ((line == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7508\n");
+      else
+        fprintf(stderr, "reached bug index 7508\n");
+    }
+    if ((!FIXREVERTER[7508] && (line == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return -1;
     }
+    #ifdef FRCOV
+    }
+    #endif
     int err = PyFile_WriteObject(line, f, Py_PRINT_RAW);
     Py_DECREF(line);
     return err;
@@ -655,10 +794,27 @@ tb_printinternal(PyTracebackObject *tb, PyObject *f, long limit)
         depth++;
         tb1 = tb1->tb_next;
     }
-    while (tb != NULL && depth > limit) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7509])
+      fprintf(stderr, "reached bug index 7509\n");
+    while ((FIXREVERTER[7509] && (depth > limit )) || (!FIXREVERTER[7509] && (tb != (void *) 0 && depth > limit ))
+    #else
+    while (depth > limit 
+    #endif
+    ) {
+      
+    #ifdef FRCOV
+      if (!(tb != (void *) 0 ))
+        fprintf(stderr, "triggered bug index 7509\n");
+      #endif
+    
         depth--;
         tb = tb->tb_next;
     }
+    #ifdef FRCOV
+    }
+    #endif
     while (tb != NULL) {
         code = PyFrame_GetCode(tb->tb_frame);
         int tb_lineno = tb->tb_lineno;
@@ -712,9 +868,24 @@ _PyTraceBack_Print(PyObject *v, const char *header, PyObject *f)
     PyObject *limitv;
     long limit = PyTraceBack_LIMIT;
 
-    if (v == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7510]) {
+      if ((v == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7510\n");
+      else
+        fprintf(stderr, "reached bug index 7510\n");
+    }
+    if ((!FIXREVERTER[7510] && (v == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         return 0;
     }
+    #ifdef FRCOV
+    }
+    #endif
     if (!PyTraceBack_Check(v)) {
         PyErr_BadInternalCall();
         return -1;
@@ -824,8 +995,23 @@ _Py_DumpASCII(int fd, PyObject *text)
     }
     else {
         data = _PyUnicodeObject_CAST(text)->data.any;
-        if (data == NULL)
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[7512]) {
+          if ((data == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 7512\n");
+          else
+            fprintf(stderr, "reached bug index 7512\n");
+        }
+        if ((!FIXREVERTER[7512] && (data == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        )
             return;
+            #ifdef FRCOV
+            }
+            #endif
     }
 
     if (MAX_STRING_LENGTH < size) {
@@ -956,14 +1142,41 @@ dump_traceback(int fd, PyThreadState *tstate, int write_header)
     }
 
     _PyInterpreterFrame *frame = tstate->current_frame;
-    if (frame == NULL) {
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7513]) {
+      if ((frame == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7513\n");
+      else
+        fprintf(stderr, "reached bug index 7513\n");
+    }
+    if ((!FIXREVERTER[7513] && (frame == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    ) {
         PUTS(fd, "  <no Python frame>\n");
         return;
     }
+    #ifdef FRCOV
+    }
+    #endif
 
     unsigned int depth = 0;
     while (1) {
-        if (MAX_FRAME_DEPTH <= depth) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[7514]) {
+          if ((100 <= depth ) && !(0))
+            fprintf(stderr, "triggered bug index 7514\n");
+          else
+            fprintf(stderr, "reached bug index 7514\n");
+        }
+        if ((!FIXREVERTER[7514] && (100 <= depth ))
+        #else
+        if (0
+        #endif
+        ) {
             if (MAX_FRAME_DEPTH < depth) {
                 PUTS(fd, "plus ");
                 _Py_DumpDecimal(fd, depth);
@@ -971,18 +1184,51 @@ dump_traceback(int fd, PyThreadState *tstate, int write_header)
             }
             break;
         }
+        #ifdef FRCOV
+        }
+        #endif
         dump_frame(fd, frame);
         frame = frame->previous;
-        if (frame == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[7515]) {
+          if ((frame == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 7515\n");
+          else
+            fprintf(stderr, "reached bug index 7515\n");
+        }
+        if ((!FIXREVERTER[7515] && (frame == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             break;
         }
+        #ifdef FRCOV
+        }
+        #endif
         if (frame->owner == FRAME_OWNED_BY_CSTACK) {
             /* Trampoline frame */
             frame = frame->previous;
         }
-        if (frame == NULL) {
+        
+        #ifdef FRCOV
+        {if (FIXREVERTER[7516]) {
+          if ((frame == (void *) 0 ) && !(0))
+            fprintf(stderr, "triggered bug index 7516\n");
+          else
+            fprintf(stderr, "reached bug index 7516\n");
+        }
+        if ((!FIXREVERTER[7516] && (frame == (void *) 0 ))
+        #else
+        if (0
+        #endif
+        ) {
             break;
         }
+        #ifdef FRCOV
+        }
+        #endif
         /* Can't have more than one shim frame in a row */
         assert(frame->owner != FRAME_OWNED_BY_CSTACK);
         depth++;
@@ -1051,10 +1297,25 @@ _Py_DumpTracebackThreads(int fd, PyInterpreterState *interp,
     if (interp == NULL) {
         if (current_tstate == NULL) {
             interp = _PyGILState_GetInterpreterStateUnsafe();
-            if (interp == NULL) {
+            
+            #ifdef FRCOV
+            {if (FIXREVERTER[7517]) {
+              if ((interp == (void *) 0 ) && !(0))
+                fprintf(stderr, "triggered bug index 7517\n");
+              else
+                fprintf(stderr, "reached bug index 7517\n");
+            }
+            if ((!FIXREVERTER[7517] && (interp == (void *) 0 ))
+            #else
+            if (0
+            #endif
+            ) {
                 /* We need the interpreter state to get Python threads */
                 return "unable to get the interpreter state";
             }
+            #ifdef FRCOV
+            }
+            #endif
         }
         else {
             interp = current_tstate->interp;
@@ -1068,8 +1329,23 @@ _Py_DumpTracebackThreads(int fd, PyInterpreterState *interp,
 
     /* Get the current interpreter from the current thread */
     PyThreadState *tstate = PyInterpreterState_ThreadHead(interp);
-    if (tstate == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[7518]) {
+      if ((tstate == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 7518\n");
+      else
+        fprintf(stderr, "reached bug index 7518\n");
+    }
+    if ((!FIXREVERTER[7518] && (tstate == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return "unable to get the thread head state";
+        #ifdef FRCOV
+        }
+        #endif
 
     /* Dump the traceback of each thread */
     tstate = PyInterpreterState_ThreadHead(interp);
diff --git a/Python/tracemalloc.c b/Python/tracemalloc.c
index fee7dd0e56d..7636e1ea590 100644
--- a/Python/tracemalloc.c
+++ b/Python/tracemalloc.c
@@ -1,3 +1,7 @@
+#ifdef FRCOV
+#include <stdio.h>
+extern short FIXREVERTER[];
+#endif
 #include "Python.h"
 #include "pycore_fileutils.h"     // _Py_write_noraise()
 #include "pycore_gc.h"            // PyGC_Head
@@ -1279,8 +1283,23 @@ _PyMem_DumpTraceback(int fd, const void *ptr)
     }
 
     traceback = tracemalloc_get_traceback(DEFAULT_DOMAIN, (uintptr_t)ptr);
-    if (traceback == NULL)
+    
+    #ifdef FRCOV
+    {if (FIXREVERTER[4256]) {
+      if ((traceback == (void *) 0 ) && !(0))
+        fprintf(stderr, "triggered bug index 4256\n");
+      else
+        fprintf(stderr, "reached bug index 4256\n");
+    }
+    if ((!FIXREVERTER[4256] && (traceback == (void *) 0 ))
+    #else
+    if (0
+    #endif
+    )
         return;
+        #ifdef FRCOV
+        }
+        #endif
 
     PUTS(fd, "Memory block allocated at (most recent call first):\n");
     for (i=0; i < traceback->nframe; i++) {
